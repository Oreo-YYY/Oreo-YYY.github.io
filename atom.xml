<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://y-rui.github.io</id>
    <title>NoteForStudy</title>
    <updated>2020-12-30T17:05:42.273Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://y-rui.github.io"/>
    <link rel="self" href="https://y-rui.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://y-rui.github.io/images/avatar.png</logo>
    <icon>https://y-rui.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, NoteForStudy</rights>
    <entry>
        <title type="html"><![CDATA[详解 FTP、FTPS 与 SFTP]]></title>
        <id>https://y-rui.github.io/post/xiang-jie-ftpftps-yu-sftp/</id>
        <link href="https://y-rui.github.io/post/xiang-jie-ftpftps-yu-sftp/">
        </link>
        <updated>2020-12-30T16:57:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="ftp-ftps-与-sftp-简介">FTP、FTPS 与 SFTP 简介</h2>
<p><strong>FTP</strong><br>
在看相关功能之前，二狗子发现客户端有三种不同的协议，分别是 FTP、FTPS 与 SFTP，为了弄清楚这是什么，二狗子打开了万能的百科。<br>
首先来了解一下什么是 FTP，维基百科说：FTP 即 文件传输协议（英语：File Transfer Protocol 的缩写）是一个用于计算机网络上在客户端和服务器之间进行文件传输的应用层协议。完整的 FTP 是由 FTP 服务器 和 FTP 客户端组成的，客户端可以将本地的文件通过 FTP 协议上传到服务器，也可以将服务器的文件下载到本地。它是当今使用的最古老的文件传输协议之一，是一种非常便捷的移动文件的方式。</p>
<p><strong>FTP 的工作原理</strong><br>
FTP 连接需要 FTP 服务器和客户端两方在网络上建立通信。建立 FTP 连接时会有两个不同的通信通道。一个被称为命令通道，它的作用是发出和响应指令。另一个为数据通道，用于客户端和服务器端进行数据交互。<br>
使用 FTP 传输文件时，用户需要通过向 FTP 服务器提供凭据来获得文件传输许可。当然某些公共 FTP 服务器可能不需要凭据即可访问其文件，但是无法保证数据传输的安全性，任何未加密公共网络上的数据发送都是非常危险的，所以为了保护传输数据的安全，由 FTP 衍生而出的就是下面的两种协议：FTPS 与 SFTP。</p>
<p><strong>FTPS</strong><br>
接下来二狗子查询了一下，发现 FPTS 有 FTPS 隐式 SSL 和 FTPS 显示 SSL 两种模式，两者都是用 SSL 加密。那么两者有什么区别呢？</p>
<ul>
<li>FTPS 隐式 SSL：该模式通常在端口 990 上运行。在这个模式下全部数据的交换都需要在客户端和服务器之间建立 SSL 会话，并且服务器会拒绝任何不使用 SSL 进行的连接尝试。</li>
<li>FTPS 显式 SSL：显示 SSL 下服务器可以同时支持 FTP 和 FTPS 会话。开始会话前客户端需要先建立与 FTP 服务器的未加密连接，并在发送用户凭证前先发送 AUTH TLS 或 AUTH SSL 命令来请求服务器将命令通道切换到 SSL 加密通道，成功建立通道后再将用户凭证发送到 FTP 服务器，从而保证在会话期间的任何命令都可以通过 SSL 通道自动加密。</li>
</ul>
<p>二狗子来给大家简单快速的总结一下。当启用隐式模式时，FTP 的默认端口就被改为 TCP/990，服务器自动建立安全连接，并且要求客户端也必须支持安全连接模式也就是使用 SSL 进行连接。当启用显式模式时，与 FTP 连接方式和默认端口一样，但是需要以命令 AUTH SSL/TLS 类型的命令进行激活安全连接后才能正常传输数据。</p>
<p><strong>SFTP</strong><br>
最后大家来一起看看 SFTP，SFTP 是 Secure File Transfer Protocol 的缩写，也叫作安全文件传送协议。</p>
<p>如果说 FTPS 是在 FTP 协议上增加了一层 SSL ，那么 SFTP 就是是基于网络协议SSH（安全外壳）的协议与前面所说的 FTP 完全不同。SFTP 不使用单独的命令通道和数据通道，而是数据和命令都会通过单个连接以特殊格式的数据包进行传输。</p>
<p>SFTP 提供了两种验证连接的方法。</p>
<ul>
<li>与 FTP 一样，连接时只需要验证用户 ID 和密码就可以了。但是，与FTP不同的是，这些凭据是加密的，这是 SFTP 最主要的安全优势。</li>
<li>除密码外，还可以通过 SSH 密钥来验证并通过 SFTP 协议连接。</li>
</ul>
<p>了解了这几个协议之后，二狗子使用 FTP 客户端工具就更加顺手了，他可以根据自己的需求更改协议以及加密方式，而不用为不懂某个设置而烦恼。<br>
<img src="https://y-rui.github.io/post-images/1609347666217.png" alt="" loading="lazy"><br>
但是，新的疑问又出现了，二狗子看到这里的传输设置中的传输模式，有主动和被动之分，这又是什么意思呢。不懂就问的他又打开了 Google…<br>
<img src="https://y-rui.github.io/post-images/1609347681998.png" alt="" loading="lazy"></p>
<h2 id="ftp-软件的主动模式和被动模式的区别">FTP 软件的主动模式和被动模式的区别</h2>
<p><strong>主动模式</strong><br>
一般 FTP 的默认模式就是主动模式，也称为 port 模式。</p>
<p>它是通过两个步骤来进行工作的：</p>
<ul>
<li>首先客户端上的随机端口与服务器上的 FTP 端口 21 建立命令通道，客户端发送 PORT 命令，指定服务器与客户端其中一个端口连接，并建立数据通道。</li>
<li>然后服务器从端口 20 连接到为数据通道指定的客户端端口。建立连接后，即可通过这些客户端和服务器端口进行文件传输。</li>
</ul>
<p><strong>被动模式</strong><br>
在传输方式栏，你还可以手动调整为被动传输模式，在该模式下用户端进行文件传输时，会先通过随机端口 A 连接到服务器上的端口 21，并发出 PASV 命令建立命令通道，告诉服务端这次是被动模式连接。之后服务器会打开一个随机端口用于数据传输，而客户端通过与发出命令的端口不同的随机端口 B 建立数据通道，从而进行文件传输。<br>
<img src="https://y-rui.github.io/post-images/1609347745767.png" alt="" loading="lazy"><br>
被动模式与主动模式不同的地方就是客户端启动数据连接。在主动模式下，客户端在命令通道上建立连接后，服务器将启动与客户端的数据连接。而在被动模式下，建立命令通道后，由客户端启动与服务器的数据连接。</p>
<p>因为这个区别，可以得出两者的优势和缺陷。比如主动模式有利于管理 FTP 服务端，因为只需要打开 21 端口的“准入”、20 端口的“准出” 即可，但是由于服务器连接到客户端的端口随机，所以客户端有可能会触发防火墙，甚至直接被防火墙拦截掉。反之被动模式则有利于管理客户端。</p>
<p>没想到一个看似简单的存储工具居然还有着这么多的分类和区别，不同的模式不同的方式都可以对应不同的需求，看来以后在使用工具的时候还是可以多少了解一点相关知识，能让工具用起来更顺手更舒心~</p>
<p>| 来自：知乎，作者： 又拍云<br>
| 链接：https://zhuanlan.zhihu.com/p/208617545</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MacOS下MySQL8.0忘记密码重置操作]]></title>
        <id>https://y-rui.github.io/post/macos-xia-mysql80-wang-ji-mi-ma-chong-zhi-cao-zuo/</id>
        <link href="https://y-rui.github.io/post/macos-xia-mysql80-wang-ji-mi-ma-chong-zhi-cao-zuo/">
        </link>
        <updated>2020-12-30T16:40:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="关闭数据库服务">关闭数据库服务</h2>
<h2 id="跳过权限认证">跳过权限认证</h2>
<pre><code>// 进入数据库指令文件
cd /usr/local/mysql/bin
// 跳过权限认证
sudo ./mysqld_safe --skip-grant-tables
</code></pre>
<h2 id="免密码进入数据库">免密码进入数据库</h2>
<p>在上述指令运行后，新开一个终端，同时保持原来那个终端也开着，在新的终端输入指令如下：</p>
<pre><code>//  执行mysql指令
/usr/local/mysql/bin/mysql
// 进入名为&lt;mysql&gt;的数据库
use mysql
// 刷新权限
flush privileges;
// 修改密码 但不适用于8.0+的版本
// set password for 'root'@'localhost' = password('新的密码');
// 8.0+版本修改密码
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'root123456';

// 退出mysql
exit
</code></pre>
<h2 id="配置环境变量">配置环境变量</h2>
<p>vi ~/.zshrc，在这里面添加：</p>
<p>export PATH=${PATH}:/usr/local/mysql/bin</p>
<p>保存后 source ~/.zshrc</p>
<h2 id="mac-navicat-出现-2003-cant-connect-to-mysql-server-on-127001-61-connection-refused">Mac Navicat 出现 2003 - Can't connect to MySQL server on '127.0.0.1' (61 &quot;Connection refused&quot;)</h2>
<ol>
<li>
<p>首先找到你的数据库鼠标右键编辑链接；</p>
</li>
<li>
<p>找到第二个选项勾选上 useSockt file;</p>
</li>
</ol>
<h2 id="命令行中停止mysql服务">命令行中停止mysql服务</h2>
<pre><code>sudo /usr/local/mysql/bin/mysqladmin -u root -p root123456 shutdown
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hadoop基础1-Hadoop 介绍与安装]]></title>
        <id>https://y-rui.github.io/post/hadoop-ji-chu-1-hadoop-jie-shao-yu-an-zhuang/</id>
        <link href="https://y-rui.github.io/post/hadoop-ji-chu-1-hadoop-jie-shao-yu-an-zhuang/">
        </link>
        <updated>2020-12-20T13:06:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="hadoop-介绍">Hadoop 介绍</h2>
<ul>
<li>Apache Hadoop 软件库是一个框架，允许在集群服务器上使用简单的编程模型对大数据集进行分布式处理。Hadoop 被设计成能够从单台服务器扩展到数以千计的服务器，每台服务器都有本地的计算和存储资源。Hadoop 的高可用性并不依赖硬件，其代码库自身就能在应用层侦测并处理硬件故障，因此能基于服务器集群提供高可用性的服务</li>
</ul>
<h2 id="hadoop-生态系统">Hadoop 生态系统</h2>
<p>经过多年的发展形成了 Hadoop1.X 生态系统，其结构如下图所示<br>
<img src="https://y-rui.github.io/post-images/1608469835785.png" alt="" loading="lazy"></p>
<ul>
<li>HDFS：Hadoop 生态圈的基本组成部分是 Hadoop 分布式文件系统（HDFS）。HDFS 是一种分布式文件系统，数据被保存在计算机集群上，HDFS 为 HBase 等工具提供了基础</li>
<li>MapReduce：Hadoop 的主要执行框架是 MapReduce，它是一个分布式、并行处理的编程模型，MapReduce 把任务分为 map（映射）阶段和 reduce（化简）阶段。由于 MapReduce 工作原理的特性，Hadoop 能以并行的方式访问数据，从而实现快速访问数据</li>
<li>Hbase：HBase 是一个建立在 HDFS 之上，面向列的 NoSQL 数据库，用于快速读 / 写大量数据，HBase 使用 Zookeeper 进行管理</li>
<li>Zookeeper：用于 Hadoop 的分布式协调服务。Hadoop 的许多组件依赖于 Zookeeper，它运行在计算机集群中，用于管理 Hadoop 集群</li>
<li>Pig：它是 MapReduce 编程的复杂性的抽象。Pig 平台包括运行环境和用于分析 Hadoop 数据集的脚本语言 (Pig Latin)，其编译器将 Pig Latin 翻译成 MapReduce 程序序列</li>
<li>Hive：类似于 SQL 高级语言，用于运行存储在 Hadoop 上的查询语句，Hive 让不熟悉 MapReduce 的开发人员也能编写数据查询语句，然后这些语句被翻译为 Hadoop 上面的 MapReduce 任务。像 Pig 一样，Hive 作为一个抽象层工具，吸引了很多熟悉 SQL 而不是 Java 编程的数据分析师</li>
<li>Sqoop：一个连接工具，用于在关系数据库、数据仓库和 Hadoop 之间转移数据。Sqoop 利用数据库技术描述架构，进行数据的导入 / 导出；利用 MapReduce 实现并行化运行和容错技术</li>
<li>Flume：提供了分布式、可靠、高效的服务，用于收集、汇总大数据，并将单台计算机的大量数据转移到 HDFS。它基于一个简单而灵活的架构，利用简单的可扩展的数据模型，将企业中多台计算机上的数据转移到 Hadoop 中</li>
</ul>
<h2 id="apache-版本衍化">Apache 版本衍化</h2>
<ul>
<li>Apache Hadoop 版本分为两代，我们将第一代 Hadoop 称为 Hadoop 1.0，第二代 Hadoop 称为 Hadoop 2.0</li>
<li>第一代 Hadoop 包含三个大版本，分别是 0.20.x，0.21.x 和 0.22.x。其中，0.20.x 最后演化成 1.0.x，变成了稳定版，而 0.21.x 和 0.22.x 则包括 NameNode HA 等新的重大特性</li>
<li>第二代 Hadoop 包含两个版本，分别是 0.23.x 和 2.x，它们完全不同于 Hadoop 1.0，是一套全新的架构，均包含 HDFS Federation 和 YARN 两个系统，相比于 0.23.x，2.x 增加了 NameNode HA 和 Wire-compatibility 两个重大特性</li>
</ul>
<h2 id="hadoop1x-伪分布安装">Hadoop1.X 伪分布安装</h2>
<p>Hadoop 安装有如下三种方式</p>
<ul>
<li>单机模式：安装简单，几乎不用做任何配置，但仅限于调试用途</li>
<li>伪分布模式：在单节点上同时启动 NameNode、DataNode、JobTracker、TaskTracker、Secondary Namenode 等 5 个进程，模拟分布式运行的各个节点</li>
<li>完全分布式模式：正常的 Hadoop 集群，由多个各司其职的节点构成</li>
</ul>
<p><strong>软硬件环境说明</strong></p>
<ul>
<li>节点使用 CentOS 系统，防火墙和 SElinux 需要禁用，创建了一个 shiyanlou 用户，并在系统根目录下创建 /app 目录，用于存放 Hadoop 等组件运行包。由于该目录用于安装 hadoop 等组件程序，用户对 shiyanlou 必须赋予 rwx 权限（一般做法是 root 用户在根目录下创建 /app 目录，并修改该目录拥有者为 shiyanlou(chown –R shiyanlou:shiyanlou /app)</li>
</ul>
<p><strong>Hadoop 搭建环境</strong></p>
<ul>
<li>虚拟机操作系统：CentOS6.6 64 位，单核，1G 内存</li>
<li>JDK：1.7.0_55 64 位</li>
<li>Hadoop：1.1.2</li>
</ul>
<p><strong>环境搭建</strong><br>
配置本地环境</p>
<p>设置机器名<br>
使用 sudo vi /etc/sysconfig/network<br>
打开配置文件，根据实际情况设置该服务器的机器名，新机器名在重启后生效</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring框架基础1-概述]]></title>
        <id>https://y-rui.github.io/post/spring-kuang-jia-ji-chu-1-gai-shu/</id>
        <link href="https://y-rui.github.io/post/spring-kuang-jia-ji-chu-1-gai-shu/">
        </link>
        <updated>2020-09-01T12:24:16.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>本节课程将介绍什么是 Spring。Spring 是一个容器，通过反转控制（IoC）和依赖注入（DI）来实现高内聚、低耦合的应用。除此之外它可以整合很多第三方框架，它还提供面向切面编程（AOP）的能力，对数据库事务的管理尤其方便。</li>
</ul>
<h2 id="spring-是什么">Spring 是什么</h2>
<p>Spring 是一个开源的轻量级 Java SE（Java 标准版本）/Java EE（Java 企业版本）开发应用框架，其目的是用于简化企业级应用程序开发。在传统应用程序开发中，一个完整的应用是由一组相互协作的对象组成的。所以开发一个应用除了要开发业务逻辑之外，最多的是关注使这些对象协作来完成所需功能的同时，实现低耦合、高内聚。所以，业务逻辑开发是不可避免的。如果有个框架可以帮我们来创建对象及管理这些对象之间的依赖关系，能通过配置方式来创建对象，管理对象之间依赖关系，我们不需要通过工厂和生成器来创建及管理对象之间的依赖关系，这样我们必然会减少许多工作量，加快开发。Spring 框架问世之初主要就是来完成这个功能。</p>
<p>Spring 框架除了帮我们管理对象及其依赖关系，还提供像通用日志记录、性能统计、安全控制、异常处理等面向切面的能力，可以帮我们管理最头疼的数据库事务，同时，它本身提供了一套简单的 JDBC 访问实现，能与第三方数据库访问框架集成（如 Hibernate、JPA），与各种 Java EE 技术整合（如 Java Mail、任务调度等等），提供一套自己的 Web 层框架 Spring MVC、而且还能非常简单的与第三方 Web 框架集成。从这里我们可以认为 Spring 是一个超级粘合平台，除了自己提供功能外，还提供粘合其他技术和框架的能力，从而使我们可以更自由的选择到底使用什么技术进行开发。而且不管是 JAVA SE（C/S 架构）应用程序还是 JAVA EE（B/S 架构）应用程序都可以使用这个平台进行开发。让我们来深入看一下 Spring 到底能帮我们做些什么？</p>
<h2 id="spring-能帮我们做什么">Spring 能帮我们做什么</h2>
<p><strong>Spring 能帮我们根据配置文件创建及组装对象之间的依赖关系</strong><br>
传统程序开发，创建对象及组装对象间依赖关系由我们在程序内部进行控制，这样会加大各个对象间的耦合，如果我们要修改对象间的依赖关系就必须修改源代码，重新编译、部署。而如果采用 Spring，则由 Spring 根据配置文件来进行创建及组装对象间依赖关系，只需要修改配置文件即可，无需重新编译。</p>
<p><strong>Spring 面向切面编程能帮助我们无耦合的实现日志记录、性能统计、安全控制</strong><br>
当我们要进行一些日志记录、权限控制、性能统计等工作时，在传统应用程序当中我们可能在需要的对象或方法中进行，而且比如权限控制、性能统计大部分是重复的，这样代码中就存在大量重复代码，即使把通用部分提取出来，仍旧存在重复调用。</p>
<p>像性能统计我们可能只是在必要时才进行，在诊断完毕后要删除这些代码；还有日志记录，比如记录一些方法访问日志、数据访问日志等等，这些都会渗透到各个访问方法中；还有权限控制，必须在方法执行时开始进行审核，可见这些工作急需优化。如果采用 Spring，这些日志记录、权限控制、性能统计从业务逻辑中分离出来，通过 Spring 支持的面向切面编程，动态添加这些功能，无需渗透到各个需要的方法或对象中。</p>
<p>反观其他的解决方案，通过使用“代理设计模式”或“包装器设计模式”，仍需通过编程方式来创建代理对象，仍需耦合这些代理对象，而采用 Spring 面向切面编程能提供一种更好的方式来完成上述功能。通过配置方式，而不需要在现有代码中添加任何额外代码，使现有代码专注业务逻辑。</p>
<p><strong>Spring 能非常简单的帮我们管理数据库事务</strong><br>
在传统应用程序当中，我们如何来完成数据库事务管理？需要一系列“获取连接，执行 SQL，提交或回滚事务，关闭连接”，而且还要保证在最后一定要关闭连接，多么可怕的事情，而且也很无聊。如果采用 Spring，我们只需获取连接，执行 SQL，其他的都交给 Spring 来管理，简单方便。</p>
<p><strong>除以上之外，Spring 还可以：</strong></p>
<ul>
<li>与第三方数据库访问框架（如 Hibernate、JPA）无缝集成，而且自己也提供了一套 JDBC 访问模板，来方便数据库访问。</li>
<li>与第三方 Web（如 Struts、JSF）框架无缝集成，而且自己也提供了一套 Spring MVC 框架，来方便 Web 层搭建。</li>
<li>与 Java EE（如 Java Mail、任务调度）整合，与更多技术整合（比如缓存框架）。</li>
</ul>
<h2 id="spring-的优点">Spring 的优点</h2>
<p><strong>关键概念</strong></p>
<ul>
<li>应用程序：能完成我们所需要功能的成品，比如购物网站、OA 系统。</li>
<li>框架：能完成一定功能的半成品，比如我们可以使用框架进行购物网站开发。框架做一部分功能，我们自己做一部分功能，辅助高效工作。而且框架规定了你在开发应用程序时的整体架构，提供了一些基础功能，还规定了类和对象的如何创建、如何协作等，从而简化我们的代码编写，让我们专注于业务逻辑开发。</li>
<li>非侵入式设计：从框架角度可以这样理解，无需继承框架提供的类，这种设计就可以看作是非侵入式设计；如果继承了这些框架类，就是侵入设计。如果以后想更换框架，之前写过的代码几乎无法重用，如果非侵入式设计则之前写过的代码仍然可以继续使用。</li>
<li>轻量级与重量级：轻量级是相对于重量级而言的，轻量级一般就是非入侵性的、所依赖的东西非常少、资源占用非常少、部署简单等等，其实就是比较容易使用，而重量级正好相反。</li>
<li>POJO：Plain Ordinary Java Object，简单的 Java 对象。它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其它 Java 框架的类或接口。</li>
<li>容器：在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是装对象的对象，因为存在放入、拿出等操作，所以容器还要管理对象的生命周期。</li>
<li>控制反转：即 Inversion of Control，缩写为 IoC，控制反转还有一个名字叫做依赖注入（Dependency Injection），就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。</li>
<li>Bean：一般指容器管理对象，在 Spring 中指 Spring IoC 容器管理对象。</li>
</ul>
<p><strong>Spring 的优点</strong></p>
<ul>
<li>非常轻量级的容器：以集中的、自动化的方式进行应用程序对象创建和装配，除此之外还会负责管理对象生命周期，能组合成复杂的应用程序。Spring 容器是非侵入式的（不需要依赖任何 Spring 特定类），而且完全采用 POJOs 进行开发，使应用程序更容易测试、更容易管理。而且核心 jar 包非常小，Spring 3.0.5 不到 1 M，而且不需要依赖任何应用服务器，可以部署在任何环境（Java SE 或 Java EE）。</li>
<li>AOP：AOP 是 Aspect Oriented Programming 的缩写，意思是面向切面编程。从另一个角度来考虑程序结构以完善面向对象编程（OOP），<em>即可以通过在编译期间、装载期间或运行期间实现在不修改源代码的情况下给程序动态添加功能的一种技术</em>。通俗点说就是把可重用的功能提取出来，然后将这些通用功能在合适的时候织入到应用程序中。比如安全，日志记录，这些都是通用的功能，我们可以把它们提取出来，然后在程序执行的合适地方植入这些代码并执行它们，从而完成需要的功能并复用了这些功能。</li>
<li>简单的数据库事务管理：在使用数据库的应用程序当中，自己管理数据库事务是一项很让人头疼的事，而且很容易出现错误，Spring 支持可插入的事务管理支持，而且无需 JavaEE 环境支持，通过 Spring 管理事务可以把我们从事务管理中解放出来来专注业务逻辑。</li>
<li>JDBC 抽象及 ORM（对象关系映射）框架支持：Spring 使 JDBC 更加容易使用。提供 DAO（数据访问对象）支持，非常方便集成第三方 ORM 框架，比如 Hibernate 等。并且完全支持 Spring 事务和使用 Spring 提供的一致的异常体系。</li>
<li>灵活的 Web 层支持：Spring 本身提供一套非常强大的 MVC 框架，而且可以非常容易的与第三方 MVC 框架集成，比如 Struts 等。</li>
<li>简化各种技术集成：提供对 Java Mail、任务调度、JMX、JMS、JNDI、EJB、动态语言、远程访问、Web Service 等的集成。</li>
</ul>
<p>Spring 能帮助我们简化应用程序开发，帮助我们创建和组装对象，为我们管理事务，简单的 MVC 框架，可以把 Spring 看作是一个超级粘合平台，能把很多技术整合在一起，形成一个整体，使系统结构更优良、性能更出众，从而加速我们程序开发。有如上优点，我们没有理由不考虑使用它。</p>
<h2 id="如何学好-spring">如何学好 Spring</h2>
<p>要学好 Spring，首先要明确 Spring 是个什么东西，能帮我们做些什么事情，知道了这些然后做个简单的例子，这样就基本知道怎么使用 Spring 了。Spring 核心是 IoC 容器，所以一定要透彻理解什么是控制反转（IoC）容器，以及如何配置及使用容器，其他所有技术都是基于容器实现的。理解好 IoC 后，接下来是面向切面编程（AOP），首先还是明确概念，基本配置，最后是实现原理，接下来就是数据库事务管理。其实 Spring 管理事务是通过面向切面编程实现的，所以基础很重要，IoC 容器和 AOP 学好，其余都是基于这两个核心东西的实现，学起来就更加轻松了。</p>
<h2 id="spring-架构图">Spring 架构图</h2>
<figure data-type="image" tabindex="1"><img src="https://y-rui.github.io/post-images/1608771232334.png" alt="" loading="lazy"></figure>
<p><strong>核心容器：包括 Core、Beans、Context、EL 模块</strong></p>
<ul>
<li>Core 模块：封装了框架依赖的最底层部分，包括资源访问、类型转换及一些常用工具类。</li>
<li>Beans 模块：提供了框架的基础部分，包括控制反转（IOC）和依赖注入（DI）。其中 BeanFactory 是容器核心，本质是“工厂设计模式”的实现，而且无需编程实现“单例设计模式”，单例完全由容器控制，而且提倡面向接口编程，而非面向实现编程。所有应用程序对象及对象间关系由框架管理，从而真正从程序逻辑中把维护对象之间的依赖关系提取出来，所有这些依赖关系都由 BeanFactory 来维护。</li>
<li>Context 模块：以 Core 和 Beans 为基础，集成 Beans 模块功能并添加资源绑定、数据验证、国际化、Java EE 支持、容器生命周期、事件传播等。核心接口是 ApplicationContext。</li>
<li>EL 模块：提供强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从 Spring 容器获取 Bean，它也支持列表投影、选择和一般的列表聚合等。</li>
</ul>
<p><strong>AOP、Aspects 模块</strong></p>
<ul>
<li>AOP 模块：Spring AOP 模块提供了符合 AOP Alliance 规范的面向切面的编程（aspect-oriented programming）实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中，这样各专其职，降低业务逻辑和通用功能的耦合。</li>
<li>Aspects 模块：提供了对 AspectJ 的集成，AspectJ 提供了比 Spring ASP 更强大的功能。</li>
<li>数据访问/集成模块：该模块包括了 JDBC、ORM、OXM、JMS 和事务管理。</li>
<li>事务模块：该模块用于 Spring 管理事务，只要是 Spring 管理对象都能得到 Spring 管理事务的好处，无需在代码中进行事务控制了，而且支持编程和声明性的事务管理。</li>
<li>JDBC 模块：提供了一个 JDBC 的样例模板，使用这些模板能消除传统冗长的 JDBC 编码还有必须的事务控制，而且能享受到 Spring 管理事务的好处。</li>
<li>ORM 模块：提供与流行的“对象-关系”映射框架的无缝集成，包括 Hibernate、JPA、MyBatis 等。而且可以使用 Spring 事务管理，无需额外控制事务。</li>
<li>OXM 模块：提供了一个对 Object/XML 映射实现，将 java 对象映射成 XML 数据，或者将 XML 数据映射成 java 对象，Object/XML 映射实现包括 JAXB、Castor、XMLBeans 和 XStream。</li>
<li>JMS 模块：用于 JMS（Java Messaging Service），提供一套“消息生产者、消息消费者”模板用于更加简单的使用 JMS。JMS 用于用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</li>
<li>Web/Remoting 模块：Web/Remoting 模块包含了 Web、Web-Servlet、Web-Struts、Web-Porlet 模块。</li>
<li>Web 模块：提供了基础的 Web 功能。例如多文件上传、集成 IoC 容器、远程过程访问（RMI、Hessian、Burlap）以及 Web Service 支持，并提供一个 RestTemplate 类来提供方便的 Restful services 访问。</li>
<li>Web-Servlet 模块：提供了一个 Spring MVC Web 框架实现。Spring MVC 框架提供了基于注解的请求资源注入、更简单的数据绑定、数据验证等及一套非常易用的 JSP 标签，完全无缝与 Spring 其他技术协作。</li>
<li>Web-Struts 模块：提供了与 Struts 无缝集成，Struts 1.x 和 Struts 2.x 都支持。</li>
<li>Test 模块：Spring 支持 Junit 和 TestNG 测试框架，而且还额外提供了一些基于 Spring 的测试功能，比如在测试 Web 框架时，模拟 Http 请求的功能。</li>
</ul>
<h2 id="典型应用场景">典型应用场景</h2>
<p>Spring 可以应用到许多场景，从最简单的标准 Java SE 程序到企业级应用程序都能使用 Spring 来构建。以下介绍几个比较流行的应用场景：</p>
<ul>
<li>典型 Web 应用程序应用场景：</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://y-rui.github.io/post-images/1608771369230.png" alt="" loading="lazy"></figure>
<ul>
<li>远程访问应用场景：</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://y-rui.github.io/post-images/1608771390589.png" alt="" loading="lazy"></figure>
<ul>
<li>EJB 应用场景：</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://y-rui.github.io/post-images/1608771414258.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础13-设计模式]]></title>
        <id>https://y-rui.github.io/post/java-ji-chu-13-she-ji-mo-shi/</id>
        <link href="https://y-rui.github.io/post/java-ji-chu-13-she-ji-mo-shi/">
        </link>
        <updated>2020-08-30T12:07:36.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。本节主要介绍中介模式、代理模式、责任模式。</li>
</ul>
<h2 id="中介模式">中介模式</h2>
<p><strong>简介</strong></p>
<ul>
<li>定义了一个对象，该对象封装了一组对象的交互方式。对象之间的通信将封装在中介对象中。对象不再直接相互通信，而是通过中介进行通信。这减少了通信对象之间的依赖性，从而减少了耦合。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>避免一组交互对象之间的紧密耦合。</li>
<li>可以独立地改变一组对象之间的交互。</li>
</ul>
<p><strong>类图</strong><br>
对应中介对象来说，互相交互的对象叫做同事类，中介者对象维护同事类之间的关系，中介对象需要知道所有同事对象，所以也会带来一个问题，当同事类过多时，中介者类将异常复杂。<br>
<img src="https://y-rui.github.io/post-images/1608725370862.png" alt="" loading="lazy"></p>
<ol>
<li>Mediator：抽象中介类，用于与各同事对象之间进行通信。</li>
<li>ConcreteMediator：具体中介类，协调各同事类。</li>
<li>Colleague：抽象同事类。</li>
<li>ConcreteColleague：具体同事类。</li>
</ol>
<p><strong>编程实战</strong><br>
比如我们要实现一个聊天室的功能，聊天室就是中介，而聊天的人就是一个同事类，发送的每个消息都由聊天室转发给其他人。</p>
<p>在 /home/project 目录下新建以下文件<br>
AbstractChatRoom.java（Mediator）：</p>
<pre><code>public abstract class AbstractChatRoom {
    public abstract void notice(String message, User user);
}
</code></pre>
<p>ChatRoom.java(ConcreteMediator)：</p>
<pre><code>import java.util.ArrayList;
import java.util.List;


public class ChatRoom extends AbstractChatRoom {
    private List&lt;User&gt; users = new ArrayList&lt;&gt;();

    public void register(User user) {
        users.add(user);
    }
    @Override
    public void notice(String message, User user) {
        for (User u : users) {
            if (u != user) {
                u.getMessage(message);
            }
        }
    }
}
</code></pre>
<p>User.java(Colleague)。</p>
<pre><code>public abstract class User {
    protected AbstractChatRoom chatRoom;

    public User(AbstractChatRoom chatRoom) {
        this.chatRoom = chatRoom;
    }

    /**
     * 发送消息
     *
     * @param msg
     */
    public abstract void sendMessage(String msg);

    /**
     * 接受消息
     *
     * @param msg
     */
    public abstract void getMessage(String msg);
}
</code></pre>
<p>UserA.java(ConcreteColleague)：</p>
<pre><code>public class UserA extends User {
    public UserA(AbstractChatRoom chatRoom) {
        super(chatRoom);
    }

    @Override
    public void sendMessage(String msg) {
        System.out.println(&quot;用户A发送 &quot; + msg);
        chatRoom.notice(msg, this);
    }

    @Override
    public void getMessage(String msg) {
        System.out.println(&quot;用户A收到 &quot; + msg);
    }
}
</code></pre>
<p>UserB.java(ConcreteColleague)：</p>
<pre><code>public class UserB extends User {
    public UserB(AbstractChatRoom chatRoom) {
        super(chatRoom);
    }

    @Override
    public void sendMessage(String msg) {
        System.out.println(&quot;用户B发送 &quot; + msg);
        chatRoom.notice(msg, this);
    }

    @Override
    public void getMessage(String msg) {
        System.out.println(&quot;用户B收到 &quot; + msg);
    }
}
</code></pre>
<p>Client.java：</p>
<pre><code>public class Client {
    public static void main(String[] args) {
        ChatRoom chatRoom = new ChatRoom();
        UserA userA = new UserA(chatRoom);
        UserB userB = new UserB(chatRoom);
        chatRoom.register(userA);
        chatRoom.register(userB);
        userA.sendMessage(&quot;你好！&quot;);
        userB.sendMessage(&quot;再见！&quot;);
    }
}
</code></pre>
<p>编译运行：</p>
<pre><code>javac Client.java
java Clent
用户A发送 你好！
用户B收到 你好！
用户B发送 再见！
用户A收到 再见！
</code></pre>
<h2 id="代理模式">代理模式</h2>
<p><strong>简介</strong></p>
<ul>
<li>代理模式：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>隐藏原始对象并控制对象的访问。</li>
<li>访问对象时提供其他的功能。</li>
</ul>
<p><strong>类图</strong><br>
<img src="https://y-rui.github.io/post-images/1608725558580.png" alt="" loading="lazy"><br>
说明：</p>
<ul>
<li>Subject: 一个客户端可用的公开的功能接口。</li>
<li>RealSubject：实现 Subject 接口的类，提供了接口方法的具体实现。</li>
<li>Proxy：实现 Subject 接口的代理类，通过 RealSubject 类的业务逻辑方法来实现抽象方法，可以附加自己的操作。</li>
</ul>
<p><strong>编程实战</strong><br>
假设我们需要建设一栋楼房，但是建设之前我们需要购买原材料（如水泥...)，接着才可以开始建设，楼房主体建设完成后，还需要封顶操作。</p>
<p>在 /home/project/ 目录下新建以下文件<br>
LouSubject.java：</p>
<pre><code>public interface LouSubject{
    void build();
}
</code></pre>
<p>LouRealSubject.java：</p>
<pre><code>public class LouRealSubject implements LouSubject{
    @Override
    public void build(){
        System.out.println(&quot;建设实验楼&quot;);
    }
}
</code></pre>
<p>LouProxy.java：</p>
<pre><code>public class LouProxy implements LouSubject{
    private LouSubject target;
    public LouProxy(){
        this.target = new LouRealSubject();
    }
    @Override
    public void build(){
        System.out.println(&quot;购买材料&quot;);
        target.build();
        System.out.println(&quot;封顶&quot;);
    }
}
</code></pre>
<p>LouClient.java</p>
<pre><code>public class LouClient{
    public static void main(String[] args){
        LouSubject proxy = new LouProxy();
        proxy.build();
    }
}
</code></pre>
<p>编译运行：</p>
<pre><code>javac LouClient.java
java LouClient
购买材料
建设实验楼
封顶
</code></pre>
<h2 id="责任链模式">责任链模式</h2>
<ul>
<li>责任链模式是一种由命令对象源和一系列处理对象组成的设计模式。每个处理对象都包含定义它可以处理的命令对象类型的逻辑；其余的传递给链中的下一个处理对象。还存在一种机制，用于将新处理对象添加到该链的末尾。责任链模式在结构上与装饰器模式几乎相同，不同之处在于对于装饰器，所有类都处理请求，而对于责任链，链中的一个类恰好处理请求。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>避免将请求的发送方与其接收方耦合。</li>
<li>可以使用多个接收器处理请求。</li>
</ul>
<p><strong>类图</strong><br>
<img src="https://y-rui.github.io/post-images/1608725688081.png" alt="" loading="lazy"><br>
handler：抽象处理者。<br>
ConcreteHandler：具体处理者，接受到请求后，可以选择处理请求或者传递给下一个处理者。</p>
<p><strong>编程实战</strong><br>
假设我们有一个请假系统，不同的职位可以处理不同的请假请求，比如：<br>
组长：可以处理两天以内的请求<br>
厂长：可以处理七天以内的请求<br>
老板：可以处理十五天以内的请求<br>
如果组长可以处理，那么就直接处理了，如果组长不可以处理，那么我们再继续往下传递。</p>
<p>在 /home/project 目录下新建以下文件<br>
Handler.java：</p>
<pre><code>public abstract class Handler {
    /**
     * 下个处理者
     */
    protected Handler successor;

    public void setSuccessor(Handler successor) {
        this.successor = successor;
    }

    public abstract void handlerRequest(int heaven);
}
</code></pre>
<p>GroupLeaderHandler.java</p>
<pre><code>public class GroupLeaderHandler extends Handler {
    @Override
    public void handlerRequest(int heaven) {
        if (heaven &lt;= 2) {
            System.out.println(&quot;组长处理&quot;);
        }else {
            if (super.successor != null) {
                super.successor.handlerRequest(heaven);
            }
        }
    }
}
</code></pre>
<p>FactoryManagerHandler.java：</p>
<pre><code>public class FactoryManagerHandler extends Handler{
    @Override
    public void handlerRequest(int heaven) {
        if (heaven &lt;= 7) {
            System.out.println(&quot;厂长处理&quot;);
        }else {
            if (super.successor != null) {
                super.successor.handlerRequest(heaven);
            }
        }
    }
}
</code></pre>
<p>BossHandler.java：</p>
<pre><code>public class BossHandler extends Handler {
    @Override
    public void handlerRequest(int heaven) {
        if (heaven &lt;= 15) {
            System.out.println(&quot;老板处理&quot;);
        }else {
            if (super.successor != null) {
                super.successor.handlerRequest(heaven);
            }
        }
    }
}
</code></pre>
<p>Client.java：</p>
<pre><code>public class Client {
    public static void main(String[] args) {
        Handler groupLeaderHandler = new GroupLeaderHandler();
        Handler factoryManagerHandler = new FactoryManagerHandler();
        Handler bossHandler = new BossHandler();
        groupLeaderHandler.setSuccessor(factoryManagerHandler);
        factoryManagerHandler.setSuccessor(bossHandler);
        //请假一天
        groupLeaderHandler.handlerRequest(1);
        //请假6天
        groupLeaderHandler.handlerRequest(6);
        //请假10天
        groupLeaderHandler.handlerRequest(10);
    }
}
</code></pre>
<p>编译运行：</p>
<pre><code>javac Client.java
java Client
组长处理
厂长处理
老板处理
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础12-正则表达式]]></title>
        <id>https://y-rui.github.io/post/java-ji-chu-12-zheng-ze-biao-da-shi/</id>
        <link href="https://y-rui.github.io/post/java-ji-chu-12-zheng-ze-biao-da-shi/">
        </link>
        <updated>2020-08-30T12:05:09.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为 regex、regexp 或 RE ），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式（规则）的文本。</li>
</ul>
<p>Java 通过 java.util.regex 包支持正则表达式的的功能。<br>
Java 使用正则表达式匹配非常简单，这里我们以匹配邮箱地址为例。在 /home/project 目录下新建一个源代码文件 RegexDemo.java。</p>
<pre><code>import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexDemo {
    public static void main(String[] args) {
//       Pattern类 正则表达式的编译表示。
        Pattern pattern = Pattern.compile(&quot;^[a-zA-Z0-9_!#$%&amp;'*+/=?`{|}~^.-]+@[a-zA-Z0-9.-]+$&quot;);
        String[] emails = {&quot;shiyanlou@shiyanlou.com&quot;, &quot;shiyanlou&quot;};
        for (String email :
                emails) {
//Matcher 通过解释Pattern对字符序列执行匹配操作的引擎
            Matcher matcher = pattern.matcher(email);
            System.out.println(email + &quot;匹配结果：&quot; + matcher.matches());
        }
    }
}
</code></pre>
<p>编译运行：</p>
<pre><code>$ javac RegexDemo.java
$ java RegexDemo
shiyanlou@shiyanlou.com匹配结果：true
shiyanlou匹配结果：false
</code></pre>
<p><strong>练习题：正则表达式</strong><br>
在 /home/project 目录下新建一个源代码文件 RegexTest.java。你需要完成以下要求：</p>
<ul>
<li>从控制台输入一串字符串，使用正则表达式判断其是不是 11 位手机号码。</li>
<li>如果是 11 位手机号码，输出 true，如果不是输出 false。</li>
</ul>
<p>示例：</p>
<pre><code>输入：
    13408199578
输出：
    true
</code></pre>
<p>参考答案</p>
<pre><code>import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexTest {
    public static void main(String[] args) {
        Pattern pattern = Pattern.compile(&quot;^1([34578])\\d{9}$&quot;);
        Scanner in = new Scanner(System.in);
        String phone = in.nextLine();
        Matcher matcher = pattern.matcher(phone);
        System.out.println(matcher.matches());
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础11-反射]]></title>
        <id>https://y-rui.github.io/post/java-ji-chu-11-fan-she/</id>
        <link href="https://y-rui.github.io/post/java-ji-chu-11-fan-she/">
        </link>
        <updated>2020-08-30T11:48:18.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>ava 反射说的是在运行状态中，对于任何一个类，我们都能够知道这个类有哪些方法和属性。对于任何一个对象，我们都能够对它的方法和属性进行调用。我们把这种动态获取对象信息和调用对象方法的功能称之为反射机制。本节主要讲解 Java 反射机制中的常用类。</li>
</ul>
<h2 id="什么是反射">什么是反射</h2>
<ul>
<li>反射是 Java 编程语言的一个特性，它提供了在运行时检查和动态调用类、方法、属性的能力。</li>
</ul>
<h2 id="反射能做什么">反射能做什么</h2>
<ul>
<li>反射可以在运行时检查类，接口，方法和变量。还可以实例化对象、调用方法、获取和设置变量值。比如当我们不知道一个类中是否拥有某个方法时，我们就可以使用反射来检查是否拥有这个方法。</li>
</ul>
<h2 id="反射常用类">反射常用类</h2>
<p><strong>常用类</strong></p>
<ul>
<li>Class：Class 类表示正在运行的 Java 程序中的类和接口。</li>
<li>Field：提供有关类或接口的单个域的信息和动态访问。如数据类型，访问修饰符，域的名称和值。</li>
<li>Method：提供有关类或接口上的单个方法的信息和访问权限。如访问修饰符，返回类型，名称，参数类型和方法的异常类型。</li>
<li>Constructor：提供有关类的单个构造函数的信息和访问权限。例如构造函数的访问修饰符，名称和参数类型。</li>
<li>Modifier：提供了有关访问修饰符的信息。</li>
</ul>
<p><strong>Class</strong><br>
Class 类没有公共构造方法，可以通过以下方法获取 Class 实例。</p>
<ul>
<li>Object 提供的 getClass() 方法。</li>
<li>类名.Class。</li>
<li>Class.forName(String className) 方法，className 为类的全限定名。</li>
</ul>
<p>Class 类常用方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Field getField(String name)</code></td>
<td>获取指定的域对象</td>
</tr>
<tr>
<td><code>Field[] getFields()</code></td>
<td>返回所有的公有域对象数组</td>
</tr>
<tr>
<td><code>Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code></td>
<td>返回指定的方法对象</td>
</tr>
<tr>
<td><code>Method[] getMethods()</code></td>
<td>返回所有的公有方法对象数组</td>
</tr>
<tr>
<td><code>Method[] getDeclaredMethods()</code></td>
<td>返回所有方法对象数组</td>
</tr>
<tr>
<td><code>String getName()</code></td>
<td>获取全限定名</td>
</tr>
</tbody>
</table>
<p><strong>编程实战</strong><br>
在 /home/project/ 目录下新建 ReflectDemo.java。</p>
<pre><code>import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;

public class ReflectDemo {
    public int a;
    private int b;

    public static void main(String[] args) {
        Class&lt;ReflectDemo&gt; reflectDemoClass = ReflectDemo.class;
        //输出所有的域名称
        for (Field declaredField : reflectDemoClass.getDeclaredFields()) {
            //可以通过Modifier将具体的权限信息输出，否则只会显示代表权限的数值
            System.out.println(&quot;域：&quot; + declaredField.getName() + &quot; 修饰符：&quot; + Modifier.toString(declaredField.getModifiers()));
        }
        //输出所有的公有域名称
        for (Field field : reflectDemoClass.getFields()) {
            System.out.println(&quot;公有域：&quot; + field.getName() + &quot; 修饰符：&quot; + Modifier.toString(field.getModifiers()));
        }
        //输出类的所有方法名
        for (Method declaredMethod : reflectDemoClass.getDeclaredMethods()) {
            System.out.println(&quot;方法：&quot; + declaredMethod.getName() + &quot; 修饰符：&quot; + Modifier.toString(declaredMethod.getModifiers()));
        }
    }

    public void fun1() {
    }

    private void fun2() {
    }

}
</code></pre>
<p>编译运行：</p>
<pre><code>javac ReflectDemo.java
java ReflectDemo
</code></pre>
<p>运行结果：</p>
<pre><code>域：a 修饰符：public
域：b 修饰符：private
公有域：a 修饰符：public
方法：main 修饰符：public static
方法：fun1 修饰符：public
方法：fun2 修饰符：private
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础10-JDBC]]></title>
        <id>https://y-rui.github.io/post/java-ji-chu-10-jdbc/</id>
        <link href="https://y-rui.github.io/post/java-ji-chu-10-jdbc/">
        </link>
        <updated>2020-08-29T08:04:58.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>JDBC 是连接数据库和 Java 程序的桥梁，通过 JDBC API 可以方便地实现对各种主流数据库的操作。本节将重点讲解 JDBC 的内容</li>
</ul>
<h2 id="数据库简介">数据库简介</h2>
<p>数据库，简而言之可视为电子化的文件柜——存储电子文件的处所，用户可以对文件中的数据运行新增、截取、更新、删除等操作</p>
<p>所谓“数据库”系以一定方式储存在一起、能予多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。一个数据库由多个表空间（Tablespace）构成</p>
<h2 id="关系数据库">关系数据库</h2>
<h2 id="非关系型数据库nosql">非关系型数据库（NoSql）</h2>
<h2 id="sql-简介">SQL 简介</h2>
<ul>
<li>结构化查询语言 (Structured Query Language) 简称 SQL（发音：/ˈes kjuː ˈel/ &quot;S-Q-L&quot;)，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。</li>
<li>结构化查询语言是高级的非过程化编程语言，允许用户在高层数据结构上工作。它不要求用户指定对数据的存放方法，也不需要用户了解具体的数据存放方式，所以具有完全不同底层结构的不同数据库系统，可以使用相同的结构化查询语言作为数据输入与管理的接口。结构化查询语言语句可以嵌套，这使它具有极大的灵活性和强大的功能。</li>
</ul>
<p><strong>SQL 语法</strong></p>
<h2 id="jdbc">JDBC</h2>
<p>JDBC 的全称是 Java Database Connectivity，叫做 Java 数据库连接。它包括了一组与数据库交互的 API，还有与数据库进行通信的驱动程序</p>
<p>我们要写涉及到数据库的程序，是通过 C 语言或者 C++ 语言直接访问数据库的接口，如下图所示<br>
<img src="https://y-rui.github.io/post-images/1608710862742.png" alt="" loading="lazy"><br>
对于不同的数据库，我们需要知道不同数据库对外提供的系统 API，这就影响了我们程序的扩展和跨平台的实现</p>
<p>那么有没有一种方法来对不同的数据库接口进行统一呢？当然有。我们只需要和最上层接口进行交互，剩下的部分就交给其他各层去处理，我们的任务就变的轻松简单许多<br>
<img src="https://y-rui.github.io/post-images/1608710893585.png" alt="" loading="lazy"><br>
JDBC 为数据库开发人员提供了一个标准的 API，据此可以构建更高级的工具和接口使数据库开发人员能够用纯 Java API 编写数据库应用程序<br>
<img src="https://y-rui.github.io/post-images/1608710914425.png" alt="" loading="lazy"></p>
<p><strong>JDBC 连接数据库</strong><br>
涉及到建立一个 JDBC 连接的编程主要有四个步骤</p>
<ol>
<li>导入 JDBC 驱动： 只有拥有了驱动程序我们才可以注册驱动程序完成连接的其他步骤</li>
<li>注册 JDBC 驱动程序：这一步会导致 JVM 加载所需的驱动类实现到内存中，然后才可以实现 JDBC 请求</li>
<li>数据库 URL 指定：创建具有正确格式的地址，指向到要连接的数据库</li>
<li>创建连接对象：最后，代码调用 DriverManager 对象的 getConnection() 方法来建立实际的数据库连接</li>
</ol>
<p>接下来我们便详细讲解这四步</p>
<p><strong>导入 JDBC 驱动</strong><br>
需要下载对应数据库的 jdbc 驱动，将其导入到项目中，具体的导入方式根据个人的 IDE 确定，本节课程不使用 IDE，直接使用 javac -cp 命令导入包</p>
<p><strong>注册 JDBC 驱动程序</strong><br>
我们在使用驱动程序之前，必须注册你的驱动程序。注册驱动程序的本质就是将我们将要使用的数据库的驱动类文件动态的加载到内存中，然后才能进行数据库。比如我们使用的 Mysql 数据库。我们可以通过以下两种方式来注册我们的驱动程序</p>
<p>1、Class.forName()<br>
动态加载一个类最常用的方法是使用 Java 的 Class.forName() 方法，通过使用这个方法来将数据库的驱动类动态加载到内存中，然后我们就可以使用</p>
<p>使用 Class.forName() 来注册 Mysql 驱动程序</p>
<pre><code>try {
   Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
}
catch(ClassNotFoundException ex) {
   System.out.println(&quot;Error: unable to load driver class!&quot;);
   System.exit(1);
}
</code></pre>
<p>2、DriverManager.registerDriver()</p>
<pre><code>Driver driver = new com.mysql.jdbc.Driver();
DriverManager.registerDriver(driver);
</code></pre>
<p><strong>指定数据库连接 URL</strong><br>
当加载了驱动程序，便可以使用 DriverManager.getConnection() 方法连接到数据库了</p>
<p>这里给出 DriverManager.getConnection() 三个重载方法</p>
<pre><code>getConnection(String url)

getConnection(String url, Properties prop)

getConnection(String url, String user, String password)
</code></pre>
<p>数据库的 URL 是指向数据库地址。下表列出了下来流行的 JDBC 驱动程序名和数据库的 URL</p>
<table>
<thead>
<tr>
<th>RDBMS</th>
<th>JDBC 驱动程序的名称</th>
<th>URL</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Mysql</code></td>
<td>com.mysql.jdbc.Driver</td>
<td>jdbc:mysql://hostname/ databaseName</td>
</tr>
<tr>
<td><code>Oracle</code></td>
<td>oracle.jdbc.driver.OracleDriver</td>
<td>jdbc:oracle:thin:@hostname:port Number:databaseName</td>
</tr>
<tr>
<td><code>DB2</code></td>
<td>COM.ibm.db2.jdbc.net.DB2Driver</td>
<td>jdbc:db2:hostname:port Number/databaseName</td>
</tr>
<tr>
<td><code>Sybase</code></td>
<td>com.sybase.jdbc.SybDriver</td>
<td>jdbc:sybase:Tds:hostname: port Number/databaseName</td>
</tr>
</tbody>
</table>
<p><strong>创建连接对象</strong><br>
下面三种形式 DriverManager.getConnection() 方法来创建一个连接对象，以 Mysql 为例。getConnection() 最常用形式要求传递一个数据库 URL，用户名 username 和密码 password</p>
<ol>
<li>使用数据库 URL 的用户名和密码</li>
</ol>
<pre><code>String URL = &quot;jdbc:mysql://localhost/EXAMPLE&quot;;
String USER = &quot;username&quot;;
String PASS = &quot;password&quot;
Connection conn = DriverManager.getConnection(URL, USER, PASS);
</code></pre>
<ol start="2">
<li>只使用一个数据库 URL<br>
然而，在这种情况下，数据库的 URL，包括用户名和密码</li>
</ol>
<pre><code>String URL = &quot;jdbc:mysql://localhost/EXAMPLE?user=root&amp;password=0909&quot;;
//Mysql URL的参数设置详细可以查阅相关资料
Connection conn = DriverManager.getConnection(URL);
</code></pre>
<ol start="3">
<li>使用数据库的 URL 和一个 Properties 对象</li>
</ol>
<pre><code>import java.util.*;

String URL = &quot;jdbc:mysql://localhost/EXAMPLE&quot;;
Properties pro = new Properties( );

//Properties对象，保存一组关键字-值对
pro.put( &quot;user&quot;, &quot;root&quot; );
pro.put( &quot;password&quot;, &quot;&quot; );

Connection conn = DriverManager.getConnection(URL, pro);
</code></pre>
<ol start="4">
<li>关闭 JDBC 连接</li>
</ol>
<pre><code>conn.close();
</code></pre>
<h2 id="创建数据库">创建数据库</h2>
<p>在使用数据库之前第一件事情就是创建数据库，这里我们使用 JDBC 来创建数据库</p>
<p><strong>编程实战</strong><br>
实验楼数据库密码为空<br>
在 /home/project/ 目录下新建文件 CreateDatabase.java</p>
<pre><code>import java.sql.*;

public class CreateDatabase {
    public static void main(String[] args){
        Connection connection = null;
        try {
            //加载数据库驱动
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
            //打开数据库连接 第一个参数为数据库地址  后面2个参数分别为数据库用户名和密码
            // 实验楼中 MySQL 的用户名为: root, 密码为空。
            connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/&quot;,&quot;root&quot;,&quot;&quot;);
            //创建Statement
            Statement statement = connection.createStatement();
            //执行sql
            statement.execute(&quot;create database EXAMPLE&quot;);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                //关闭连接
                if (connection != null) {
                    connection.close();
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<p>启动 mysql</p>
<pre><code>$ sudo service mysql start
</code></pre>
<p>编译运行（需要带上 mysql-connector-java-5.1.45.jar）</p>
<pre><code>$ wget https://labfile.oss.aliyuncs.com/courses/1230/mysql-connector-java-5.1.47.jar
$ javac -cp mysql-connector-java-5.1.47.jar CreateDatabase.java
$ java -cp .:mysql-connector-java-5.1.47.jar CreateDatabase
</code></pre>
<h2 id="数据库操作">数据库操作</h2>
<p><img src="https://y-rui.github.io/post-images/1608711715625.png" alt="" loading="lazy"><br>
当连接上了数据库后，就需要通过 sql 语句对数据库进行操作。随着 Java 语言应用面的逐步拓宽，Sun 公司开发了一个标准的 SQL 数据库访问接口———JDBC API。它可以使 Java 编程人员通过一个一致的接口，访问多种关系数据库。而今天我们就来学习一下，如何利用 JDBC 的一些核心 API 与数据库进行交互</p>
<p>通过使用 JDBC Statement, CallableStatement 和 PreparedStatement 接口定义的方法和属性，使可以使用 SQL 或 PL/SQL 命令和从数据库接收数据。它们还定义了许多方法，帮助消除 Java 和数据库之间数据类型的差异</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>应用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Statement</code></td>
<td>当在运行时使用静态 SQL 语句时（Statement 接口不能接收参数）</td>
</tr>
<tr>
<td><code>CallableStatement</code></td>
<td>当要访问数据库中的存储过程时（CallableStatement 对象的接口还可以接收运行时输入参数）</td>
</tr>
<tr>
<td><code>PreparedStatement</code></td>
<td>当计划多次使用 SQL 语句时（PreparedStatement 接口接收在运行时输入参数）</td>
</tr>
</tbody>
</table>
<p><strong>Statement</strong><br>
我们要使用 Statement 接口，第一步肯定是创建一个 Statement 对象了。我们需要使用 Connection 对象的 createStatement() 方法进行创建</p>
<pre><code>Statement stmt = null;
try {
   stmt = conn.createStatement( );
   . . .
}
catch (SQLException e) {
   . . .
}
finally {
   . . .
}
</code></pre>
<p>一旦创建了一个 Statement 对象，我们就可以用它来执行 SQL 语句了，首先我们先来看看 Statement 里面有哪些方法吧！</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>boolean execute(String SQL)</code></td>
<td>如果 ResultSet 对象可以被检索返回布尔值 true，否则返回 false。使用这个方法来执行 SQL DDL 语句，或当需要使用真正的动态 SQL</td>
</tr>
<tr>
<td><code>int executeUpdate(String SQL)</code></td>
<td>用于执行 INSERT、UPDATE 或 DELETE 语句以及 SQLDDL（数据定义语言）语句。返回值是一个整数，指示受影响的行数（即更新计数）</td>
</tr>
<tr>
<td><code>ResultSet executeQuery(String SQL)</code></td>
<td>返回 ResultSet 对象。用于产生单个结果集的语句，例如 SELECT 语句</td>
</tr>
</tbody>
</table>
<p>正如关闭一个 Connection 对象来释放数据库连接资源，出于同样的原因，也应该关闭 Statement 对象</p>
<pre><code>Statement stmt = null;
try {
   stmt = conn.createStatement( );
   . . .
}
catch (SQLException e) {
   . . .
}
finally {
   stmt.close();
}
</code></pre>
<p>注：如果关闭了 Connection 对象首先它会关闭 Statement 对象，然而应该始终明确关闭 Statement 对象，以确保正确的清除</p>
<p><strong>PreparedStatement</strong><br>
PreparedStatement 接口扩展了 Statement 接口，有利于高效地执行多次使用的 SQL 语句。我们先来创建一个 PreparedStatement 对象。 Statement 为一条 SQL 语句生成执行计划。如果要执行两条 SQL 语句，会生成两个执行计划。一万个查询就生成一万个执行计划！</p>
<pre><code>select colume from table where colume=1;
select colume from table where colume=2;
</code></pre>
<p>PreparedStatement 用于使用绑定变量重用执行计划</p>
<pre><code>select colume from table where colume=:x;
</code></pre>
<p>通过 set 不同数据，只需要生成一次执行计划，并且可以重用</p>
<pre><code>PreparedStatement pstmt = null;
try {

/*
在JDBC中所有的参数都被代表？符号，这是已知的参数标记。在执行SQL语句之前，必须提供值的每一个参数。
*/
   String SQL = &quot;Update Students SET age = ? WHERE id = ?&quot;;
   pstmt = conn.prepareStatement(SQL);
   . . .
}
/*

setXXX()方法将值绑定到参数，其中XXX表示希望绑定到输入参数值的 Java 数据类型。如果忘了提供值，将收到一个 SQLException。
*/
catch (SQLException e) {
   . . .
}
finally {
//同理，我们需要关闭 PreparedStatement 对象
   pstmt.close();
}
</code></pre>
<p>说了这么多，我们手动操作一下吧<br>
先创建数据库和相应的内容</p>
<pre><code>sudo service mysql start
# 实验楼中 MySQL 的用户名为: root, 密码为空。
mysql -u root
create database EXAMPLE;
use EXAMPLE
</code></pre>
<pre><code>create table Students
(
id int not null,
age int not null,
name varchar(255),
primary key(id)
);
insert into Students values(1,18,'Tom'),
(2,20,'Aby'),(4,20,'Tomson');
</code></pre>
<p>在 /home/project/ 目录下创建 JdbcTest.java</p>
<pre><code>import java.sql.*;

public class JdbcTest {
   // JDBC 驱动器的名称和数据库地址
   static final String JDBC_DRIVER = &quot;com.mysql.jdbc.Driver&quot;;
   static final String DB_URL = &quot;jdbc:mysql://localhost/EXAMPLE&quot;;


   static final String USER = &quot;root&quot;;
   static final String PASS = &quot;&quot;;

   public static void main(String[] args) {
       Connection conn = null;
       PreparedStatement stmt = null;
       try{
           //注册 JDBC 驱动器
           Class.forName(&quot;com.mysql.jdbc.Driver&quot;);

           //打开连接
           System.out.println(&quot;Connecting to database...&quot;);
           conn = DriverManager.getConnection(DB_URL,USER,PASS);

           //执行查询
           System.out.println(&quot;Creating statement...&quot;);
           //这里我们要更改一个同学的年龄，参数待定
           String sql = &quot;UPDATE Students set age=? WHERE id=?&quot;;
           stmt = conn.prepareStatement(sql);

           //将值绑定到参数，参数从左至右序号为1，2...
           stmt.setInt(1, 22);  // 绑定 age 的值(序号为1)
           stmt.setInt(2, 1); // 绑定 ID 的值

           // 更新 ID 为1的同学的年龄
           int rows = stmt.executeUpdate();
           System.out.println(&quot;被影响的行数 : &quot; + rows );

           // 查询所有记录，并显示.
           sql = &quot;SELECT id, name, age FROM Students&quot;;
           ResultSet rs = stmt.executeQuery(sql);

           //处理结果集
           while(rs.next()){
               //检索
               int id  = rs.getInt(&quot;id&quot;);
               int age = rs.getInt(&quot;age&quot;);
               String name = rs.getString(&quot;name&quot;);


               //显示
               System.out.print(&quot;ID: &quot; + id);
               System.out.print(&quot;, Age: &quot; + age);
               System.out.print(&quot;, Name: &quot; + name);
               System.out.println();
           }
           //清理
           rs.close();
           stmt.close();
           conn.close();
       }catch(SQLException se){
           se.printStackTrace();
       }catch(Exception e){
           e.printStackTrace();
       }finally{
           try{
               if(stmt!=null)
                   stmt.close();
           }catch(SQLException se2){
           }
    try{
         if(conn!=null)
                 conn.close();
      }catch(SQLException se){
              se.printStackTrace();
          }
       }
           System.out.println(&quot;Goodbye!&quot;);
   }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ wget https://labfile.oss.aliyuncs.com/courses/1230/mysql-connector-java-5.1.47.jar
$ javac -cp .:mysql-connector-java-5.1.47.jar JdbcTest.java
$ java -cp .:mysql-connector-java-5.1.47.jar JdbcTest
</code></pre>
<p><strong>CallableStatement</strong><br>
CallableStatement 对象为所有的 DBMS 提供了一种以标准形式调用存储过程的方法。存储过程储存在数据库中。对储存过程的调用是 CallableStatement 对象所含的内容。三种类型的参数有：IN，OUT 和 INOUT。PreparedStatement 对象只使用 IN 参数。 CallableStatement 对象可以使用所有三个</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>IN</code></td>
<td>它的值是在创建 SQL 语句时未知的参数，将 IN 参数传给 CallableStatement 对象是通过 setXXX() 方法完成的</td>
</tr>
<tr>
<td><code>OUT</code></td>
<td>其值由它返回的 SQL 语句提供的参数。从 OUT 参数的 getXXX() 方法检索值</td>
</tr>
<tr>
<td><code>INOUT</code></td>
<td>同时提供输入和输出值的参数，绑定的 setXXX() 方法的变量，并使用 getXXX() 方法检索值</td>
</tr>
</tbody>
</table>
<p>在 JDBC 中调用存储过程的语法如下所示。注意，方括号表示其间的内容是可选项；方括号本身并不是语法的组成部份</p>
<pre><code>{call 存储过程名[(?, ?, ...)]}
</code></pre>
<p>返回结果参数的过程的语法为</p>
<pre><code>{? = call 存储过程名[(?, ?, ...)]}
</code></pre>
<p>不带参数的存储过程的语法类似</p>
<pre><code>{call 存储过程名}
</code></pre>
<p>CallableStatement 对象是用 Connection 方法 prepareCall 创建的</p>
<pre><code>CallableStatement cstmt = null;
try {
   String SQL = &quot;{call getEXAMPLEName (?, ?)}&quot;;
   cstmt = conn.prepareCall (SQL);
   . . .
}
catch (SQLException e) {
   . . .
}
finally {
   cstmt.close();
}
</code></pre>
<p>好了，CallableStatement 接口就不再详细地讲解了，同学们可以自己查阅相关的资料，对 CallableStatement 进行深入学习</p>
<h2 id="jdbc-结果集">JDBC 结果集</h2>
<p>结果集通常是通过执行查询数据库的语句生成，表示数据库查询结果的数据表</p>
<p><strong>ResultSet 介绍</strong><br>
ResultSet 对象具有指向其当前数据行的光标。最初，光标被置于第一行之前。next 方法将光标移动到下一行；因为该方法在 ResultSet 对象没有下一行时返回 false，所以可以在 while 循环中使用它来迭代结果集。光标可以方便我们对结果集进行遍历。默认的 ResultSet 对象不可更新，仅有一个向前移动的光标。因此，只能迭代它一次，并且只能按从第一行到最后一行的顺序进行</p>
<p>ResultSet 接口的方法可分为三类</p>
<ul>
<li>导航方法：用于移动光标</li>
<li>获取方法：用于查看当前行的光标所指向的列中的数据</li>
<li>更新方法：用于更新当前行的列中的数据</li>
</ul>
<p>JDBC 提供下列连接方法来创建所需的 ResultSet 语句</p>
<pre><code>createStatement(int RSType, int RSConcurrency);

prepareStatement(String SQL, int RSType, int RSConcurrency);

prepareCall(String sql, int RSType, int RSConcurrency);
</code></pre>
<p>RSType 表示 ResultSet 对象的类型，RSConcurrency 是 ResultSet 常量，用于指定一个结果集是否为只读或可更新</p>
<p>ResultSet 的类型，如果不指定 ResultSet 类型，将自动获得一个是 TYPE_FORWARD_ONLY</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ResultSet.TYPE_FORWARD_ONLY</code></td>
<td>游标只能向前移动的结果集</td>
</tr>
<tr>
<td><code>ResultSet.TYPE_SCROLL_INSENSITIVE</code></td>
<td>游标可以向前和向后滚动，但不及时更新，就是如果数据库里的数据修改过，并不在 ResultSet 中反应出来</td>
</tr>
<tr>
<td><code>ResultSet.TYPE_SCROLL_SENSITIVE</code></td>
<td>游标可以向前和向后滚动，并及时跟踪数据库的更新，以便更改 ResultSet 中的数据</td>
</tr>
</tbody>
</table>
<p>并发性的 ResultSet，如果不指定任何并发类型，将自动获得一个为 CONCUR_READ_ONLY</p>
<table>
<thead>
<tr>
<th>并发</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ResultSet.CONCUR_READ_ONLY</code></td>
<td>创建结果集只读。这是默认的</td>
</tr>
<tr>
<td><code>ResultSet.CONCUR_UPDATABLE</code></td>
<td>创建一个可更新的结果集</td>
</tr>
</tbody>
</table>
<p>如初始化一个 Statement 对象来创建一个双向、可更新的 ResultSet 对象</p>
<pre><code>try {
   Statement stmt = conn.createStatement(
                           ResultSet.TYPE_SCROLL_INSENSITIVE,
                           ResultSet.CONCUR_UPDATABLE);
}
catch(Exception ex) {
   ....
}
finally {
   ....
}
</code></pre>
<p><strong>导航</strong><br>
我们在上面已经知道了，导航方法是用于移动光标的。我们先来看一看，在 ResultSet 接口中有哪些方法会涉及光标的移动</p>
<p>先创建数据库和相应的内容</p>
<pre><code>sudo service mysql start
mysql -u root
create database EXAMPLE;
use EXAMPLE
</code></pre>
<pre><code>create table Students
(
id int not null,
age int not null,
name varchar(255),
primary key(id)
);
insert into Students values(1,18,'Tom'),
(2,20,'Aby'),(4,20,'Tomson');
</code></pre>
<p>在 /home/project/ 目录下创建文件JdbcTest.java</p>
<pre><code>import java.sql.*;

public class JdbcTest {
   // JDBC 驱动器名称 和数据库地址
   static final String JDBC_DRIVER = &quot;com.mysql.jdbc.Driver&quot;;
   //数据库的名称为 EXAMPLE
   static final String DB_URL = &quot;jdbc:mysql://localhost/EXAMPLE&quot;;

   // 数据库用户和密码
   static final String USER = &quot;root&quot;;
   static final String PASS = &quot;&quot;;

   public static void main(String[] args) {
       Connection conn = null;
       Statement stmt = null;
       try{
           //注册JDBC 驱动程序
           Class.forName(&quot;com.mysql.jdbc.Driver&quot;);

           //打开连接
           System.out.println(&quot;Connecting to database...&quot;);
           conn = DriverManager.getConnection(DB_URL,USER,PASS);



           System.out.println(&quot;Creating statement...&quot;);
           //创建所需的ResultSet，双向，只读
           stmt = conn.createStatement(
                           ResultSet.TYPE_SCROLL_INSENSITIVE,
                           ResultSet.CONCUR_READ_ONLY);
           String sql;
           sql = &quot;SELECT id, name, age FROM Students&quot;;
           ResultSet rs = stmt.executeQuery(sql);

           // 将光标移到最后一行
           System.out.println(&quot;Moving cursor to the last...&quot;);
           rs.last();

           //处理结果集
           System.out.println(&quot;Displaying record...&quot;);
           int id  = rs.getInt(&quot;id&quot;);
           int age = rs.getInt(&quot;age&quot;);
           String name = rs.getString(&quot;name&quot;);


           //显示
           System.out.print(&quot;ID: &quot; + id);
           System.out.print(&quot;, Age: &quot; + age);
           System.out.print(&quot;, Name: &quot; + name);
           System.out.println();

           // 将光标移到第一行
           System.out.println(&quot;Moving cursor to the first row...&quot;);
           rs.first();


           System.out.println(&quot;Displaying record...&quot;);
           id  = rs.getInt(&quot;id&quot;);
           age = rs.getInt(&quot;age&quot;);
           name = rs.getString(&quot;name&quot;);


           //显示
           System.out.print(&quot;ID: &quot; + id);
           System.out.print(&quot;, Age: &quot; + age);
           System.out.print(&quot;, Name: &quot; + name);

           //将光标移至下一行
           System.out.println(&quot;Moving cursor to the next row...&quot;);
           rs.next();


           System.out.println(&quot;Displaying record...&quot;);
           id  = rs.getInt(&quot;id&quot;);
           age = rs.getInt(&quot;age&quot;);
           name = rs.getString(&quot;name&quot;);

           // 显示
           System.out.print(&quot;ID: &quot; + id);
           System.out.print(&quot;, Age: &quot; + age);
           System.out.print(&quot;, Name: &quot; + name);

           rs.close();
           stmt.close();
           conn.close();
       }catch(SQLException se){
           se.printStackTrace();
       }catch(Exception e){
           e.printStackTrace();
       }finally{
           try{
               if(stmt!=null)
                   stmt.close();
           }catch(SQLException se2){
           }
           try{
               if(conn!=null)
                   conn.close();
           }catch(SQLException se){
               se.printStackTrace();
           }
       }
       System.out.println(&quot;Goodbye!&quot;);
   }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ wget https://labfile.oss.aliyuncs.com/courses/1230/mysql-connector-java-5.1.47.jar
$ javac -cp .:mysql-connector-java-5.1.47.jar JdbcTest.java
$ java -cp .:mysql-connector-java-5.1.47.jar JdbcTest
</code></pre>
<p><strong>获取</strong><br>
ResultSet 接口中我们经常使用 get 方法来查看结果集</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public int getInt(String columnName) throws SQLException</code></td>
<td>当前行中名为 ColumnName 列的值</td>
</tr>
<tr>
<td><code>public int getInt(int columnIndex) throws SQLException</code></td>
<td>当前行中指定列的索引的值。列索引从 1 开始，意味着一个行的第一列是 1，行的第二列是 2，依此类推</td>
</tr>
</tbody>
</table>
<p>当然还有 getString() 等等</p>
<p><strong>更新</strong><br>
更新的方法如下</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public void updateString(int columnIndex, String s) throws SQLException</code></td>
<td>指定列中的字符串更改为 s 的值</td>
</tr>
<tr>
<td><code>public void updateString(String columnName, String s) throws SQLException</code></td>
<td>类似于前面的方法，不同之处在于由它的名称，而不是它的索引指定的列</td>
</tr>
</tbody>
</table>
<p>类似的还有 updateDouble() 等等</p>
<p>我们在更新了结果集中的内容，当然需要更新一下数据库了。我们可以调用下面的方法更新数据库</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public void updateRow()</code></td>
<td>通过更新数据库中相应的行更新当前行</td>
</tr>
<tr>
<td><code>public void deleteRow()</code></td>
<td>从数据库中删除当前行</td>
</tr>
<tr>
<td><code>public void refreshRow()</code></td>
<td>刷新在结果集的数据，以反映最新变化在数据库中</td>
</tr>
<tr>
<td><code>public void cancelRowUpdates()</code></td>
<td>取消所做的当前行的任何更新</td>
</tr>
<tr>
<td><code>public void insertRow()</code></td>
<td>插入一行到数据库中。当光标指向插入行此方法只能被调用</td>
</tr>
</tbody>
</table>
<p>我们这里对上面的方法做一个小小的举例</p>
<pre><code>Statement stmt = conn.createStatement(
                           ResultSet.TYPE_SCROLL_INSENSITIVE,
                           ResultSet.CONCUR_UPDATABLE);

String sql = &quot;SELECT id, name, age FROM Students&quot;;
ResultSet rs = stmt.executeQuery(sql);

//结果集中插入新行
rs.moveToInsertRow();
rs.updateInt(&quot;id&quot;,5);
rs.updateString(&quot;name&quot;,&quot;John&quot;);
rs.updateInt(&quot;age&quot;,21);
//更新数据库
rs.insertRow();
</code></pre>
<p><strong>练习题：根据多种条件进行查询</strong><br>
启动数据库</p>
<pre><code>$ sudo service mysql start
</code></pre>
<p>创建一个数据库test，在数据库中创建一个数据表user，表内容如下</p>
<pre><code>create database test;
use test;
CREATE TABLE user
(
    id int PRIMARY KEY,
    name varchar(50),
    age int,
    sex varchar(50)
);
alter table user change sex sex varchar(50) character set utf8;
INSERT INTO `user`(`id`, `name`, `age`, `sex`) VALUES (1, 'shi', 20, '男');
INSERT INTO `user`(`id`, `name`, `age`, `sex`) VALUES (2, 'yan', 13, '女');
INSERT INTO `user`(`id`, `name`, `age`, `sex`) VALUES (3, 'lou', 22, '女');
INSERT INTO `user`(`id`, `name`, `age`, `sex`) VALUES (4, 'admin', 50, '男');
</code></pre>
<p>在 /home/project 目录下创建一个文件 QueryDemo.java，使用 jdbc 完成以下查询</p>
<ul>
<li>查询 Id 为 1 的用户</li>
<li>查询年龄为 12 岁，名字为 yan 的用语</li>
<li>查询年龄大于 20 岁的用户</li>
</ul>
<p>JDBC 驱动下载</p>
<pre><code>$ wget https://labfile.oss.aliyuncs.com/courses/1230/mysql-connector-java-5.1.47.jar
</code></pre>
<p>参考答案</p>
<pre><code>import java.sql.*;

public class QueryDemo {

    // JDBC 驱动器的名称和数据库地址
    private static final String JDBC_DRIVER = &quot;com.mysql.jdbc.Driver&quot;;
    private static final String DB_URL = &quot;jdbc:mysql://localhost/test&quot;;
    private static final String USER = &quot;root&quot;;
    private static final String PASS = &quot;&quot;;

    public static void main(String[] args) {
        Connection conn = null;
        PreparedStatement stmt = null;
        try {
            Class.forName(JDBC_DRIVER);
            conn = DriverManager.getConnection(DB_URL, USER, PASS);

            //id为1的用户
            String sql = &quot;select id,name,age,sex from user where id=?&quot;;
            stmt = conn.prepareStatement(sql);
            stmt.setInt(1, 1);
            ResultSet resultSet = stmt.executeQuery();
            printRS(resultSet);

            //年龄为12 名字为yan
            stmt = conn.prepareStatement(&quot;select id,name,age,sex from user where age=? and name=?&quot;);
            stmt.setInt(1, 12);
            stmt.setString(2, &quot;yan&quot;);
            resultSet = stmt.executeQuery();
            printRS(resultSet);

            //年龄为12 名字为yan
            stmt = conn.prepareStatement(&quot;select id,name,age,sex from user where age&gt;?&quot;);
            stmt.setInt(1, 20);
            resultSet = stmt.executeQuery();
            printRS(resultSet);
            //清理
            resultSet.close();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                if (stmt != null) {
                    stmt.close();
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
            try {
                if (conn != null) {
                    conn.close();
                }
            } catch (SQLException se) {
                se.printStackTrace();
            }
        }
    }

    private static void printRS(ResultSet resultSet) throws SQLException {
        while (resultSet.next()) {
            int id = resultSet.getInt(&quot;id&quot;);
            String name = resultSet.getString(&quot;name&quot;);
            int age = resultSet.getInt(&quot;age&quot;);
            String sex = resultSet.getString(&quot;sex&quot;);
            System.out.println(&quot;id:&quot; + id + &quot; name:&quot; + name + &quot; age:&quot; + age + &quot; sex:&quot; + sex);
        }
    }
}
</code></pre>
<p><strong>JDBC 事务</strong><br>
我们在编写 java 程序的时候，在默认情况下，JDBC 连接是在自动提交模式下，即每个 SQL 语句都是在其完成时提交到数据库。但有时候我们为了提高程序运行的性能或者保持业务流程的完整性，以及使用了分布式事务管理方式，这个时候我们可能想关闭自动提交而自己管理和控制自己的事务</p>
<p>让多条 SQL 在一个事务中执行，并且保证这些语句是在同一时间共同执行的时候，我们就应该为这多条语句定义一个事务。一个事务是把单个 SQL 语句或一组 SQL 语句作为一个逻辑单元，并且如果事务中任何语句失败，则整个事务失败</p>
<p>如果我们要启动一个事务，而不是让 JDBC 驱动程序默认使用 auto-commit 模式支持。这个时候我们就要使用 Connection 对象的 setAutoCommit() 方法。我们传递一个布尔值 false 到 setAutoCommit() 中，就可以关闭自动提交。反之我们传入一个 true 便将其重新打开</p>
<p>例如</p>
<pre><code>Connection conn = null;
conn = DriverManager.getConnection(URL);
//关闭自动提交
conn.setAutoCommit(false);
</code></pre>
<p>我们关闭了自动提交后，如果我们要提交数据库更改怎么办呢？这时候就要用到我们的提交和回滚了。我们要提交更改，可以调用 commit() 方法</p>
<pre><code>conn.commit();
</code></pre>
<p>尤其不要忘记，在 catch 块内添加回滚事务，表示操作出现异常，撤销事务</p>
<pre><code>conn.rollback();
</code></pre>
<h2 id="插入数据">插入数据</h2>
<p>JDBC 插入数据使用的频率非常高，接下来说明如何使用 JDBC 插入数据</p>
<p><strong>编程实战</strong><br>
创建数据库（若之前已经创建了 Students 表需提前删除再操作）</p>
<pre><code>    sudo service mysql start
    mysql -u root
    create database EXAMPLE;
    use EXAMPLE;
    create table Students
    (
        id int not null,
        age int not null,
        name varchar(255),
        primary key(id)
    );
</code></pre>
<p>在 /home/project 目录下新建一个JdbcInsertTest.java</p>
<pre><code>import java.sql.*;

public class JdbcInsertTest {
    public static Connection connection = null;
    public static void main(String[] args) {
        try {
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
            connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/EXAMPLE&quot;, &quot;root&quot;, &quot;&quot;);
            Statement statement = connection.createStatement();
            //单条插入
            boolean execute = statement.execute(&quot;insert into Students values (0,1,'shiyanlou')&quot;);
            if (execute) {
                System.out.println(&quot;插入失败&quot;);
            }else {
                System.out.println(&quot;单条插入成功&quot;);
            }
            // 批量插入  需要关闭自动提交
            connection.setAutoCommit(false);
            String sql = &quot;insert into Students values (?,?,?)&quot;;
            PreparedStatement preparedStatement = connection.prepareStatement(sql);
            //设置插入的值
            for (int i = 1; i &lt;= 10; i++) {
                preparedStatement.setInt(1, i);
                preparedStatement.setInt(2, i + 10);
                preparedStatement.setString(3, &quot;shiyanlou&quot;);
                preparedStatement.addBatch();
            }
            //执行批量插入，使用executeBatch 方法
            preparedStatement.executeBatch();
            //提交到数据库
            connection.commit();
            System.out.println(&quot;提交批量插入完成&quot;);
        } catch (ClassNotFoundException | SQLException e) {
            e.printStackTrace();
        }

    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ wget https://labfile.oss.aliyuncs.com/courses/1230/mysql-connector-java-5.1.47.jar
$ javac -cp .:mysql-connector-java-5.1.47.jar JdbcInsertTest.java
$ java -cp .:mysql-connector-java-5.1.47.jar JdbcInsertTest
单条插入成功
提交批量插入完成
</code></pre>
<p>如果成功运行，进入数据库查看数据是否有增加</p>
<pre><code>mysql -u root
use EXAMPLE;
select * from Students;
</code></pre>
<p><strong>练习题：插入数据</strong><br>
启动数据库</p>
<pre><code>$ sudo service mysql start
</code></pre>
<p>创建一个数据库test，在数据库中创建一个数据表user，表内容如下</p>
<pre><code>create database test;
use test;
CREATE TABLE user
(
    id int PRIMARY KEY,
    name varchar(50),
    age int,
    sex varchar(10)
);
</code></pre>
<p>在 /home/project 目录下创建一个文件 InsertDemo.java，使用 jdbc 完成以下操作</p>
<ul>
<li>将用户 id：10，name：shiyanlou，age：22，sex：男 插入到数据库</li>
</ul>
<p>JDBC 驱动下载</p>
<pre><code>$ wget https://labfile.oss.aliyuncs.com/courses/1230/mysql-connector-java-5.1.47.jar
</code></pre>
<p>参考答案</p>
<pre><code>import java.sql.*;

public class InsertDemo {
    public static Connection connection = null;
    public static void main(String[] args) {
        try {
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
            connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;, &quot;root&quot;, &quot;&quot;);
            Statement statement = connection.createStatement();
            statement.execute(&quot;insert into user values (10,'shiyanlou',22,'男')&quot;);
            statement.close();
            connection.close();
        } catch (ClassNotFoundException | SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                connection.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础9-多线程]]></title>
        <id>https://y-rui.github.io/post/java-ji-chu-9-duo-xian-cheng/</id>
        <link href="https://y-rui.github.io/post/java-ji-chu-9-duo-xian-cheng/">
        </link>
        <updated>2020-08-28T07:22:23.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>Java 给多线程编程提供了内置的支持。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。本节主要讲解 Java 多线程的一些概念以及其实现</li>
</ul>
<h2 id="什么是线程">什么是线程</h2>
<ul>
<li>线程：程序执行流的最小单元。它是进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派 CPU 的基本单位</li>
</ul>
<p>如同大自然中的万物，线程也有「生老病死」的过程，下图表示了一个线程从创建到消亡的过程，以及过程中的状态<br>
<img src="https://y-rui.github.io/post-images/1608708198359.png" alt="" loading="lazy"><br>
结合线程的生命周期来看看多线程的定义</p>
<ul>
<li>多线程：从软件或者硬件上实现多个线程并发执行的技术。在单个程序中同时运行多个线程完成不同的工作</li>
</ul>
<p>在 Java 中，垃圾回收机制就是通过一个线程在后台实现的，这样做的好处在于：开发者通常不需要为内存管理投入太多的精力。反映到我们现实生活中，在浏览网页时，浏览器能够同时下载多张图片；实验楼的服务器能够容纳多个用户同时进行在线实验，这些都是多线程带来的好处</p>
<p>从专业的角度来看，多线程编程是为了最大限度地利用 CPU 资源——当处理某个线程不需要占用 CPU 而只需要利用 IO 资源时，允许其他的那些需要 CPU 资源的线程有机会利用 CPU。这或许就是多线程编程的最终目的。当然，你也可以进一步了解</p>
<p>对于多线程和线程之间的关系，你可以这样理解：一个使用了多线程技术的程序，包含了两条或两条以上并发运行的线程（Thread）</p>
<h2 id="多线程实现">多线程实现</h2>
<p>Java 中的 Thread 类就是专门用来创建线程和操作线程的类</p>
<p><strong>创建线程</strong><br>
创建线程的方法</p>
<ol>
<li>继承 Thread 类并重写它的 run() 方法，然后用这个子类来创建对象并调用 start() 方法</li>
<li>定义一个类并实现 Runnable 接口，实现 run() 方法</li>
</ol>
<p>总的来说就是线程通过 start() 方法启动而不是 run() 方法，run() 方法的内容为我们要实现的业务逻辑</p>
<p><strong>编程实例</strong><br>
在 /home/project/ 目录下新建一个类 CreateThread</p>
<p>代码片段如下</p>
<pre><code>public class CreateThread {

    public static void main(String[] args) {
        Thread1 thread1 = new Thread1();
        //声明一个Thread1对象，这个Thread1类继承自Thread类的

        Thread thread2 = new Thread(new Thread2());
        //传递一个匿名对象作为参数

        thread1.start();
        thread2.start();
        //启动线程
    }
}

class Thread1 extends Thread {
    @Override
    public void run() {
        //在run()方法中放入线程要完成的工作

        //这里我们把两个线程各自的工作设置为打印100次信息
        for (int i = 0; i &lt; 100; ++i) {
            System.out.println(&quot;Hello! This is &quot; + i);
        }

        //在这个循环结束后，线程便会自动结束
    }
}

class Thread2 implements Runnable {
    //与Thread1不同，如果当一个线程已经继承了另一个类时，就建议你通过实现Runnable接口来构造

    @Override
    public void run() {
        for (int i = 0; i &lt; 100; ++i) {
            System.out.println(&quot;Thanks. There is &quot; + i);
        }
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac CreateThread.java
$ java CreateThread
Hello! This is 0
Hello! This is 1
Hello! This is 2
Thanks. There is 0
Thanks. There is 1
Hello! This is 3
Hello! This is 4
Thanks. There is 2
........
</code></pre>
<p>你在控制台就可以看到两个线程近似交替地在输出信息。受到系统调度的影响，两个线程输出信息的先后顺序可能不同</p>
<h2 id="线程变量">线程变量</h2>
<ul>
<li>ThreadLocal，即线程变量，是一个以 ThreadLocal 对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个 ThreadLocal 对象查询到绑定在这个线程上的一个值。 可以通过 set(T) 方法来设置一个值，在当前线程下再通过 get() 方法获取到原先设置的值</li>
</ul>
<p><strong>编程实例</strong><br>
在 /home/project/ 目录下新建一个源代码文件 ThreadLocalDemo.java</p>
<pre><code>public class ThreadLocalDemo {

    public static void main(String[] args) {
        ThreadDemo threadDemo = new ThreadDemo();
        //启动2个线程
        new Thread(threadDemo).start();
        new Thread(threadDemo).start();

    }
}

class ThreadDemo implements Runnable {
    //使用ThreadLocal提供的静态方法创建一个线程变量 并且初始化值为0
    private static ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; 0);

    @Override
    public void run() {
        for (int i = 0; i &lt; 10; i++) {
            //get方法获取线程变量值
            Integer integer = threadLocal.get();
            integer += 1;
            //set方法设置线程变量值
            threadLocal.set(integer);
            System.out.println(integer);
        }
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac ThreadLocalDemo.java
$ java ThreadLocalDemo
1
1
2
2
3
3
4
4
5
5
6
6
7
7
8
8
9
10
9
10
</code></pre>
<p>通过控制台的结果可以看到，两个线程之间的变量互不干涉</p>
<p><strong>线程共享变量</strong><br>
如果我们去掉了 ThreadLocal，其他的流程都不改变，已经使用 2 个线程自增变量会如何呢？</p>
<p>修改 ThreadLocalDemo.java</p>
<pre><code>public class ThreadLocalDemo {

    public static void main(String[] args) {
        ThreadDemo threadDemo = new ThreadDemo();
        new Thread(threadDemo).start();
        new Thread(threadDemo).start();

    }
}

class ThreadDemo implements Runnable {
    private Integer integer = 0;

    @Override
    public void run() {
        for (int i = 0; i &lt; 10; i++) {
            integer++;
            System.out.println(integer);
        }
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac ThreadLocalDemo.java
$ java ThreadLocalDemo

1
3
4
5
6
7
8
9
10
11
2
12
13
14
15
16
17
18
19
20
</code></pre>
<p>在没有加入 ThreadLocal 的情况下，发现 integer 变量的值增加到了 20，那是因为这个时候两个线程都是使用同一对象 threadDemo 的变量，这个时候的 integer 就变成了线程共享变量，如果同学们多运行几次，还有可能出现最后结果是 18 19 的情况，那是因为如果不做任何处理，线程共享变量都不是线程安全的，也就是说在多线程的情况下，共享变量有可能会出错</p>
<h2 id="线程同步">线程同步</h2>
<p>当多个线程操作同一个对象时，就会出现线程安全问题，被多个线程同时操作的对象数据可能会发生错误。线程同步可以保证在同一个时刻该对象只被一个线程访问</p>
<p><strong>Synchronized</strong><br>
关键字 synchronized 可以修饰方法或者以同步块的形式来进行使用，它确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，保证了线程对变量访问的可见性和排他性。它有三种使用方法</p>
<ul>
<li>对普通方式使用，将会锁住当前实例对象</li>
<li>对静态方法使用，将会锁住当前类的 Class 对象</li>
<li>对代码块使用，将会锁住代码块中的对象</li>
</ul>
<p><strong>使用示例</strong><br>
在下面的代码中，演示了三种加锁方式</p>
<pre><code>public class SynchronizedDemo {
    private static Object lock = new Object();

    public static void main(String[] args) {
        //同步代码块 锁住lock
        synchronized (lock) {
            //doSomething
        }
    }

    //静态同步方法  锁住当前类class对象
    public synchronized static void staticMethod(){

    }
    //普通同步方法  锁住当前实例对象
    public synchronized void memberMethod() {

    }
}
</code></pre>
<p><strong>java.util.concurrent</strong><br>
java.util.concurrent 包是 java5 开始引入的并发类库，提供了多种在并发编程中的适用工具类。包括原子操作类，线程池，阻塞队列，Fork/Join 框架，并发集合，线程同步锁等</p>
<p><strong>Lock 与 Unlock</strong><br>
JUC 中的 ReentrantLock 是多线程编程中常用的加锁方式，ReentrantLock 加锁比 synchronized 加锁更加的灵活，提供了更加丰富的功能</p>
<p><strong>编程实战</strong><br>
在 /home/project/ 目录下新建一个源代码文件 LockDemo.java</p>
<pre><code>import java.util.concurrent.locks.ReentrantLock;

public class LockDemo {
    private static ReentrantLock lock = new ReentrantLock();

    public static void main(String[] args) {
        Thread thread1 = new Thread(() -&gt; {
            lock.lock();
            try {
                //需要同步的代码块
                System.out.println(&quot;线程1加锁&quot;);
            }finally {
//                一定要在finally中解锁，否则可能造成死锁
                lock.unlock();
                System.out.println(&quot;线程1解锁&quot;);
            }
        });
        thread1.start();
        Thread thread2 = new Thread(() -&gt; {
            lock.lock();
            try {
                System.out.println(&quot;线程2加锁&quot;);
            }finally {
                lock.unlock();
                System.out.println(&quot;线程2解锁&quot;);
            }
        });
        thread2.start();
    }

}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac LockDemo.java
$ java LockDemo
线程1加锁
线程1解锁
线程2加锁
线程2解锁
</code></pre>
<h2 id="死锁">死锁</h2>
<p>在多线程环境下，锁的使用非常频繁，但是它会带来一下问题，比如死锁。当死锁发生时，系统将会瘫痪。比如两个线程互相等待对方释放锁</p>
<p><strong>死锁示例</strong><br>
在 /home/project/ 目录下新建一个源代码文件 DeadLockDemo.java</p>
<pre><code>public class DeadLockDemo {
    private static Object lockA = new Object();
    private static Object lockB = new Object();

    public static void main(String[] args) {
        //这里使用lambda表达式创建了一个线程
        //线程  1
        new Thread(() -&gt; {
            synchronized (lockA) {
                try {
                    //线程休眠一段时间  确保另外一个线程可以获取到b锁
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(&quot;D&quot;);
                synchronized (lockB) {
                }
            }
        }).start();
        //线程 2
        new Thread(() -&gt; {
            synchronized (lockB) {
                System.out.println(&quot;死锁...&quot;);
                synchronized (lockA) {
                }
            }
        }).start();
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac DeadLockDemo.java
$ java DeadLockDemo
死锁...
死锁...
</code></pre>
<p>在上面的编程实例中，线程 1 获取了 lockA 的锁后再去获取 lockB 的锁，而此时 lockB 已经被线程 2 获取，同时线程 2 也想获取 lockA，两个线程进这样僵持了下去，谁也不让，造成了死锁。在编程时，应该避免死锁的出现</p>
<h2 id="饥饿">饥饿</h2>
<p>饥饿是指一个可运行的进程尽管能继续执行，但被调度器无限期地忽视，而不能被调度执行的情况</p>
<p>比如当前线程处于一个低优先级的情况下，操作系统每次都调用高优先级的线程运行，就会导致当前线程虽然可以运行，但是一直不能被运行的情况</p>
<h2 id="线程生命周期">线程生命周期</h2>
<p>线程的声明周期共有 6 种状态，分别是：新建 New、运行（可运行）Runnable、阻塞Blocked、计时等待Timed Waiting、等待Waiting 和终止Terminate</p>
<ul>
<li>当你声明一个线程对象时，线程处于新建状态，系统不会为它分配资源，它只是一个空的线程对象</li>
<li>调用 start() 方法时，线程就成为了可运行状态，至于是否是运行状态，则要看系统的调度了</li>
<li>调用了 sleep() 方法、调用 wait() 方法和 IO 阻塞时，线程处于等待、计时等待或阻塞状态</li>
<li>当 run() 方法执行结束后，线程也就终止了</li>
</ul>
<p>我们通过一个例子来加深对于这些状态的理解<br>
在 /home/project/ 目录下新建 ThreadState 类，用于自定义线程的状态。主要的代码如下</p>
<pre><code>public class ThreadState implements Runnable {

    public synchronized void waitForAMoment() throws InterruptedException {

        wait(500);
        //使用wait()方法使当前线程等待500毫秒
        //或者等待其他线程调用notify()或notifyAll()方法来唤醒
    }

    public synchronized void waitForever() throws InterruptedException {

        wait();
        //不填入时间就意味着使当前线程永久等待，
        //只能等到其他线程调用notify()或notifyAll()方法才能唤醒
    }

    public synchronized void notifyNow() throws InterruptedException {

        notify();
        //使用notify()方法来唤醒那些因为调用了wait()方法而进入等待状态的线程
    }

    @Override
    public void run() {

        //这里用异常处理是为了防止可能的中断异常
        //如果任何线程中断了当前线程，则抛出该异常

        try {
            waitForAMoment();
            // 在新线程中运行waitMoment()方法

            waitForever();
            // 在新线程中运行waitForever()方法

        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>然后再新建一个测试类ThreadTest，用于输出这些状态<br>
接下来会用到 sleep() 方法，下面给出了这个方法的使用方法</p>
<ul>
<li>sleep()，在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。填入的参数为休眠的时间（单位：毫秒）</li>
</ul>
<pre><code>public class ThreadTest {
    public static void main(String[] args) throws InterruptedException {
        ThreadState state = new ThreadState();
        //声明并实例化一个ThreadState对象

        Thread thread = new Thread(state);
        //利用这个名为state的ThreadState对象来创建Thread对象

        System.out.println(&quot;Create new thread: &quot; + thread.getState());
        //使用getState()方法来获得线程的状态，并进行输出

        thread.start();
        //使用thread对象的start()方法来启动新的线程

        System.out.println(&quot;Start the thread: &quot; + thread.getState());
        //输出线程的状态

        Thread.sleep(100);
        //通过调用sleep()方法使当前这个线程休眠100毫秒，从而使新的线程运行waitForAMoment()方法

        System.out.println(&quot;Waiting for a moment (time): &quot; + thread.getState());
        //输出线程的状态

        Thread.sleep(1000);
        //使当前这个线程休眠1000毫秒，从而使新的线程运行waitForever()方法

        System.out.println(&quot;Waiting for a moment: &quot; + thread.getState());
        //输出线程的状态

        state.notifyNow();
        // 调用state的notifyNow()方法

        System.out.println(&quot;Wake up the thread: &quot; + thread.getState());
        //输出线程的状态

        Thread.sleep(1000);
        //使当前线程休眠1000毫秒，使新线程结束

        System.out.println(&quot;Terminate the thread: &quot; + thread.getState());
        //输出线程的状态
    }
}
</code></pre>
<p>检查一下代码，编译并运行</p>
<pre><code>$ javac ThreadState.java ThreadTest.java
$ java ThreadTest
Create new thread: NEW
Start the thread: RUNNABLE
Waiting for a moment (time): TIMED_WAITING
Waiting for a moment: WAITING
Wake up the thread: BLOCKED
Terminate the thread: TERMINATED
</code></pre>
<h2 id="练习题顺序打印字母">练习题：顺序打印字母</h2>
<p>在 /home/project/ 目录下新建文件ThreadTest.java<br>
你需要完成以下需求</p>
<ol>
<li>创建三个线程输出 A、B、C 三个字符。</li>
<li>要求 A、B、C 必须顺序输出，连续输出三次</li>
</ol>
<p>结果如下</p>
<pre><code>A
B
C
A
B
C
A
B
C
</code></pre>
<p><strong>参考答案</strong></p>
<pre><code>import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class ThreadTest {
    private static ReentrantLock lock = new ReentrantLock();
    private static int count = 0;
    private static Condition condition = lock.newCondition();

    public static void main(String[] args) {
        Thread A = new Thread(() -&gt; {
        //加锁 一次只有一个线程输出
            lock.lock();
            try {
                while (true) {
                //因为只循环3次 所以到9的时候就结束循环
                    if (count == 9) {
                        break;
                    }
                    //当余数为0 就输出A
                    if (count % 3 == 0) {
                        count++;
                        System.out.println(&quot;A&quot;);
                        //唤醒其他等待线程
                        condition.signalAll();
                    } else {
                        try {
                        //等待
                            condition.await();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            } finally {
                lock.unlock();
            }
        });
        Thread B = new Thread(() -&gt; {
            lock.lock();
            try {
                while (true) {
                    if (count == 9) {
                        break;
                    }
                    if (count % 3 == 1) {
                        count++;
                        System.out.println(&quot;B&quot;);
                        condition.signalAll();
                    } else {
                        try {
                            condition.await();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            } finally {
                lock.unlock();
            }
        });
        Thread C = new Thread(() -&gt; {
            lock.lock();
            try {
                while (true) {
                    if (count == 9) {
                        break;
                    }
                    if (count % 3 == 2) {
                        count++;
                        System.out.println(&quot;C&quot;);
                        condition.signalAll();
                    } else {
                        try {
                            condition.await();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            } finally {
                lock.unlock();
            }
        });

        A.start();
        B.start();
        C.start();

    }
}
</code></pre>
<h2 id="arrayblockingqueue">ArrayBlockingQueue</h2>
<p>ArrayBlockingQueue 是由数组支持的有界阻塞队列。位于 java.util.concurrent 包下<br>
首先看看其构造方法</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public ArrayBlockingQueue(int capacity)</code></td>
<td>构造大小为 capacity 的队列</td>
</tr>
<tr>
<td><code>public ArrayBlockingQueue(int capacity, boolean fair)</code></td>
<td>指定队列大小，以及内部实现是公平锁还是非公平锁</td>
</tr>
<tr>
<td><code>public ArrayBlockingQueue(int capacity, boolean fair, Collection&lt;? extends E&gt; c)</code></td>
<td>指定队列大小，以及锁实现，并且在初始化是加入集合 c</td>
</tr>
</tbody>
</table>
<p>入队常用方法</p>
<table>
<thead>
<tr>
<th>入队方法</th>
<th>队列已满</th>
<th>队列未满</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>add</code></td>
<td>抛出异常</td>
<td>返回 true</td>
</tr>
<tr>
<td><code>offer</code></td>
<td>返回 false</td>
<td>返回 true</td>
</tr>
<tr>
<td><code>put</code></td>
<td>阻塞直到插入</td>
<td>没有返回值</td>
</tr>
</tbody>
</table>
<p>出队常用方法</p>
<table>
<thead>
<tr>
<th>出队方法</th>
<th>队列为空</th>
<th>队列不为空</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>remove</code></td>
<td>抛出异常</td>
<td>移出并返回队首</td>
</tr>
<tr>
<td><code>poll</code></td>
<td>返回 null</td>
<td>移出并返回队首</td>
</tr>
<tr>
<td><code>take</code></td>
<td>阻塞直到返回</td>
<td>移出并返回队首</td>
</tr>
</tbody>
</table>
<p><strong>编程实战</strong><br>
在 /home/project/ 目录下新建源代码文件 ABQDemo.java</p>
<pre><code>import java.util.concurrent.ArrayBlockingQueue;

public class ABQDemo {
    //构建大小为10的阻塞队列
    private static ArrayBlockingQueue&lt;Integer&gt; arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(10);

    public static void main(String[] args) {
        Thread thread1 = new Thread(() -&gt; {
            for (int i = 1; i &lt;= 10; i++) {
                arrayBlockingQueue.add(i);
            }
        });
        thread1.start();
        try {
            //等待线程1执行完毕
            thread1.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(() -&gt; {
            //如果插入失败
            if (!arrayBlockingQueue.offer(11)) {
                System.out.println(&quot;插入元素11失败&quot;);
            }
            try {
                //一直阻塞直到插入元素11，注意这里阻塞的不是主线程，main方法还是继续运行
                arrayBlockingQueue.put(11);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }).start();
        Thread thread2=new Thread(() -&gt; {
            Integer element;
            System.out.println(&quot;开始出队:&quot;);
            //打印队列中的元素
            while ((element = arrayBlockingQueue.poll()) != null) {
                System.out.print(&quot;\t&quot;+element);
            }
        });
        thread2.start();
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac ABQDemo.java
$ java ABQDemo
插入元素11失败
开始出队:
    1    2    3    4    5    6    7    8    9    10    11
</code></pre>
<h2 id="生产者消费者模式">生产者消费者模式</h2>
<p>生产者消费者模式是多线程编程中非常重要的设计模式，生产者负责生产数据，消费者负责消费数据。生产者消费者模式中间通常还有一个缓冲区，用于存放生产者生产的数据，而消费者则从缓冲区中获取，这样可以降低生产者和消费者之间的耦合度</p>
<p>举个例子来说吧，比如有厂家，代理商，顾客，厂家就是生产者，顾客就是消费者，代理商就是缓冲区，顾客从代理商这里买东西，代理商负责从厂家处拿货，并且销售给顾客，顾客不用直接和厂家打交道，并且通过代理商，就可以直接获取商品，或者从代理商处知道货物不足，需要等待</p>
<p><strong>编程实例</strong><br>
在 /home/project 目录下新建一个源代码文件 PCModel.java</p>
<pre><code>import java.util.Random;
import java.util.concurrent.LinkedBlockingQueue;

public class PCModel {
    //阻塞队列
    private static LinkedBlockingQueue&lt;Integer&gt; queue = new LinkedBlockingQueue&lt;&gt;();

    public static void main(String[] args) {
        //生产者
        Thread provider = new Thread(() -&gt; {
            Random random = new Random();
            for (int j = 0; j &lt; 5; j++) {
                try {
                    int i = random.nextInt();
                    //注释直到插入数据
                    queue.put(i);
                    System.out.println(&quot;生产数据：&quot; + i);
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        //消费者
        Thread consumer = new Thread(() -&gt; {
            Integer data;
            for (int i = 0; i &lt; 5; i++) {
                try {
                    //阻塞直到取出数据
                    data = queue.take();
                    System.out.println(&quot;消费数据：&quot; + data);
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        //启动线程
        provider.start();
        consumer.start();
    }
}
</code></pre>
<p><strong>练习题</strong><br>
在 /home/project 目录下新建一个源代码文件 ProviderConsumerTest.java，你需要完成以下需求</p>
<ul>
<li>参照编程实例，启动多个生产者和消费者生成和消费数据</li>
</ul>
<p>注意：不要直接使用上面的编程实例直接使用多个 provider.start() 或者 consumer.start()，会抛出异常报错，应该重新实例化多个生产者和消费者，不能一个实例启动多次</p>
<h2 id="线程池">线程池</h2>
<ul>
<li>线程池（英语：thread pool）：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度</li>
</ul>
<p>由于 Java 创建和销毁线程都会带来资源上的销毁，所以线程池可以帮助我们复用线程，减少资源消耗</p>
<p><strong>编程实战</strong><br>
Java 线程池可以通过 Executors 工具类创建，Executors 常用方法</p>
<ul>
<li>newFixedThreadPool(int nThreads): 创建一个固定大小为 n 的线程池</li>
<li>newSingleThreadExecutor(): 创建只有一个线程的线程池</li>
<li>newCachedThreadPool(): 创建一个根据需要创建新线程的线程池</li>
</ul>
<p>在 /home/project/ 目录下新建源代码文件 ThreadPoolDemo.java</p>
<pre><code>import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPoolDemo {
    //使用Executors 创建一个固定大小为5的线程池
    private static ExecutorService executorService = Executors.newFixedThreadPool(5);

    public static void main(String[] args) {
//        提交任务
        executorService.submit(() -&gt; {
            for (int i = 0; i &lt; 10; i++) {
                System.out.print(i + &quot; &quot;);
            }
        });
        //停止线程池 并不会立即关闭 ，而是在线程池中的任务执行完毕后才关闭
        executorService.shutdown();
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac ThreadPoolDemo.java
$ java ThreadPoolDemo
0 1 2 3 4 5 6 7 8 9
</code></pre>
<p>除了使用 Executors 工具类帮助我们创建之外，也可以直接创建线程池</p>
<p>在 /home/project/ 目录下新建源代码文件 ThreadPoolDemo2.java</p>
<pre><code>import java.util.concurrent.ExecutorService;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class ThreadPoolDemo2 {
    private static ExecutorService executorService = new ThreadPoolExecutor(
            5, //核心线程数为5
            10,//最大线程数为10
            0L, TimeUnit.MILLISECONDS,//非核心线程存活时间
            new LinkedBlockingQueue&lt;&gt;());//任务队列

    public static void main(String[] args) {
        //提交任务
        executorService.submit(() -&gt; {
            for (int i = 0; i &lt; 10; i++) {
                System.out.print(i + &quot; &quot;);
            }
        });
        //关闭线程池
        executorService.shutdown();
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac ThreadPoolDemo2.java
$ java ThreadPoolDemo2
0 1 2 3 4 5 6 7 8 9
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础8-网络编程]]></title>
        <id>https://y-rui.github.io/post/java-ji-chu-8-wang-luo-bian-cheng/</id>
        <link href="https://y-rui.github.io/post/java-ji-chu-8-wang-luo-bian-cheng/">
        </link>
        <updated>2020-08-28T07:09:11.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。java.net 包中 J2SE 的 API 包含有类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。本节重点讲解 Java 网络编程中的常用类，以及计算机网络的一些基础知识</li>
</ul>
<h2 id="socket-简介">Socket 简介</h2>
<p>网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个 socket</p>
<p>建立网络通信连接至少要一对端口号 (socket)。socket 本质是编程接口 (API)，对 TCP/IP 的封装，TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口；HTTP 是轿车，提供了封装或者显示数据的具体形式；Socket 是发动机，提供了网络通信的能力</p>
<p>Socket 的英文原义是“孔”或“插座”。作为 BSD UNIX 的进程通信机制，取后一种意思。通常也称作&quot;套接字&quot;，用于描述 IP 地址和端口，是一个通信链的句柄，可以用来实现不同虚拟机或不同计算机之间的通信。在 Internet 上的主机一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个 Socket，并绑定到一个端口上，不同的端口对应于不同的服务。Socket 正如其英文原义那样，像一个多孔插座。一台主机犹如布满各种插座的房间，每个插座有一个编号，有的插座提供 220 伏交流电， 有的提供 110 伏交流电，有的则提供有线电视节目。 客户软件将插头插到不同编号的插座，就可以得到不同的服务</p>
<h2 id="tcp">TCP</h2>
<p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。在简化的计算机网络 OSI 模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内另一个重要的传输协议。在因特网协议族（Internet protocol suite）中，TCP 层是位于 IP 层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是 IP 层不提供这样的流机制，而是提供不可靠的包交换</p>
<p>应用层向 TCP 层发送用于网间传输的、用 8 位字节表示的数据流，然后 TCP 把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制）。之后 TCP 把结果包传给 IP 层，由它来通过网络将包传送给接收端实体的 TCP 层。TCP 为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP 用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和</p>
<h2 id="udp">UDP</h2>
<p>UDP 是 User Datagram Protocol 的简称， 中文名是用户数据报协议，是 OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，IETF RFC 768 是 UDP 的正式规范。UDP 在 IP 报文的协议号是 17</p>
<p>UDP 协议全称是用户数据报协议，在网络中它与 TCP 协议一样用于处理数据包，是一种无连接的协议。在 OSI 模型中，在第四层——传输层，处于 IP 协议的上一层。UDP 有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。UDP 用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的客户 / 服务器模式的网络应用都需要使用 UDP 协议。UDP 协议从问世至今已经被使用了很多年，虽然其最初的光彩已经被一些类似协议所掩盖，但是即使是在今天 UDP 仍然不失为一项非常实用和可行的网络传输层协议</p>
<p>与所熟知的 TCP（传输控制协议）协议一样，UDP 协议直接位于 IP（网际协议）协议的顶层。根据 OSI（开放系统互连）参考模型，UDP 和 TCP 都属于传输层协议。UDP 协议的主要作用是将网络数据流量压缩成数据包的形式。一个典型的数据包就是一个二进制数据的传输单位。每一个数据包的前 8 个字节用来包含报头信息，剩余字节则用来包含具体的传输数据</p>
<h2 id="httpurlconnection">HttpURLConnection</h2>
<p>HttpURLConnection 位于 java.net 包中，支持 HTTP 特定功能。我们可以使用它来发起网络请求，获取服务器的相关资源</p>
<p><strong>编程实战</strong><br>
HttpURLConnection 提供了很多方法用于使用 Http，这里只演示了使用 HttpURLConnection 类的基本流程</p>
<p>在 /home/project/ 目录下新建源代码文件 HttpUrlTest.java</p>
<pre><code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;

public class HttpUrlTest {
    public static void main(String[] args) {
        try {
            //设置url
            URL shiyanlou = new URL(&quot;https://www.lanqiao.cn&quot;);
            //打开连接
            HttpURLConnection urlConnection = (HttpURLConnection)shiyanlou.openConnection();
            //设置请求方法
            urlConnection.setRequestMethod(&quot;GET&quot;);
            //设置连接超时时间
            urlConnection.setConnectTimeout(1000);
            //获取输入流
            InputStream inputStream = urlConnection.getInputStream();
            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
            //打印结果
            bufferedReader.lines().forEach(System.out::println);
            //关闭连接
            inputStream.close();
            bufferedReader.close();
            urlConnection.disconnect();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<pre><code>$ javac HttpUrlTest.java
$ java HttpUrlTest
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;zh-CN&quot;&gt;
.....内容过长省略.....
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>如果没有问题的话，那么我们将看到实验楼首页的 html 源代码</p>
<h2 id="inetaddress-类">InetAddress 类</h2>
<p>InetAddress类用于表示 IP 地址，比如在进行 Socket 编程时，就会使用到该类</p>
<p>InetAddress没有公共构造方法，我们只能使用它提供的静态方法来构建一个 InetAddress 类实例</p>
<ul>
<li>getLocalHost()： 返回本地主机地址</li>
<li>getAllByName（String host）：从指定的主机名返回 InetAddress 对象的数组，因为主机名可以与多个 IP 地址相关联</li>
<li>getByAddress（byte [] addr）：从原始 IP 地址的字节数组中返回一个 InetAddress 对象</li>
<li>getByName（String host）：根据提供的主机名创建一个 InetAddress 对象</li>
<li>getHostAddress()：返回文本表示的 IP 地址字符串</li>
<li>getHostname()：获取主机名</li>
</ul>
<p><strong>编程实战</strong><br>
在 /home/project 目录下新建一个 InetAddressDemo.java</p>
<pre><code>import java.net.InetAddress;
import java.net.UnknownHostException;

public class InetAddressDemo {
    public static void main(String[] args) {
        try {
            InetAddress shiyanlou = InetAddress.getByName(&quot;www.lanqiao.cn&quot;);
            //toString 方法将输出主机名和ip地址
            System.out.println(shiyanlou.toString());
            //获取ip地址
            String ip = shiyanlou.toString().split(&quot;/&quot;)[1];
            //根据IP地址获取主机名
            InetAddress byAddress = InetAddress.getByName(ip);
            System.out.println(&quot;get hostname by IP address:&quot; + byAddress.getHostName());
            System.out.println(&quot;localhost: &quot;+InetAddress.getLocalHost());
        } catch (UnknownHostException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>javac InetAddressDemo.java
java InetAddressDemo
</code></pre>
<p>运行结果</p>
<pre><code>www.lanqiao.cn/121.40.227.60
get hostname by IP address:www.shiyanlou.com
localhost: 90ce6f59cfd6/192.168.42.3
</code></pre>
<h2 id="socket">Socket</h2>
<p>Socket 类代表一个客户端套接字，可以使用该类向服务器发送和接受数据。一般需要通过下面几个步骤</p>
<ol>
<li>建立与服务器的连接</li>
<li>使用输出流将数据发送到服务器</li>
<li>使用输入流读取服务器返回的数据</li>
<li>关闭连接</li>
</ol>
<p><strong>构造方法</strong><br>
Socket 常用构造方法</p>
<ul>
<li>Socket(InetAddress address, int port)：创建一个套接字，连接到指定 IP 地址和端口的服务器</li>
<li>Socket(String host, int port)：创建一个套接字，连接到指定的主机名和端口的服务器</li>
<li>Socket(InetAddress address, int port, InetAddress localAddr, int localPort)：创建一个套接字连接到指定的 IP 地址和端口的服务器，并且显示的指定客户端地址和端口</li>
</ul>
<p>在创建 Socket 时，需要捕获异常</p>
<p><strong>getOutputStream()</strong><br>
该方法可以获取输出流，在建立连接后，可以使用该方法获取输出流，发送数据到服务器。发送数据的方式和使用 IO 流是相同的，使用 write 方法发送指定的数据即可</p>
<p><strong>getInputStream()</strong><br>
用户获取输入流，通过该方法获取输入流之后可以读取服务器发送来的数据。使用方法和 IO 流相同，使用 read 方法即可</p>
<p><strong>close()</strong><br>
关闭 Socket，可能抛出 IO 异常，所以我们同样需要捕获异常</p>
<h2 id="serversocket">ServerSocket</h2>
<p>ServerSocket类用于实现服务器套接字，服务器套接字会等待客户端网络连接，与客户端连接之后，会进行一系列操作，然后将结果返回给客户端</p>
<p>创建一个 ServerSocket 一般需要以下几个步骤</p>
<ol>
<li>创建服务器套接字并将其绑定到特定的接口</li>
<li>等待客户端连接</li>
<li>通过客户端套接字获取输入流，从客户端读取数据</li>
<li>通过客户端套接字获取输出流，发送数据到客户端</li>
<li>关闭套接字</li>
</ol>
<p><strong>构造方法</strong><br>
常见构造方法</p>
<ul>
<li>ServerSocket()：创建一个未绑定端口的服务器套接字</li>
<li>ServerSocket(int port)：创建绑定到指定端口号的服务器套接字</li>
<li>ServerSocket(int port,int backlog)：创建一个绑定到指定端口号的服务器套接字，并且backlog 参数指定了最大排队连接数</li>
<li>ServerSocket(int port,int backlog,InetAddress bindAddr)：创建服务器套接字并将其绑定到指定的端口号和本地 IP 地址</li>
</ul>
<p>示例</p>
<pre><code>ServerSocket serverSocket = new ServerSocket(8888);
</code></pre>
<p><strong>accept()</strong><br>
用于监听客户端连接请求，当调用该方法时，会阻塞当前线程，直到有客户端发起请求与其建立连接，否则将一直等待。当连接成功后，将返回一个 Socket 对象</p>
<p>ServerSocket<br>
ServerSocket类用于实现服务器套接字，服务器套接字会等待客户端网络连接，与客户端连接之后，会进行一系列操作，然后将结果返回给客户端。</p>
<p>创建一个 ServerSocket 一般需要以下几个步骤：</p>
<p>创建服务器套接字并将其绑定到特定的接口<br>
等待客户端连接<br>
通过客户端套接字获取输入流，从客户端读取数据<br>
通过客户端套接字获取输出流，发送数据到客户端<br>
关闭套接字<br>
构造方法<br>
常见构造方法：</p>
<p>ServerSocket()：创建一个未绑定端口的服务器套接字。</p>
<p>ServerSocket(int port)：创建绑定到指定端口号的服务器套接字。</p>
<p>ServerSocket(int port,int backlog)：创建一个绑定到指定端口号的服务器套接字，并且backlog 参数指定了最大排队连接数。</p>
<p>ServerSocket(int port,int backlog,InetAddress bindAddr)：创建服务器套接字并将其绑定到指定的端口号和本地 IP 地址。</p>
<p>示例：</p>
<p>ServerSocket serverSocket = new ServerSocket(8888);<br>
copy<br>
accept()<br>
用于监听客户端连接请求，当调用该方法时，会阻塞当前线程，直到有客户端发起请求与其建立连接，否则将一直等待。当连接成功后，将返回一个 Socket 对象。</p>
<p><strong>close()</strong><br>
用于关闭服务器套接字，服务器停止后，将断开所有连接</p>
<h2 id="网络编程实例">网络编程实例</h2>
<p>java.net 包提供了两个类 Socket 和 ServerSocket，分别实现 Socket 连接的客户端和服务器端</p>
<p>我们编译一个简单的 Socket 应用，实现客户端发送信息给服务端，服务端再将信息发送回客户端的回显的功能</p>
<p>在 /home/project/ 目录下新建源代码文件 EchoServer.java</p>
<pre><code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;


public class EchoServer {
    public static void main(String[] args) {
        try {
            //服务端需要使用ServerSocket类
            ServerSocket serverSocket = new ServerSocket(1080);
            //阻塞 等待客户端连接
            Socket client = serverSocket.accept();
            PrintWriter out = new PrintWriter(client.getOutputStream(), true);
            BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));
            String userIn;
            while ((userIn = in.readLine()) != null) {
                System.out.println(&quot;收到客户端消息：&quot; + userIn);
                //发回客户端
                out.println(userIn);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>在 /home/project/ 目录下新建源代码文件 EchoClient.java</p>
<pre><code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.Scanner;

public class EchoClient {
    public static void main(String[] args) {
        String hostname = &quot;127.0.0.1&quot;;
        //socket端口
        int port = 1080;
        Scanner userIn = new Scanner(System.in);
        try {
            //建立socket连接
            Socket socket = new Socket(hostname, port);
            //获取socket输出流
            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
            //获取输入流
            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            String userInput;
            System.out.println(&quot;请输入信息：&quot;);
            //当用户输入exit时退出
            while (!&quot;exit&quot;.equals(userInput = userIn.nextLine())) {
                out.println(userInput);
                System.out.println(&quot;收到服务端回应:&quot; + in.readLine());
            }
            //关闭socket
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>编译运行</p>
<p>打开两个 terminal，一个运行服务端，一个运行客户端</p>
<p>首先启动服务端，不能先启动客户端，否则报错</p>
<p>服务端启动命令</p>
<pre><code>$ javac EchoServer.java
$ java EchoServer
</code></pre>
<p>接着切换到客户端 terminal。客户端启动命令</p>
<pre><code>$ javac EchoClient.java
$ java EchoClient
</code></pre>
<p>运行结果</p>
<ul>
<li>客户端</li>
</ul>
<pre><code>请输入信息：
shi
收到服务端回应:shi
yan
收到服务端回应:yan
lou
收到服务端回应:lou
exit
</code></pre>
<ul>
<li>服务端</li>
</ul>
<pre><code>收到客户端消息：shi
收到客户端消息：yan
收到客户端消息：lou
</code></pre>
<h2 id="练习题多线程服务器">练习题：多线程服务器</h2>
<p>在 /home/project/ 目录下新建源代码文件 Server.java 和Client.java</p>
<p>你需要完成以下要求</p>
<ul>
<li>Server 可以同时接受多个客户端的连接</li>
<li>每个线程负责一个连接</li>
<li>客户端发送消息给服务端，服务端再将客户端发送的消息发回客户端</li>
</ul>
<p>参考答案<br>
client</p>
<pre><code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.Scanner;

public class Client {
    public static void main(String[] args) {
        String hostname = &quot;127.0.0.1&quot;;
        //socket端口
        int port = 1080;
        Scanner userIn = new Scanner(System.in);
        try {
            //建立socket连接
            Socket socket = new Socket(hostname, port);
            //获取socket输出流
            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
            //获取输入流
            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            String userInput;
            System.out.println(&quot;请输入信息：&quot;);
            //当用户输入exit时退出
            while (!&quot;exit&quot;.equals(userInput = userIn.nextLine())) {
                out.println(userInput);
                System.out.println(&quot;收到服务端回应:&quot; + in.readLine());
            }
            //关闭socket
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>server</p>
<pre><code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;


public class Server {
    public static void main(String[] args) {
        try {
            //服务端需要使用ServerSocket类
            ServerSocket serverSocket = new ServerSocket(1080);
            //阻塞 等待客户端连接
            while (true) {
                Thread thread = new Thread(new ServerThread(serverSocket.accept()));
                thread.start();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    static class ServerThread implements Runnable {
        Socket client;

        public ServerThread(Socket client) {
            this.client = client;
        }

        @Override
        public void run() {
            try {
                PrintWriter out = new PrintWriter(client.getOutputStream(), true);
                BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));
                String userIn;
                while ((userIn = in.readLine()) != null) {
                    System.out.println(&quot;收到客户端消息：&quot; + userIn);
                    //发回客户端
                    out.println(userIn);
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
]]></content>
    </entry>
</feed>