<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://y-rui.github.io</id>
    <title>NoteForStudy</title>
    <updated>2020-12-20T12:07:01.923Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://y-rui.github.io"/>
    <link rel="self" href="https://y-rui.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://y-rui.github.io/images/avatar.png</logo>
    <icon>https://y-rui.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, NoteForStudy</rights>
    <entry>
        <title type="html"><![CDATA[Java基础5-异常]]></title>
        <id>https://y-rui.github.io/post/java-ji-chu-5-yi-chang/</id>
        <link href="https://y-rui.github.io/post/java-ji-chu-5-yi-chang/">
        </link>
        <updated>2020-08-25T10:52:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="异常概述">异常概述</h2>
<ul>
<li>异常指不期而至的各种状况，它在程序运行的过程中发生。作为开发者，我们都希望自己写的代码永远都不会出现 bug，然而现实告诉我们并没有这样的情景。如果用户在程序的使用过程中因为一些原因造成他的数据丢失，这个用户就可能不会再使用该程序了。所以，对于程序的错误以及外部环境能够对用户造成的影响，我们应当及时报告并且以适当的方式来处理这个错误</li>
<li>之所以要处理异常，也是为了增强程序的鲁棒性</li>
</ul>
<p>异常都是从 Throwable 类派生出来的，而 Throwable 类是直接从 Object 类继承而来</p>
<h2 id="异常分类">异常分类</h2>
<p>异常通常有四类</p>
<ol>
<li>Error：系统内部错误，这类错误由系统进行处理，程序本身无需捕获处理</li>
<li>Exception：可以处理的异常</li>
<li>RuntimeException：可以捕获，也可以不捕获的异常</li>
<li>继承 Exception 的其他类：必须捕获，通常在 API 文档中会说明这些方法抛出哪些异常</li>
</ol>
<p>平时主要关注的异常是 Exception 下的异常，而 Exception 异常下又主要分为两大类异常，一个是派生于 RuntimeExcption 的异常，一个是除了 RuntimeExcption 体系之外的其他异常</p>
<p>RuntimeExcption 异常（运行时异常）通常有以下几种</p>
<ul>
<li>错误的类型转换</li>
<li>数组访问越界</li>
<li>访问 null 指针</li>
<li>算术异常</li>
</ul>
<p>一般来说，RuntimeException 都是代码逻辑出现问题</p>
<p>非 RuntimeException（受检异常，Checked Exception）一般有</p>
<ul>
<li>打开一个不存在的文件</li>
<li>没有找到具有指定名称的类</li>
<li>操作文件异常</li>
</ul>
<p>受检异常是编译器要求必须处理的异常，必须使用 try catch 处理，或者使用 throw 抛出，交给上层调用者处理</p>
<h2 id="声明及抛出">声明及抛出</h2>
<p><strong>throw 抛出异常</strong><br>
当程序运行时数据出现错误或者我们不希望发生的情况出现的话，可以通过抛出异常来处理</p>
<p>异常抛出语法</p>
<pre><code>throw new 异常类();
</code></pre>
<p>在 /home/project/ 目录下新建 ThrowTest.java</p>
<pre><code>public class ThrowTest {

    public static void main(String[] args) {
        Integer a = 1;
        Integer b = null;
        //当a或者b为null时，抛出异常
        if (a == null || b == null) {
            throw new NullPointerException();
        } else {
            System.out.println(a + b);
        }
    }
}
</code></pre>
<pre><code>$ javac ThrowTest.java
$ java ThrowTest
Exception in thread &quot;main&quot; java.lang.NullPointerException
    at ThrowTest.main(ThrowTest.java:8)
</code></pre>
<p><strong>throws 声明异常</strong><br>
throws 用于声明异常，表示该方法可能会抛出的异常。如果声明的异常中包括 checked 异常（受检异常），那么调用者必须捕获处理该异常或者使用 throws 继续向上抛出。throws 位于方法体前，多个异常之间使用 , 分割</p>
<p>修改 /home/project/ 下的 ThrowsTest.java</p>
<pre><code>import java.io.FileInputStream;
import java.io.FileNotFoundException;

public class ThrowsTest {

    public static void main(String[] args) throws FileNotFoundException {
        //由方法的调用者捕获异常或者继续向上抛出
        throwsTest();

    }

    public static void throwsTest() throws FileNotFoundException {
        new FileInputStream(&quot;/home/project/shiyanlou.file&quot;);
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac ThrowsTest.java
$ java ThrowsTest
Exception in thread &quot;main&quot; java.io.FileNotFoundException: /home/project/shiyanlou.file (系统找不到指定的路径。)
    at java.io.FileInputStream.open0(Native Method)
    at java.io.FileInputStream.open(FileInputStream.java:195)
    at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:138)
    at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:93)
    at ThrowsTest.throwsTest(ThrowsTest.java:13)
    at ThrowsTest.main(ThrowsTest.java:8)
</code></pre>
<h2 id="捕获异常">捕获异常</h2>
<p>通常抛出异常后，还需要将异常捕获。使用 try 和 catch 语句块来捕获异常，有时候还会用到 finally</p>
<p>对于上述三个关键词所构成的语句块，try 语句块是必不可少的，catch 和 finally 语句块可以根据情况选择其一或者全选。你可以把可能发生错误或出现问题的语句放到 try 语句块中，将异常发生后要执行的语句放到 catch 语句块中，而 finally 语句块里面放置的语句，不管异常是否发生，它们都会被执行</p>
<p>你可能想说，那我把所有有关的代码都放到 try 语句块中不就妥当了吗？可是你需要知道，捕获异常对于系统而言，其开销非常大，所以应尽量减少该语句块中放置的语句</p>
<p><strong>捕获异常编程实例</strong><br>
在 /home/project/ 目录下新建 CatchException.java</p>
<pre><code>public class CatchException {
    public static void main(String[] args) {
        try {
            // 下面定义了一个try语句块

            System.out.println(&quot;I am try block.&quot;);

            Class&lt;?&gt; tempClass = Class.forName(&quot;&quot;);
            // 声明一个空的Class对象用于引发“类未发现异常”
            System.out.println(&quot;Bye! Try block.&quot;);

        } catch (ClassNotFoundException e) {
            // 下面定义了一个catch语句块
            System.out.println(&quot;I am catch block.&quot;);

            e.printStackTrace();
            //printStackTrace()的意义在于在命令行打印异常信息在程序中出错的位置及原因

            System.out.println(&quot;Goodbye! Catch block.&quot;);

        } finally {
            // 下面定义了一个finally语句块
            System.out.println(&quot;I am finally block.&quot;);
        }
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac CatchException.java
$ java CatchException
I am try block.
I am catch block.
java.lang.ClassNotFoundException:
        at java.lang.Class.forName0(Native Method)
        at java.lang.Class.forName(Unknown Source)
        at CatchException.main(CatchException.java:8)
Goodbye! Catch block.
I am finally block.
</code></pre>
<p>请你结合这些输出语句在源代码中的位置，再来体会一下三个语句块的作用</p>
<p><strong>捕获多个异常</strong><br>
在一段代码中，可能会由于各种原因抛出多种不同的异常，而对于不同的异常，我们希望用不同的方式来处理它们，而不是笼统的使用同一个方式处理，在这种情况下，可以使用异常匹配，当匹配到对应的异常后，后面的异常将不再进行匹配</p>
<p><strong>编程实例</strong><br>
在 /home/project/ 目录下新建源代码文件 MultipleCapturesDemo.java</p>
<pre><code>import java.io.FileInputStream;
import java.io.FileNotFoundException;

public class MultipleCapturesDemo {
    public static void main(String[] args) {
        try {
            new FileInputStream(&quot;&quot;);
        } catch (FileNotFoundException e) {
            System.out.println(&quot;IO 异常&quot;);
        } catch (Exception e) {
            System.out.println(&quot;发生异常&quot;);
        }
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac MultipleCapturesDemo.java
$ java MultipleCapturesDemo
IO 异常
</code></pre>
<p>在处理异常时，并不要求抛出的异常同 catch 所声明的异常完全匹配，子类的对象也可以匹配父类的处理程序。比如异常 A 继承于异常 B，那么在处理多个异常时，一定要将异常 A 放在异常 B 之前捕获，如果将异常 B 放在异常 A 之前，那么将永远匹配到异常 B，异常 A 将永远不可能执行，并且编译器将会报错</p>
<h2 id="自定义异常">自定义异常</h2>
<p>尽管 Java SE 的 API 已经为我们提供了数十种异常类，然而在实际的开发过程中，你仍然可能遇到未知的异常情况。此时，你就需要对异常类进行自定义</p>
<p>自定义一个异常类非常简单，只需要让它继承 Exception 或其子类就行。在自定义异常类的时候，建议同时提供无参构造方法和带字符串参数的构造方法，后者可以为你在调试时提供更加详细的信息</p>
<p>百闻不如一见，下面我们尝试自定义一个算术异常类<br>
在 /home/project/ 目录下创建一个 MyAriException 类<br>
主要的代码如下</p>
<pre><code>// MyAriException.java
public class MyAriException extends ArithmeticException {
    //自定义异常类，该类继承自ArithmeticException

    public MyAriException() {

    }
    //实现默认的无参构造方法

    public MyAriException(String msg) {
        super(msg);
    }
    //实现可以自定义输出信息的构造方法，将待输出信息作为参数传入即可
}
</code></pre>
<p>添加一个 ExceptionTest 类作为测试用，在该类的 main() 方法中，可以尝试使用 throw 抛出自定义的异常</p>
<p>代码片段如下</p>
<pre><code>// ExceptionTest.java
import java.util.Arrays;

public class ExceptionTest {
    public static void main(String[] args) {
        int[] array = new int[5];
        //声明一个长度为5的数组

        Arrays.fill(array, 5);
        //将数组中的所有元素赋值为5

        for (int i = 4; i &gt; -1; i--) {
            //使用for循环逆序遍历整个数组，i每次递减

            if (i == 0) {
            // 如果i除以了0，就使用带异常信息的构造方法抛出异常

                throw new MyAriException(&quot;There is an exception occured.&quot;);
            }

            System.out.println(&quot;array[&quot; + i + &quot;] / &quot; + i + &quot; = &quot; + array[i] / i);
            // 如果i没有除以0，就输出此结果
        }
    }
}
</code></pre>
<p>检查一下代码，编译并运行，期待中的自定义错误信息就展现在控制台中了</p>
<pre><code>$ javac ExceptionTest.java MyAriException.java
$ java ExceptionTest
array[4] / 4 = 1
array[3] / 3 = 1
array[2] / 2 = 2
array[1] / 1 = 5
Exception in thread &quot;main&quot; MyAriException: There is an exception occured.
    at ExceptionTest.main(ExceptionTest.java:17)
</code></pre>
<h2 id="异常堆栈">异常堆栈</h2>
<p>当异常抛出后，我们可以通过异常堆栈追踪程序的运行轨迹，以便我们更好的 DEBUG</p>
<p><strong>编程实例</strong><br>
在 /home/project 目录下新建一个 ExceptionStackTrace.java</p>
<pre><code>public class ExceptionStackTrace {
    private static void method1() {
        method2();
    }

    private static void method2() {
        throw new NullPointerException();
    }
    public static void main(String[] args) {
        try {
            method1();
        } catch (Exception e) {
            //打印堆栈轨迹
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac ExceptionStackTrace.java
$ java ExceptionStackTrace
java.lang.NullPointerException
    at ExceptionStackTrace.method2(ExceptionStackTrace.java:7)
    at ExceptionStackTrace.method1(ExceptionStackTrace.java:3)
    at ExceptionStackTrace.main(ExceptionStackTrace.java:11)
</code></pre>
<p>通过上面的异常堆栈轨迹，在对比我们方法的调用过程，可以得出异常信息中首先打印的是距离抛出异常最近的语句，接着是调用该方法的方法，一直到最开始被调用的方法。从下往上看，就可以得出程序运行的轨迹</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础4-泛型和集合]]></title>
        <id>https://y-rui.github.io/post/java-ji-chu-4-fan-xing-he-ji-he/</id>
        <link href="https://y-rui.github.io/post/java-ji-chu-4-fan-xing-he-ji-he/">
        </link>
        <updated>2020-08-25T10:21:16.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>Java 使用集合来组织和管理对象，本节我们重点讲解泛型和集合。主要介绍 Collection、List、ArrayList、Map、HashMap、Set 和 HashSet、Collections、算法等内容</li>
</ul>
<h2 id="泛型">泛型</h2>
<ul>
<li>泛型即参数化类型，也就是说数据类型变成了一个可变的参数，在不使用泛型的情况下，参数的数据类型都是写死了的，使用泛型之后，可以根据程序的需要进行改变</li>
</ul>
<p>定义泛型的规则</p>
<ul>
<li>只能是引用类型，不能是简单数据类型</li>
<li>泛型参数可以有多个</li>
<li>可以用使用 extends 语句或者 super 语句 如 <code>&lt;T extends superClass&gt;</code> 表示类型的上界，T 只能是 superClass 或其子类， <code>&lt;K super childClass&gt;</code> 表示类型的下界，K 只能是 childClass 或其父类</li>
<li>可以是通配符类型，比如常见的 Class&lt;?&gt;。单独使用 ? 可以表示任意类型。也可以结合 extends 和 super 来进行限制</li>
</ul>
<p><strong>定义泛型类</strong><br>
接下来我们来定义一个泛型类，它有一个成员，成员的类型待定</p>
<p>在 /home/project/ 目录下新建一个类 TestDemo.java</p>
<pre><code>/*
使用T代表类型，无论何时都没有比这更具体的类型来区分它。如果有多个类型参数，我们可能使用字母表中T的临近的字母，比如S。
*/
class Test&lt;T&gt; {
    private T ob;

    /*
    定义泛型成员变量，定义完类型参数后，可以在定义位置之后的方法的任意地方使用类型参数，就像使用普通的类型一样。
    注意，父类定义的类型参数不能被子类继承。
    */

    //构造函数
    public Test(T ob) {
        this.ob = ob;
    }

    //getter 方法
    public T getOb() {
        return ob;
    }


    //setter 方法
    public void setOb(T ob) {
        this.ob = ob;
    }

    public void showType() {
        System.out.println(&quot;T的实际类型是: &quot; + ob.getClass().getName());
    }
}

public class TestDemo {
    public static void main(String[] args) {
        // 定义泛型类 Test 的一个Integer版本
        Test&lt;Integer&gt; intOb = new Test&lt;Integer&gt;(88);
        intOb.showType();
        int i = intOb.getOb();
        System.out.println(&quot;value= &quot; + i);
        System.out.println(&quot;----------------------------------&quot;);
        // 定义泛型类Test的一个String版本
        Test&lt;String&gt; strOb = new Test&lt;String&gt;(&quot;Hello Gen!&quot;);
        strOb.showType();
        String s = strOb.getOb();
        System.out.println(&quot;value= &quot; + s);
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac TestDemo.java
$ java TestDemo
T的实际类型是: java.lang.Integer
value= 88
----------------------------------
T的实际类型是: java.lang.String
value= Hello Gen!
</code></pre>
<p><strong>使用泛型方法</strong><br>
我们先来看一看代码</p>
<p>在 /home/project 目录下新建一个 Animal 类</p>
<pre><code>// Animal.java
public class Animal {
    public Animal(){
        System.out.println(&quot;我是动物&quot;);
    }
}
</code></pre>
<p>在 /home/project 目录下新建一个 Dog 类</p>
<pre><code>// Dog.java
public class Dog extends Animal {
    public Dog(){
        System.out.println(&quot;我是狗&quot;);
    }
}
</code></pre>
<p>在 /home/project 目录下新建一个 Test 类</p>
<pre><code>// Test.java
public class Test {

  /*
  注意：定义带类型参数的方法，其主要目的是为了表达多个参数以及返回值之间的关系。例如本例子中T和S的继承关系， 返回值的类型和第一个类型参数的值相同。
  */
    public&lt;T, S extends T&gt; T testDemo(T t, S s){
        System.out.println(&quot;我是 T 类型，我的类型是&quot; + t.getClass().getName());
        System.out.println(&quot;我是 S 类型，我的类型是&quot; + s.getClass().getName());
        return t;
    }

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        Test test = new Test();
        Dog d = new Dog();
        Animal a0 = new Animal();
        Animal a1  = test.testDemo(a0, d);
        System.out.println(&quot;我是对象 a1，我的类型是&quot; + a1.getClass().getName());
    }

}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac Test.java Dog.java Animal.java
$ java Test
我是动物
我是狗
我是动物
我是 T 类型，我的类型是Animal
我是 S 类型，我的类型是Dog
我是对象 a1，我的类型是Animal
</code></pre>
<p>上面的例子中我们对类型参数赋予了具体的类型，当然我们有时候也无法确定类型参数的类型，这个时候我们便可以使用通配符。如果仅仅是想实现多态，请优先使用通配符解决</p>
<p>修改 Test 类</p>
<pre><code>import java.util.List;
import java.util.ArrayList;

public class Test {

  // List&lt;?&gt; 表示接受一个元素为任意类型的列表 List。
    public void testDemo(List&lt;?&gt; s){
        for(Object obj:s){
            System.out.println(&quot;我的类型是&quot; + obj.getClass().getName());
        }
    }

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        Test test = new Test();
        Dog a0 = new Dog();
        Animal a1 = new Animal();
    // 声明一个接收元素类型是 Animal 的列表 List s。
    // 然后创建一个元素类型是 Animal 的 ArrayList 赋值给 s。
        List&lt;Animal&gt; s = new ArrayList&lt;Animal&gt;();
    // Dog a0 是 Animal 的子类，可以向上转型为 Animal 类型
        s.add(a0);
        s.add(a1);
        test.testDemo(s);
    }

}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac Test.java Dog.java Animal.java
$ java Test
我是动物
我是狗
我是动物
我的类型是Dog
我的类型是Animal
</code></pre>
<h2 id="collection">Collection</h2>
<p>集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。任何集合框架都包含三大内容：对外的接口、接口的实现和对集合运算的算法</p>
<p>下图是简化的集合框架关系图<br>
<img src="https://y-rui.github.io/post-images/1608290776565.png" alt="" loading="lazy"></p>
<p>因为集合框架中的很多类功能是相似的，所以我们用接口来规范类。Collection 接口是 Java 集合框架里的一个根接口。它也是 List、Set 和 Queue 接口的父接口。Collection 接口中定义了可用于操作 List、Set 和 Queue 的方法——增删改查</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>返回值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>add(E e)</code></td>
<td>boolean</td>
<td>向 collection 的尾部追加指定的元素（可选操作）</td>
</tr>
<tr>
<td><code>addAll(Collection&lt;? extend E&gt; c)</code></td>
<td>boolean</td>
<td>将指定 collection 中的所有元素都添加到此 collection 中（可选操作）</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>void</td>
<td>移除此 collection 中的所有元素（可选操作）</td>
</tr>
<tr>
<td><code>contains(Object o)</code></td>
<td>boolean</td>
<td>如果此 collection 包含指定的元素，则返回 true</td>
</tr>
<tr>
<td><code>containsAll(Collection&lt;?&gt; c)</code></td>
<td>boolean</td>
<td>如果此 collection 包含指定 collection 的所有元素，则返回 true</td>
</tr>
<tr>
<td><code>equals(Object o)</code></td>
<td>boolean</td>
<td>比较此 collection 与指定对象是否相等</td>
</tr>
<tr>
<td><code>hashCode()</code></td>
<td>int</td>
<td>返回此 collection 的哈希码值</td>
</tr>
<tr>
<td><code>isEmpty()</code></td>
<td>boolean</td>
<td>如果此 collection 不包含元素，则返回 true</td>
</tr>
<tr>
<td><code>iterator()</code></td>
<td>Iterator</td>
<td>返回在此 collection 的元素上进行迭代的迭代器</td>
</tr>
<tr>
<td><code>remove(Object o)</code></td>
<td>boolean</td>
<td>移除此 collection 中出现的首个指定元素（可选操作）</td>
</tr>
<tr>
<td><code>removeAll(Collection&lt;?&gt; c)</code></td>
<td>boolean</td>
<td>移除此 collection 中那些也包含在指定 collection 中的所有元素（可选操作）</td>
</tr>
<tr>
<td><code>retainAll(Collection&lt;?&gt; c)</code></td>
<td>boolean</td>
<td>仅保留此 collection 中那些也包含在指定 collection 的元素（可选操作）</td>
</tr>
<tr>
<td><code>size()</code></td>
<td>int</td>
<td>返回此 collection 中的元素数</td>
</tr>
<tr>
<td><code>toArray()</code></td>
<td>Object[]</td>
<td>返回包含此 collection 中所有元素的数组</td>
</tr>
<tr>
<td><code>toArray(T[] a)</code></td>
<td>T[]</td>
<td>返回包含此 collection 中所有元素的数组；返回数组的运行时类型与指定数组的运行时类型相同</td>
</tr>
</tbody>
</table>
<h2 id="list">List</h2>
<ul>
<li>List 是一个接口，不能实例化，需要一个具体类来实现实例化</li>
</ul>
<p>List 集合中的对象按照一定的顺序排放，里面的内容可以重复。 List 接口实现的类有：ArrayList（实现动态数组），Vector（实现动态数组），LinkedList（实现链表），Stack（实现堆栈）</p>
<p>List 在 Collection 基础上增加的方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>返回值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>add(int index, E element)</code></td>
<td>void</td>
<td>在列表的指定位置插入指定元素（可选操作）</td>
</tr>
<tr>
<td><code>addAll(int index, Collection&lt;? extends E&gt; c)</code></td>
<td>boolean</td>
<td>将指定 collection 中的所有元素都插入到列表中的指定位置（可选操作）</td>
</tr>
<tr>
<td><code>get(int index)</code></td>
<td>E</td>
<td>返回列表中指定位置的元素</td>
</tr>
<tr>
<td><code>indexOf(Object o)</code></td>
<td>int</td>
<td>返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1</td>
</tr>
<tr>
<td><code>lastIndexOf(Object o)</code></td>
<td>int</td>
<td>返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1</td>
</tr>
<tr>
<td><code>listIterator()</code></td>
<td>ListIterator</td>
<td>返回此列表元素的列表迭代器（按适当顺序）</td>
</tr>
<tr>
<td><code>listIterator(int index)</code></td>
<td>ListIterator</td>
<td>返回此列表元素的列表迭代器（按适当顺序），从列表的指定位置开始</td>
</tr>
<tr>
<td><code>remove(int index)</code></td>
<td>E</td>
<td>移除列表中指定位置的元素（可选操作）</td>
</tr>
<tr>
<td><code>set(int index, E element)</code></td>
<td>E</td>
<td>用指定元素替换列表中指定位置的元素（可选操作）</td>
</tr>
<tr>
<td><code>subList(int fromIndex, int toIndex)</code></td>
<td>List</td>
<td>返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的部分视图</td>
</tr>
</tbody>
</table>
<p><strong>ArrayList</strong></p>
<ul>
<li>ArrayList 类实现一个可增长的动态数组，位于 java.util.ArrayList。实现了 List 接口，它可以存储不同类型的对象（包括 null 在内），而数组则只能存放特定数据类型的值</li>
</ul>
<p>ArrayList 编程实例</p>
<ul>
<li>学校的教务系统会对学生进行统一的管理，每一个学生都会有一个学号和学生姓名，我们在维护整个系统的时候，大多数操作是对学生的添加、插入、删除、修改等操作</li>
</ul>
<p>先在 /home/project/ 创建一个学生类 Student.java</p>
<pre><code>/**
 * 学生类
 */
public class Student {
    public String id;
    public String name;
    public Student(String id, String name){
        this.id = id;
        this.name = name;
    }

    @Override
    public String toString() {
        return &quot;Student{&quot; +
                &quot;id='&quot; + id + '\'' +
                &quot;, name='&quot; + name + '\'' +
                '}';
    }
}
</code></pre>
<p>再在 /home/project/ 创建一个 ListTest.java，其中包含了一个学生列表，通过操作学生列表来管理学生</p>
<pre><code>import java.util.*;


public class ListTest {

    //集合后面的&lt;&gt;代表泛型的意思
    //泛型是规定了集合元素的类型
    /**
     * 用于存放学生的List
     */
    public List&lt;Student&gt; students;


    public ListTest() {
        this.students = new ArrayList&lt;Student&gt;();
    }

    /**
     * 用于往students中添加学生
     */
    public void testAdd() {
        // 创建一个学生对象，并通过调用add方法，添加到学生管理List中
        Student st1 = new Student(&quot;1&quot;, &quot;张三&quot;);
        students.add(st1);

        // 取出 List中的Student对象 索引为0 也就是第一个
        Student temp = students.get(0);
        System.out.println(&quot;添加了学生：&quot; + temp.id + &quot;:&quot; + temp.name);

        Student st2 = new Student(&quot;2&quot;, &quot;李四&quot;);
        //添加到list中，插入到索引为0的位置，也就是第一个
        students.add(0, st2);
        Student temp2 = students.get(0);
        System.out.println(&quot;添加了学生：&quot; + temp2.id + &quot;:&quot; + temp2.name);

        // 对象数组的形式添加
        Student[] student = {new Student(&quot;3&quot;, &quot;王五&quot;), new Student(&quot;4&quot;, &quot;马六&quot;)};

        // Arrays类包含用来操作数组（比如排序和搜索）的各种方法，asList() 方法用来返回一个受指定数组支持的固定大小的列表
        students.addAll(Arrays.asList(student));
        Student temp3 = students.get(2);
        Student temp4 = students.get(3);
        System.out.println(&quot;添加了学生：&quot; + temp3.id + &quot;:&quot; + temp3.name);
        System.out.println(&quot;添加了学生：&quot; + temp4.id + &quot;:&quot; + temp4.name);
        Student[] student2 = {new Student(&quot;5&quot;, &quot;周七&quot;), new Student(&quot;6&quot;, &quot;赵八&quot;)};
        students.addAll(2, Arrays.asList(student2));
        Student temp5 = students.get(2);
        Student temp6 = students.get(3);
        System.out.println(&quot;添加了学生：&quot; + temp5.id + &quot;:&quot; + temp5.name);
        System.out.println(&quot;添加了学生：&quot; + temp6.id + &quot;:&quot; + temp6.name);
    }


    /**
     * 取得List中的元素的方法
     */
    public void testGet() {
        int size = students.size();
        for (int i = 0; i &lt; size; i++) {
            Student st = students.get(i);
            System.out.println(&quot;学生：&quot; + st.id + &quot;:&quot; + st.name);

        }
    }


    /**
     * 通过迭代器来遍历
     * 迭代器的工作是遍历并选择序列中的对象，Java 中 Iterator 只能单向移动
     */
    public void testIterator() {
        // 通过集合的iterator方法，取得迭代器实例
        Iterator&lt;Student&gt; it = students.iterator();
        System.out.println(&quot;有如下学生（通过迭代器访问）：&quot;);
        while (it.hasNext()) {

            Student st = it.next();
            System.out.println(&quot;学生&quot; + st.id + &quot;:&quot; + st.name);
        }
    }

    /**
     * 通过for each 方法访问集合元素
     *
     */
    public void testForEach() {
        System.out.println(&quot;有如下学生（通过for each）：&quot;);
        for (Student obj : students) {
            Student st = obj;
            System.out.println(&quot;学生：&quot; + st.id + &quot;:&quot; + st.name);
        }
        //使用java8 Steam将学生排序后输出
        students.stream()//创建Stream
                //通过学生id排序
                .sorted(Comparator.comparing(x -&gt; x.id))
                //输出
                .forEach(System.out::println);
    }

    /**
     * 修改List中的元素
     *
     */
    public void testModify() {
        students.set(4, new Student(&quot;3&quot;, &quot;吴酒&quot;));
    }

    /**
     * 删除List中的元素
     *
     */
    public void testRemove() {
        Student st = students.get(4);
        System.out.println(&quot;我是学生：&quot; + st.id + &quot;:&quot; + st.name + &quot;，我即将被删除&quot;);
        students.remove(st);
        System.out.println(&quot;成功删除学生！&quot;);
        testForEach();
    }


    public static void main(String[] args) {
        ListTest lt = new ListTest();
        lt.testAdd();
        lt.testGet();
        lt.testIterator();
        lt.testModify();
        lt.testForEach();
        lt.testRemove();

    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac Student.java ListTest.java
$ java ListTest

添加了学生：1:张三
添加了学生：2:李四
添加了学生：3:王五
添加了学生：4:马六
添加了学生：5:周七
添加了学生：6:赵八
学生：2:李四
学生：1:张三
学生：5:周七
学生：6:赵八
学生：3:王五
学生：4:马六
有如下学生（通过迭代器访问）：
学生2:李四
学生1:张三
学生5:周七
学生6:赵八
学生3:王五
学生4:马六
有如下学生（通过for each）：
学生：2:李四
学生：1:张三
学生：5:周七
学生：6:赵八
学生：3:吴酒
学生：4:马六
Student{id='1', name='张三'}
Student{id='2', name='李四'}
Student{id='3', name='吴酒'}
Student{id='4', name='马六'}
Student{id='5', name='周七'}
Student{id='6', name='赵八'}
我是学生：3:吴酒，我即将被删除
成功删除学生！
有如下学生（通过for each）：
学生：2:李四
学生：1:张三
学生：5:周七
学生：6:赵八
学生：4:马六
Student{id='1', name='张三'}
Student{id='2', name='李四'}
Student{id='4', name='马六'}
Student{id='5', name='周七'}
Student{id='6', name='赵八'}
</code></pre>
<p>在上面的代码中，用到了 Arrays 类， Arrays 包含用来操作数组（比如排序和搜索）的各种方法，asList() 方法用来返回一个受指定数组支持的固定大小的列表</p>
<h2 id="map">Map</h2>
<ul>
<li>Map 接口也是一个非常重要的集合接口，用于存储键 / 值对。Map 中的元素都是成对出现的，键值对就像数组的索引与数组的内容的关系一样，将一个键映射到一个值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。我们可以通过键去找到相应的值</li>
</ul>
<p>value 可以存储任意类型的对象，我们可以根据 key 键快速查找 value。Map 中的键 / 值对以 Entry 类型的对象实例形式存在</p>
<p>看一看 Map 中的方法吧</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>返回值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>clear()</code></td>
<td>void</td>
<td>从此映射中移除所用映射关系（可选操作）</td>
</tr>
<tr>
<td><code>containsKey(Object key)</code></td>
<td>boolean</td>
<td>如果此映射包含指定键的映射关系，则返回 true</td>
</tr>
<tr>
<td><code>containsValue(Object value)</code></td>
<td>boolean</td>
<td>如果此映射将一个或多个键映射到指定值，则返回 true</td>
</tr>
<tr>
<td><code>entrySet()</code></td>
<td><code>Set&lt;Map.Entry&lt;K,V&gt;&gt;</code></td>
<td>返回此映射中包含的映射关系的 Set 视图</td>
</tr>
<tr>
<td><code>equals(Object o)</code></td>
<td>boolean</td>
<td>比较指定的对象与此映射是否相等</td>
</tr>
<tr>
<td><code>get(Object key)</code></td>
<td>V</td>
<td>返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null</td>
</tr>
<tr>
<td><code>hashCode()</code></td>
<td>int</td>
<td>返回此映射的哈希码值</td>
</tr>
<tr>
<td><code>isEmpty()</code></td>
<td>boolean</td>
<td>如果此映射未包含键 - 值映射关系，则返回 true</td>
</tr>
<tr>
<td><code>keySet()</code></td>
<td>Set</td>
<td>返回此映射中包含的键的 Set 视图</td>
</tr>
<tr>
<td><code>put(K key, V value)</code></td>
<td>V</td>
<td>将指定的值与此映射中的指定键关联（可选操作）</td>
</tr>
<tr>
<td><code>putAll(Map&lt;? extends K, ? extends V&gt; m)</code></td>
<td>void</td>
<td>从指定映射中将所有映射关系复制到此映射中（可选操作）</td>
</tr>
<tr>
<td><code>remove(Object key)</code></td>
<td>V</td>
<td>如果存在一个键的映射关系，则将其从此映射中移除（可选操作）</td>
</tr>
<tr>
<td><code>size</code></td>
<td>int</td>
<td>返回此映射中的键 - 值映射关系数</td>
</tr>
<tr>
<td><code>values()</code></td>
<td>Collection</td>
<td>返回此映射中包含的值的 Collection 视图</td>
</tr>
</tbody>
</table>
<p><strong>HashMap</strong></p>
<ul>
<li>HashMap 是基于哈希表的 Map 接口的一个重要实现类。HashMap 中的 Entry 对象是 无序 排列的，Key 值和 value 值都可以为 null，但是一个 HashMap 只能有一个 key 值为 null 的映射（key 值不可重复）</li>
</ul>
<p><strong>编程实例</strong><br>
在 /home/project/ 目录下创建一个 Course 类</p>
<pre><code>// Course.java
public class Course {
    public String id;
    public String name;
    public Course(String id, String name){
        this.id = id;
        this.name = name;
    }
}
</code></pre>
<p>在 /home/project/ 目录下创建一个 MapTest 类</p>
<pre><code>// MapTest.java
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Scanner;
import java.util.Set;

public class MapTest {

    /**
     * 用来承装课程类型对象
     */
    public Map&lt;String, Course&gt; courses;

    /**
     * 在构造器中初始化 courses 属性
     * @param args
     */
    public MapTest() {
        this.courses = new HashMap&lt;String, Course&gt;();
    }

    /**
     * 测试添加：输入课程 ID，判断是否被占用
     * 若未被占用，输入课程名称，创建新课程对象
     * 并且添加到 courses 中
     * @param args
     */
    public void testPut() {
        //创建一个 Scanner 对象，用来获取输入的课程 ID 和名称
        Scanner console = new Scanner(System.in);

        for(int i = 0; i &lt; 3; i++) {
            System.out.println(&quot;请输入课程 ID：&quot;);
            String ID = console.next();
            //判断该 ID 是否被占用
            Course cr = courses.get(ID);
            if(cr == null){
                //提示输入课程名称
                System.out.println(&quot;请输入课程名称：&quot;);
                String name = console.next();
                //创建新的课程对象
                Course newCourse = new Course(ID,name);
                //通过调用 courses 的 put 方法，添加 ID-课程映射
                courses.put(ID, newCourse);
                System.out.println(&quot;成功添加课程：&quot; + courses.get(ID).name);
            }
            else {
                System.out.println(&quot;该课程 ID 已被占用&quot;);
                continue;
            }
        }
    }

    /**
     * 测试 Map 的 keySet 方法
     * @param args
     */

    public void testKeySet() {
        //通过 keySet 方法，返回 Map 中的所有键的 Set 集合
        Set&lt;String&gt; keySet = courses.keySet();
        //遍历 keySet，取得每一个键，在调用 get 方法取得每个键对应的 value
        for(String crID: keySet) {
            Course cr = courses.get(crID);
            if(cr != null){
                System.out.println(&quot;课程：&quot; + cr.name);
            }
        }
    }

    /**
     * 测试删除 Map 中的映射
     * @param args
     */
    public void testRemove() {
        //获取从键盘输入的待删除课程 ID 字符串
        Scanner console = new Scanner(System.in);
        while(true){
            //提示输出待删除的课程 ID
            System.out.println(&quot;请输入要删除的课程 ID！&quot;);
            String ID = console.next();
            //判断该 ID 是否对应的课程对象
            Course cr = courses.get(ID);
            if(cr == null) {
                //提示输入的 ID 并不存在
                System.out.println(&quot;该 ID 不存在！&quot;);
                continue;
            }
            courses.remove(ID);
            System.out.println(&quot;成功删除课程&quot; + cr.name);
            break;
        }
    }

    /**
     * 通过 entrySet 方法来遍历 Map
     * @param args
     */
    public void testEntrySet() {
        //通过 entrySet 方法，返回 Map 中的所有键值对
        Set&lt;Entry&lt;String,Course&gt;&gt; entrySet = courses.entrySet();
        for(Entry&lt;String,Course&gt; entry: entrySet) {
            System.out.println(&quot;取得键：&quot; + entry.getKey());
            System.out.println(&quot;对应的值为：&quot; + entry.getValue().name);
        }
    }

    /**
     * 利用 put 方法修改Map 中的已有映射
     * @param args
     */
    public void testModify(){
        //提示输入要修改的课程 ID
        System.out.println(&quot;请输入要修改的课程 ID：&quot;);
        //创建一个 Scanner 对象，去获取从键盘上输入的课程 ID 字符串
        Scanner console = new Scanner(System.in);
        while(true) {
            //取得从键盘输入的课程 ID
            String crID = console.next();
            //从 courses 中查找该课程 ID 对应的对象
            Course course = courses.get(crID);
            if(course == null) {
                System.out.println(&quot;该 ID 不存在！请重新输入！&quot;);
                continue;
            }
            //提示当前对应的课程对象的名称
            System.out.println(&quot;当前该课程 ID，所对应的课程为：&quot; + course.name);
            //提示输入新的课程名称，来修改已有的映射
            System.out.println(&quot;请输入新的课程名称：&quot;);
            String name = console.next();
            Course newCourse = new Course(crID,name);
            courses.put(crID, newCourse);
            System.out.println(&quot;修改成功！&quot;);
            break;
        }
    }

    public static void main(String[] args) {
        MapTest mt = new MapTest();
        mt.testPut();
        mt.testKeySet();
        mt.testRemove();
        mt.testModify();
        mt.testEntrySet();

    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac Course.java MapTest.java
$ java MapTest
请输入课程 ID：
1
请输入课程名称：
语文
成功添加课程：语文
请输入课程 ID：
1
该课程 ID 已被占用
请输入课程 ID：
2
请输入课程名称：
数学
成功添加课程：数学
课程：语文
课程：数学
请输入要删除的课程 ID！
1
成功删除课程语文
请输入要修改的课程 ID：
2
当前该课程 ID，所对应的课程为：数学
请输入新的课程名称：
英语
修改成功！
取得键：2
对应的值为：英语
</code></pre>
<h2 id="set-和-hashset">Set 和 HashSet</h2>
<ul>
<li>Set 接口也是 Collection 接口的子接口，它有一个很重要也是很常用的实现类——HashSet，Set 是元素无序并且不包含重复元素的 collection（List 可以重复），被称为集</li>
<li>HashSet 由哈希表（实际上是一个 HashMap 实例）支持。它不保证 set 的迭代顺序；特别是它不保证该顺序恒久不变</li>
</ul>
<p><strong>编程实例</strong><br>
假设现在学生们要做项目，每个项目有一个组长，由组长来组织组员，我们便来实现项目组的管理吧</p>
<p>因为项目组的组长由一个老师担任，首先在 /home/project 目录下创建一个 PD 类</p>
<pre><code>// PD.java
import java.util.HashSet;
import java.util.Set;
/*
 * 项目组长类
 */
public class PD {

    public String id;
    public String name;
    //集合后面的&lt;&gt;代表泛型的意思
    //泛型是规定了集合元素的类型
    public Set&lt;Student&gt; students;
    public PD(String id, String name){
        this.id = id;
        this.name = name;
        this.students = new HashSet&lt;Student&gt;();
    }
}
</code></pre>
<p>在 /home/project/ 创建一个学生类 Student.java</p>
<pre><code>/**
 * 学生类
 */
 // Student.java
public class Student {
    public String id;
    public String name;
    public Student(String id, String name){
        this.id = id;
        this.name = name;
    }

    @Override
    public String toString() {
        return &quot;Student{&quot; +
                &quot;id='&quot; + id + '\'' +
                &quot;, name='&quot; + name + '\'' +
                '}';
    }
}
</code></pre>
<p>接下来我们便创建一个 SetTest 类，用来管理项目成员</p>
<pre><code>// SetTest.java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;

public class SetTest {

    public List&lt;Student&gt; students;

    public SetTest() {
        students = new ArrayList&lt;Student&gt;();
    }

    /*
     * 用于往students中添加学生
     */
    public void testAdd() {
        //创建一个学生对象，并通过调用add方法，添加到学生管理List中
        Student st1 = new Student(&quot;1&quot;, &quot;张三&quot;);
        students.add(st1);

        //添加到List中的类型均为Object，所以取出时还需要强转

        Student st2 = new Student(&quot;2&quot;,&quot;李四&quot;);
        students.add(st2);

        Student[] student = {new Student(&quot;3&quot;, &quot;王五&quot;),new Student(&quot;4&quot;, &quot;马六&quot;)};
        students.addAll(Arrays.asList(student));

        Student[] student2 = {new Student(&quot;5&quot;, &quot;周七&quot;),new Student(&quot;6&quot;, &quot;赵八&quot;)};
        students.addAll(Arrays.asList(student2));

    }

    /**
     * 通过for each 方法访问集合元素
     * @param args
     */
    public void testForEach() {
        System.out.println(&quot;有如下学生（通过for each）：&quot;);
        for(Object obj:students){
            Student st = (Student)obj;
            System.out.println(&quot;学生：&quot; + st.id + &quot;:&quot; + st.name);
        }
    }

    public static void main(String[] args){
        SetTest st = new SetTest();
        st.testAdd();
        st.testForEach();
        PD pd = new PD(&quot;1&quot;,&quot;张老师&quot;);
        System.out.println(&quot;请：&quot; + pd.name + &quot;选择小组成员！&quot;);
        //创建一个 Scanner 对象，用来接收从键盘输入的学生 ID
        Scanner console = new Scanner(System.in);

        for(int i = 0;i &lt; 3; i++){
            System.out.println(&quot;请输入学生 ID&quot;);
            String studentID = console.next();
            for(Student s:st.students){
                if(s.id.equals(studentID)){
                    pd.students.add(s);
                }
            }
        }
        st.testForEachForSer(pd);
        // 关闭 Scanner 对象
        console.close();
    }
    //打印输出，老师所选的学生！Set里遍历元素只能用foreach 和 iterator
    //不能使用 get() 方法，因为它是无序的，不能想 List 一样查询具体索引的元素
    public void testForEachForSer(PD pd){
        for(Student s: pd.students) {
        System.out.println(&quot;选择了学生：&quot; + s.id + &quot;:&quot; + s.name);
        }
    }

}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac PD.java SetTest.java Student.java
$ java SetTest
有如下学生（通过for each）：
学生：1:张三
学生：2:李四
学生：3:王五
学生：4:马六
学生：5:周七
学生：6:赵八
请：张老师选择小组成员！
请输入学生 ID
4
请输入学生 ID
5
请输入学生 ID
6
选择了学生：4:马六
选择了学生：5:周七
选择了学生：6:赵八
</code></pre>
<h2 id="collections">Collections</h2>
<ul>
<li>java.util.Collections 是一个工具类，他包含了大量对集合进行操作的静态方法</li>
</ul>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void sort(List list)</code></td>
<td>按自然升序排序</td>
</tr>
<tr>
<td><code>void sort(List list, Comparator c)</code></td>
<td>自定义排序规则排序</td>
</tr>
<tr>
<td><code>void shuffle(List list)</code></td>
<td>随机排序，用于打乱顺序</td>
</tr>
<tr>
<td><code>void reverse(List list)</code></td>
<td>反转，将列表元素顺序反转</td>
</tr>
<tr>
<td><code>void swap(List list, int i , int j)</code></td>
<td>交换处于索引 i 和 j 位置的元素</td>
</tr>
<tr>
<td><code>int binarySearch(List list, Object key)</code></td>
<td>二分查找，列表必须有序，返回找到的元素索引位置</td>
</tr>
<tr>
<td><code>int max(Collection coll)</code></td>
<td>查找最大值</td>
</tr>
<tr>
<td><code>int min(Collection coll)</code></td>
<td>查找最小值</td>
</tr>
<tr>
<td><code>void fill(List list, Object obj)</code></td>
<td>使用 obj 填充 list 所有元素</td>
</tr>
<tr>
<td><code>boolean replaceAll(List list, Object oldVal, Object newVal))</code></td>
<td>使用用 newVal 替换所有的 oldVal</td>
</tr>
<tr>
<td><code>&lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)</code></td>
<td>将 m 包装为线程安全的 Map</td>
</tr>
<tr>
<td><code>List synchronizedList(List list)</code></td>
<td>将 list 包装为线程安全的 List</td>
</tr>
</tbody>
</table>
<p><strong>编程实例</strong><br>
在 /home/project 目录下创建 CollectionsDemo.java</p>
<pre><code>import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class CollectionsDemo {
    public static void main(String[] args) {
//        创建一个空List
        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
        //赋值
        list.add(3);
        list.add(5);
        list.add(7);
        list.add(9);
        list.add(12);
        System.out.print(&quot;初始顺序：&quot;);
        list.forEach(v -&gt; System.out.print(v + &quot;\t&quot;));


        //打乱顺序
        Collections.shuffle(list);
        System.out.print(&quot;\n打乱顺序：&quot;);
        list.forEach(v -&gt; System.out.print(v + &quot;\t&quot;));

        //反转
        Collections.reverse(list);
        System.out.print(&quot;\n反转集合：&quot;);
        list.forEach(v -&gt; System.out.print(v + &quot;\t&quot;));

        //第一个位和最后一位交换
        Collections.swap(list,0,list.size()-1);
        System.out.print(&quot;\n交换第一位和最后一位：&quot;);
        list.forEach(v -&gt; System.out.print(v + &quot;\t&quot;));

        //按自然升序排序
        Collections.sort(list);
        System.out.print(&quot;\nSort排序后：&quot;);
        list.forEach(v -&gt; System.out.print(v + &quot;\t&quot;));

        //二分查找 必须排序后
        System.out.print(&quot;\n二分查找数值7的位置：&quot;+Collections.binarySearch(list, 7));

        //返回线程安全的list
        List&lt;Integer&gt; synchronizedList = Collections.synchronizedList(list);
    }
}
</code></pre>
<pre><code>$ javac CollectionsDemo.java
$ java CollectionsDemo
初始顺序：3    5    7    9    12
打乱顺序：5    7    3    12    9
反转集合：9    12    3    7    5
交换第一位和最后一位：5    12    3    7    9
Sort排序后：3    5    7    9    12
二分查找数值7的位置：2
</code></pre>
<h2 id="算法">算法</h2>
<ul>
<li>算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令。算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，则执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用空间复杂度与时间复杂度来衡量 --- 维基百科</li>
</ul>
<p><strong>排序算法</strong><br>
有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法——插入排序法，插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为 O(n^2)。是稳定的排序方法。</p>
<p>插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。</p>
<p>插入排序的基本思想是：每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止</p>
<p>排序过程如下</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤 2 ~ 5，直至最后一个元素</li>
</ol>
<p>在 /home/project 目录下新建一个文件InsertSort.java</p>
<pre><code>import java.util.Arrays;

public class InsertSort {
    private static void insertSort(int[] arr) {
      int j; // 已排序列表下标
      int t; // 待排序元素
      for (int i = 1; i &lt; arr.length; i++) {
        if (arr[i] &lt; arr[i - 1]) {
          t = arr[i]; // 赋值给待排序元素
          for (j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; t; j--) {
            arr[j + 1] = arr[j]; // 从后往前遍历已排序列表，逐个和待排序元素比较，如果已排序元素较大，则将它后移
          }
          arr[j + 1] = t; // 将待排序元素插入到正确的位置
        }
      }
    }

    public static void main(String[] args) {
        int[] ints = {5, 3, 4, 1, 2};
        insertSort(ints);
        System.out.println(Arrays.toString(ints));
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac InsertSort.java
$ java InsertSort
[1, 2, 3, 4, 5]
</code></pre>
<p><strong>冒泡排序</strong></p>
<ul>
<li>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。 它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从 A 到 Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素已经排序完成。 这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”</li>
</ul>
<p>冒泡排序的运行过程如下</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数</li>
<li>针对所有的元素重复以上的步骤，除了最后一个</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</li>
</ol>
<p>在 /home/project 目录下新建一个文件 BubbleSort.java</p>
<pre><code>import java.util.Arrays;

public class BubbleSort {
    public static void sort(int[] arr) {
        for (int i = 0; i &lt; arr.length-1; i++) {
            for (int j = 0; j &lt; arr.length - i - 1; j++) {
                //如果当前元素比后一位元素大 交换位置
                if (arr[j] &gt; arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }

    public static void main(String[] args) {
        int[] ints = {5, 3, 4, 1, 2};
        sort(ints);
        System.out.println(Arrays.toString(ints));
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac BubbleSort.java
$ java BubbleSort
[1, 2, 3, 4, 5]
</code></pre>
<p><strong>归并排序</strong></p>
<ul>
<li>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并</li>
</ul>
<p>排序过程</p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤 3 直到某一指针到达序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ol>
<p><img src="https://y-rui.github.io/post-images/1608461210821.png" alt="" loading="lazy"><br>
在 /home/project 目录下新建一个文件 MergeSort.java</p>
<pre><code>import java.util.Arrays;

public class MergeSort {

    public static void mergeSort(int[] arrays, int left, int right) {
                // 如果数组还可以拆分
        if (left &lt; right) {
            //数组的中间位置
            int middle = (left + right) / 2;
            //拆分左边数组
            mergeSort(arrays, left, middle);
            //拆分右边数组
            mergeSort(arrays, middle + 1, right);
            //合并
            merge(arrays, left, middle, right);
        }
    }


    /**
     * 合并数组
     */
    public static void merge(int[] arr, int left, int middle, int right) {
        //申请合并空间 大小为两个已经排序序列之和
        int[] temp = new int[right - left + 1];
        //i 和 j为两个已经排好序的数组的起始位置
        int i = left;
        int j = middle + 1;
        int k = 0;
        //排序
        while (i &lt;= middle &amp;&amp; j &lt;= right) {
            //将比较小的数组放入合并空间
            if (arr[i] &lt; arr[j]) {
                temp[k++] = arr[i++];
            } else {
                temp[k++] = arr[j++];
            }
        }
        //将左边剩余元素写入合并空间
        while (i &lt;= middle) {
            temp[k++] = arr[i++];
        }
        //将右边剩余的元素写入合并空间
        while (j &lt;= right) {
            temp[k++] = arr[j++];
        }
        //将排序后的数组写回原来的数组
        for (int l = 0; l &lt; temp.length; l++) {
            arr[l + left] = temp[l];
        }

    }

    public static void main(String[] args) {
        int[] ints = {5, 3, 4, 1, 2};
        mergeSort(ints,0,ints.length-1);
        System.out.println(Arrays.toString(ints));
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac MergeSort.java
$ java MergeSort
[1, 2, 3, 4, 5]
</code></pre>
<p><strong>快速排序</strong></p>
<ul>
<li>快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），简称快排，也是一种排序算法。最早由东尼·霍尔提出。在平均状况下，排序 n 个项目要 O(nlogn) 次比较。在最坏状况下则需要 O(n^2) 次比较，但这种状况并不常见。事实上，快速排序 O(nlogn) 通常明显比其他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成</li>
</ul>
<p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）<br>
步骤为</p>
<ol>
<li>从数列中挑出一个元素，称为“基准”（pivot）</li>
<li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分割结束之后，该基准就处于数列的中间位置。这个称为分割（partition）操作</li>
<li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序</li>
</ol>
<p>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去</p>
<p>在 /home/project 目录下新建一个文件 QuickSort.java</p>
<pre><code>import java.util.Arrays;

public class QuickSort {
    public static void sort(int[] arr, int head, int tail) {
        if (head &gt;= tail || arr == null || arr.length &lt;= 1) {
            return;
        }
        //设置数组的起始位置 i 结束位置j 基准 pivot 为数组的中间
        int i = head, j = tail, pivot = arr[(head + tail) / 2];
        while (i &lt;= j) {
            //当数组小于基准 循环结束后 相当于i所处的位置的值为大于基准的元素
            while (arr[i] &lt; pivot) {
                ++i;
            }
            //当数组大于基准 循环结束后 相当于j所处的位置的值为小于于基准的元素
            while (arr[j] &gt; pivot) {
                --j;
            }
            //如果i&lt;j 那么则将交互i j对应位置的值
            if (i &lt; j) {
                int t = arr[i];
                arr[i] = arr[j];
                arr[j] = t;
                //将指针继续移动
                ++i;
                --j;
            } else if (i == j) {
//如果i=j 那么说明本次排序已经结束 将i++ 如果这里不使用i++ 那么后面的sort(arr,i,tail)将改为arr(arr,i+1,tail)
                ++i;
            }
        }
        //继续将数组分割
        sort(arr, head, j);
        sort(arr, i, tail);
    }

    public static void main(String[] args) {
        int[] ints = {5, 3, 4, 1, 2};
        sort(ints, 0, ints.length - 1);
        System.out.println(Arrays.toString(ints));
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac QuickSort.java
$ java QuickSort
[1, 2, 3, 4, 5]
</code></pre>
<h2 id="搜索算法">搜索算法</h2>
<p><strong>线性搜索</strong></p>
<ul>
<li>线性搜索或顺序搜索是一种寻找某一特定值的搜索算法，指按一定的顺序检查数组中每一个元素，直到找到所要寻找的特定值为止。是最简单的一种搜索算法</li>
</ul>
<p>在 /home/project 目录下新建一个文件 LinearSearch.java</p>
<pre><code>public class LinearSearch {
    public static void main(String[] args) {
        int[] ints = {5, 3, 4, 1, 2};
        System.out.println(search(ints, 4));
    }

    public static int search(int[] arr, int key) {
        //循环
        for (int i = 0; i &lt; arr.length; i++) {
            //比较是否等于key
            if (arr[i] == key) {
                return arr[i];
            }
        }
        //找不到就返回-1
        return -1;
    }
}
</code></pre>
<pre><code>$ javac LinearSearch.java
$ java LinearSearch
4
</code></pre>
<p><strong>二分查找</strong></p>
<ul>
<li>在计算机科学中，二分搜索（英语：binary search），也称折半搜索（英语：half-interval search）、对数搜索（英语：logarithmic search），是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半</li>
</ul>
<p>在 /home/project 目录下新建一个文件 BinarySearch.java</p>
<pre><code>public class BinarySearch {
    public static int search(int[] arr, int key) {
        int low = 0;
        int high = arr.length - 1;
        while (low &lt;= high) {
            int middle = (high + low) / 2;
            //如果相等 返回值
            if (key == arr[middle]) {
                return key;
            } else if (key &lt; arr[middle]) {
                //如果key小于中间值，那么改变high，值可能在左边部（比较小的部分）
                high = middle - 1;
            }else {
                //如果key大于中间值，那么改变low，值可能在右边部（比较大的部分）
                low = middle + 1;
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        int[] ints = {1, 2, 3, 4, 5};
        System.out.println(search(ints, 4));
    }
}
</code></pre>
<pre><code>$ javac BinarySearch.java
$ java BinarySearch
4
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python基础19-Flask 介绍]]></title>
        <id>https://y-rui.github.io/post/python-ji-chu-19-flask-jie-shao/</id>
        <link href="https://y-rui.github.io/post/python-ji-chu-19-flask-jie-shao/">
        </link>
        <updated>2020-08-24T07:43:59.000Z</updated>
        <content type="html"><![CDATA[<h2 id="基本概念">基本概念</h2>
<p><strong>什么是 Flask?</strong><br>
Flask 是一个 web 框架。也就是说 Flask 为你提供工具，库和技术来允许你构建一个 web 应用程序。这个 web 应用程序可以是一些 web 页面、博客、wiki、基于 web 的日历应用或商业网站。</p>
<p>Flask 属于微框架（<em>micro-framework</em>）这一类别，微架构通常是很小的不依赖于外部库的框架。这既有优点也有缺点，优点是框架很轻量，更新时依赖少，并且专注安全方面的 bug，缺点是，你不得不自己做更多的工作，或通过添加插件增加自己的依赖列表。Flask 的依赖如下：</p>
<ul>
<li>Werkzeug  一个 WSGI 工具包'</li>
<li>jinja2  模板引擎</li>
</ul>
<p>维基百科 WSGI 的介绍：</p>
<ul>
<li>Web 服务器网关接口（Python Web Server Gateway Interface，缩写为 WSGI）是为Python语言定义的Web 服务器和Web 应用程序或框架之间的一种简单而通用的接口。自从 WSGI 被开发出来以后，许多其它语言中也出现了类似接口。</li>
</ul>
<p><strong>什么是模板引擎？</strong><br>
你搭建过一个网站吗？你面对过保持网站风格一致的问题吗，你不得不写多次相同的文本吗？你有没有试图改变这种网站的风格？</p>
<p>如果你的网站只包含几个网页，改变网站风格会花费你一些时间，这确实可行。尽管如此，如果你有许多页面（比如在你商店里的售卖物品列表），这个任务便很艰巨。</p>
<p>使用模板你可以设置你的页面的基本布局，并提及哪个元素将发生变化。这种方式可以定义您的网页头部并在您的网站的所有页面使它保持一致，如果你需要改变网页头部，你只需要更新一个地方。</p>
<p>使用模板引擎创建/更新/维护你的应用会节约你很多时间。</p>
<h2 id="hello-world-应用">&quot;Hello World&quot; 应用</h2>
<p>我们将使用 flask 完成一个非常基础的应用。</p>
<p>安装 flask</p>
<pre><code>$ sudo pip3 install flask
</code></pre>
<p>创建项目结构</p>
<pre><code>$ cd /home/shiyanlou
$ mkdir -p hello_flask/{templates,static}
</code></pre>
<p>这是你的 web 应用的基本结构：</p>
<pre><code>$ tree hello_flask/
hello_flask
|-- static
`-- templates

2 directories, 0 files
</code></pre>
<p>templates 文件夹是存放模板的地方，static 文件夹存放 web 应用所需的静态文件（images, css, javascript）。</p>
<p>创建应用文件</p>
<pre><code>$ cd hello_flask
$ vim hello_flask.py
</code></pre>
<p>hello_flask.py 文件里编写如下代码：</p>
<pre><code>#!/usr/bin/env python3

import flask


# Create the application.
APP = flask.Flask(__name__)


@APP.route('/')
def index():
    &quot;&quot;&quot; 显示可在 '/' 访问的 index 页面
    &quot;&quot;&quot;
    return flask.render_template('index.html')


if __name__ == '__main__':
    APP.debug=True
    APP.run()
</code></pre>
<p>创建模板文件  index.html</p>
<pre><code>$ vim templates/index.html
</code></pre>
<p>index.html 文件内容如下：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;title&gt;Hello world!&lt;/title&gt;
    &lt;link
      type=&quot;text/css&quot;
      rel=&quot;stylesheet&quot;
      href=&quot;{{ url_for('static',
              filename='hello.css')}}&quot;
    /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    It works!
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>运行 flask 应用程序</p>
<pre><code>$ python3 hello_flask.py
</code></pre>
<p>访问 http://127.0.0.1:5000/，这应该只是显示黑字白底的 &quot;It works!&quot; 文本</p>
<h2 id="flask-中使用参数">Flask 中使用参数</h2>
<p>在本节中我们将要看到如何根据用户使用的  URL 返回网页。</p>
<p>为此我们更新 hello_flask.py 文件。</p>
<p>在 hello_flask.py 文件中添加以下条目</p>
<pre><code>@APP.route('/hello/&lt;name&gt;/')
def hello(name):
    &quot;&quot;&quot; Displays the page greats who ever comes to visit it.
    &quot;&quot;&quot;
    return flask.render_template('hello.html', name=name)
</code></pre>
<p>创建下面这个模板 hello.html</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;title&gt;Hello&lt;/title&gt;
    &lt;link
      type=&quot;text/css&quot;
      rel=&quot;stylesheet&quot;
      href=&quot;{{ url_for('static',
               filename='hello.css')}}&quot;
    /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    Hello {{name}}
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>运行 flask 应用</p>
<pre><code>$ python3 hello_flask.py
</code></pre>
<p>访问 http://127.0.0.1:5000/ ，这应该只是显示黑字白底的 &quot;It works!&quot; 文本。</p>
<p>访问http://127.0.0.1:5000/hello/you，这应该返回文本 &quot;Hello you&quot;</p>
<p>无论你在 URL 中 /hello/ 后填写的什么，都会出现在返回的网页中。</p>
<p>这是你第一次使用模板，我们在 hello_flask.py 中建立了 name 变量（参见 hello 函数的 return 行）。通过语法 <code>{{name}}</code>，name 变量之后在页面中显示其自身。</p>
<h2 id="额外工作">额外工作</h2>
<p>目前，对于每一个页面我们都创建了一个模板，其实这是不好的做法，我们应该做的是创建一个主模板并且在每个页面使用它。</p>
<p>创建模板文件 master.html。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;title&gt;{% block title %}{% endblock %} - Hello Flask!&lt;/title&gt;
    &lt;link
      type=&quot;text/css&quot;
      rel=&quot;stylesheet&quot;
      href=&quot;{{ url_for('static',
                        filename='hello.css')}}&quot;
    /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    {% block body %}{% endblock %}
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>调整模板 index.html。</p>
<pre><code>{% extends &quot;master.html&quot; %} {% block title %}Home{% endblock %} {% block body %}
It works! {% endblock %}
</code></pre>
<p>正如你所看到的，在 master.html 模板中我们定义了两部分，名为 title 和 body 的 blocks。</p>
<p>在模板 index.html 中，我们声明这个模板扩展自 master.html 模板，然后我们定义了内容来放在这两个部分中（blocks）。在第一个 block title 中，我们放置了 Home 单词，在第二个 block body 中我们定义了我们想要在页面的 body 中有的东西。</p>
<ul>
<li>作为练习，更改其他模板 hello.html，同样要使用 master.html。</li>
<li>在 hello 页面添加首页链接。</li>
</ul>
<p>调整模板 hello.html，添加到首页的链接。</p>
<pre><code>&lt;a href=&quot;{{ url_for('index') }}&quot;&gt;&lt;button&gt;Home&lt;/button&gt;&lt;/a&gt;
</code></pre>
<ul>
<li>作为你的任务，在首页添加到 hello 页面的链接。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python基础18-项目结构]]></title>
        <id>https://y-rui.github.io/post/python-ji-chu-18-xiang-mu-jie-gou/</id>
        <link href="https://y-rui.github.io/post/python-ji-chu-18-xiang-mu-jie-gou/">
        </link>
        <updated>2020-08-24T07:15:53.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>本实验阐述了一个完整的 Python 项目结构，你可以使用什么样的目录布局以及怎样发布软件到网络上</li>
</ul>
<h2 id="创建-python-项目">创建 Python 项目</h2>
<p>我们的实验项目名为 <code>_factorial_</code>，放到 /home/shiyanlou/factorial 目录</p>
<pre><code>$ cd /home/shiyanlou
$ mkdir factorial
$ cd factorial/
</code></pre>
<p>我们给将要创建的 Python 模块取名为 <code>myfact_</code>，因此我们下一步创建 <code>_myfact</code> 目录</p>
<pre><code>$ mkdir myfact
$ cd myfact/
</code></pre>
<p>主代码将在 fact.py 文件里面</p>
<pre><code>&quot;myfact module&quot;

def factorial(num):
    &quot;&quot;&quot;
    返回给定数字的阶乘值

    :arg num: 我们将计算其阶乘的整数值

    :return: 阶乘值，若传递的参数为负数，则为 -1
    &quot;&quot;&quot;
    if num &gt;= 0:
        if num == 0:
            return 1
        return num * factorial(num -1)
    else:
        return -1
</code></pre>
<p>我们还有模块的 <code>__init__.py</code> 文件，内容如下</p>
<pre><code>from fact import factorial
__all__ = [factorial, ]
</code></pre>
<p>我们还在 factorial 目录下添加了一个  README.rst  文件</p>
<p><strong>MANIFEST.in</strong><br>
现在我们要写一个 /home/shiyanlou/factorial/MANIFEST.in 文件，它用来在使用 sdist 命令的时候找出将成为项目源代码压缩包一部分的所有文件</p>
<pre><code>include *.py
include README.rst
</code></pre>
<p>如果你想要排除某些文件，你可以在这个文件中使用 exclude 语句</p>
<p><strong>安装 python-setuptools 包</strong><br>
我们使用 <em>virtualenv</em>（这里不示范步骤）</p>
<pre><code>$ sudo pip3 install setuptools
</code></pre>
<p><strong>setup.py</strong><br>
最终我们需要写一个 /home/shiyanlou/factorial/setup.py，用来创建源代码压缩包或安装软件</p>
<pre><code>#!/usr/bin/env python3
&quot;&quot;&quot;Factorial project&quot;&quot;&quot;
from setuptools import find_packages, setup

setup(name = 'factorial',  # 注意这里的name不要使用factorial相关的名字，因为会重复，需要另外取一个不会与其他人重复的名字
    version = '0.1',
    description = &quot;Factorial module.&quot;,
    long_description = &quot;A test module for our book.&quot;,
    platforms = [&quot;Linux&quot;],
    author=&quot;ShiYanLou&quot;,
    author_email=&quot;support@shiyanlou.com&quot;,
    url=&quot;/courses/596&quot;,
    license = &quot;MIT&quot;,
    packages=find_packages()
    )
</code></pre>
<ul>
<li>name 是项目名称，version 是发布版本，description 和 long_description_ 分别是项目介绍，项目长描述。platforms 是此模块的支持平台列表。<code>_find_packages()</code> 是一个能在你源目录下找到所有模块的特殊函数</li>
</ul>
<p><strong>setup.py 用例</strong><br>
要创建一个源文件发布版本，执行以下命令</p>
<pre><code>$ python3 setup.py sdist
</code></pre>
<p>执行完毕会返回类似下面的信息</p>
<pre><code>running sdist
running egg_info
creating factorial.egg-info
writing factorial.egg-info/PKG-INFO
writing top-level names to factorial.egg-info/top_level.txt
writing dependency_links to factorial.egg-info/dependency_links.txt
writing manifest file 'factorial.egg-info/SOURCES.txt'
reading manifest file 'factorial.egg-info/SOURCES.txt'
reading manifest template 'MANIFEST.in'
writing manifest file 'factorial.egg-info/SOURCES.txt'
running check
creating factorial-0.1
creating factorial-0.1/factorial.egg-info
creating factorial-0.1/myfact
making hard links in factorial-0.1...
hard linking MANIFEST.in -&gt; factorial-0.1
hard linking README.rst -&gt; factorial-0.1
hard linking setup.py -&gt; factorial-0.1
hard linking factorial.egg-info/PKG-INFO -&gt; factorial-0.1/factorial.egg-info
hard linking factorial.egg-info/SOURCES.txt -&gt; factorial-0.1/factorial.egg-info
hard linking factorial.egg-info/dependency_links.txt -&gt; factorial-0.1/factorial.egg-info
hard linking factorial.egg-info/top_level.txt -&gt; factorial-0.1/factorial.egg-info
hard linking myfact/__init__.py -&gt; factorial-0.1/myfact
hard linking myfact/fact.py -&gt; factorial-0.1/myfact
Writing factorial-0.1/setup.cfg
creating dist
Creating tar archive
removing 'factorial-0.1' (and everything under it)
</code></pre>
<p>我们能在 dist 目录下看到一个 tar 压缩包</p>
<pre><code>$ ls dist/
factorial-0.1.tar.gz
</code></pre>
<p>记住尝试安装代码时使用 virtualenv</p>
<p>执行下面的命令从源代码安装</p>
<pre><code>$ sudo python3 setup.py install
</code></pre>
<h2 id="python-package-index-pypi">Python Package Index (PyPI)</h2>
<ul>
<li>你还记得我们经常使用的 pip 命令吗？有没有想过这些包是从哪里来的？答案是 <em>PyPI</em>。这是 Python 的软件包管理系统</li>
</ul>
<p>为了实验，我们会使用 PyPI 的测试服务器  https://testpypi.python.org/pypi</p>
<p><strong>创建账号</strong><br>
首先在这个链接注册账号。你会收到带有链接的邮件，点击这个链接确认你的注册</p>
<p>创建 ~/.pypirc 文件，存放你的账号详细信息，其内容格式如下</p>
<pre><code>[distutils]
index-servers = pypi
    testpypi

[pypi]
repository: https://upload.pypi.org/legacy/
username: &lt;username&gt;
password: &lt;password&gt;

[testpypi]
repository:https://test.pypi.org/legacy/
username: &lt;username&gt;
password: &lt;password&gt;
</code></pre>
<p>替换  <code>&lt;username&gt;</code> 和  <code>&lt;password&gt;</code> 为您新创建的帐户的详细信息。在这里，由于我们是到 testpypi的网页上去注册账号，即将相应的服务上传到 testpypi，所以在这里，你只需修改<code>[testpypi]</code>的用户名和密码</p>
<p>记得在 <code>setup.py</code> 中更改项目的名称为其它的名字来测试下面的指令，在接下来的命令中我将项目名称修改为 factorial2，为了不重复，大家需要自行修改至其它名称（不要使用 factorial 和 factorial2，因为已经被使用了）</p>
<p><strong>上传到 TestPyPI 服务</strong><br>
下一步我们会将我们的项目到 TestPyPI 服务。这通过 twine 命令完成</p>
<p>我们也会使用 -r 把它指向测试服务器</p>
<pre><code>$ sudo pip3 install twine
$ twine upload dist/* -r testpypi
</code></pre>
<p>执行完毕会返回类似下面的信息</p>
<pre><code>Uploading distributions to https://test.pypi.org/legacy/
Uploading factorial2-0.1.tar.gz
</code></pre>
<p>现在如果你浏览这个<a href="https://test.pypi.org/project/factorial2/0.1/">页面</a>，你会发现你的项目已经准备好被别人使用了</p>
<p>在这里你也可以使用下面的命令上传到 PyPI 服务上，但这里需要注意，在 <code>~/.pypirc</code> 里面，你需要到 https://pypi.python.org页面，按照上面的步骤去注册一个账号，然后到~/.pypirc 的 <code>[pypi]</code> 下填写相应的用户名和密码。testpypi 和 pypi 的账号密码并不通用</p>
<pre><code>$ twine upload dist/* -r pypi
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python基础17-测试]]></title>
        <id>https://y-rui.github.io/post/python-ji-chu-17-ce-shi/</id>
        <link href="https://y-rui.github.io/post/python-ji-chu-17-ce-shi/">
        </link>
        <updated>2020-08-23T06:59:40.000Z</updated>
        <content type="html"><![CDATA[<h2 id="单元测试">单元测试</h2>
<ul>
<li>在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法</li>
</ul>
<p><strong>单元测试模块</strong><br>
在 Python 里我们有 unittest 这个模块来帮助我们进行单元测试</p>
<p><strong>阶乘计算程序</strong></p>
<pre><code>import sys

def fact(n):
    &quot;&quot;&quot;
    阶乘函数

    :arg n: 数字
    :returns: n 的阶乘

    &quot;&quot;&quot;
    if n == 0:
        return 1
    return n * fact(n -1)

def div(n):
    &quot;&quot;&quot;
    只是做除法
    &quot;&quot;&quot;
    res = 10 / n
    return res


def main(n):
    res = fact(n)
    print(res)

if __name__ == '__main__':
    if len(sys.argv) &gt; 1:
        main(int(sys.argv[1]))
</code></pre>
<h2 id="第一个测试用例">第一个测试用例</h2>
<p>测试哪个函数？</p>
<p>正如你所看到的， fact(n) 这个函数执行所有的计算，所以我们至少应该测试这个函数</p>
<p>编辑 /home/shiyanlou/factorial_test.py 文件，代码如下</p>
<pre><code>import unittest
from factorial import fact

class TestFactorial(unittest.TestCase):
    &quot;&quot;&quot;
    我们的基本测试类
    &quot;&quot;&quot;

    def test_fact(self):
        &quot;&quot;&quot;
        实际测试
        任何以 `test_` 开头的方法都被视作测试用例
        &quot;&quot;&quot;
        res = fact(5)
        self.assertEqual(res, 120)


if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>运行测试</p>
<pre><code>$ python3 factorial_test.py
.
----------------------------------------------------------------------
Ran 1 test in 0.000s

OK
</code></pre>
<p><strong>说明</strong><br>
我们首先导入了 unittest 模块，然后测试我们需要测试的函数</p>
<p>测试用例是通过子类化  <code>unittest.TestCase</code>  创建的</p>
<p>现在我们打开测试文件并且把 120 更改为 121，然后看看会发生什么</p>
<h2 id="各类-assert-语句">各类 assert 语句</h2>
<table>
<thead>
<tr>
<th>Method</th>
<th>Checks that</th>
<th>New in</th>
</tr>
</thead>
<tbody>
<tr>
<td>assertEqual(a, b)</td>
<td>a == b</td>
<td></td>
</tr>
<tr>
<td>assertNotEqual(a, b)</td>
<td>a != b</td>
<td></td>
</tr>
<tr>
<td>assertTrue(x)</td>
<td>bool(x) is True</td>
<td></td>
</tr>
<tr>
<td>assertFalse(x)</td>
<td>bool(x) is False</td>
<td></td>
</tr>
<tr>
<td>assertIs(a, b)</td>
<td>a is b</td>
<td>2.7</td>
</tr>
<tr>
<td>assertIsNot(a, b)</td>
<td>a is not b</td>
<td>2.7</td>
</tr>
<tr>
<td>assertIsNone(x)</td>
<td>x is None</td>
<td>2.7</td>
</tr>
<tr>
<td>assertIsNotNone(x)</td>
<td>x is not None</td>
<td>2.7</td>
</tr>
<tr>
<td>assertIn(a, b)</td>
<td>a in b</td>
<td>2.7</td>
</tr>
<tr>
<td>assertNotIn(a, b)</td>
<td>a not in b</td>
<td>2.7</td>
</tr>
<tr>
<td>assertIsInstance(a, b)</td>
<td>isinstance(a, b)</td>
<td>2.7</td>
</tr>
<tr>
<td>assertNotIsInstance(a, b)</td>
<td>not isinstance(a, b))</td>
<td>2.7</td>
</tr>
</tbody>
</table>
<h2 id="异常测试">异常测试</h2>
<p>如果我们在 factorial.py 中调用 div(0)，我们能看到异常被抛出</p>
<p>我们也能测试这些异常，就像这样</p>
<pre><code>self.assertRaises(ZeroDivisionError, div, 0)
</code></pre>
<p>完整代码</p>
<pre><code>import unittest
from factorial import fact, div

class TestFactorial(unittest.TestCase):
    &quot;&quot;&quot;
    我们的基本测试类
    &quot;&quot;&quot;

    def test_fact(self):
        &quot;&quot;&quot;
        实际测试
        任何以 `test_` 开头的方法都被视作测试用例
        &quot;&quot;&quot;
        res = fact(5)
        self.assertEqual(res, 120)

    def test_error(self):
        &quot;&quot;&quot;
        测试由运行时错误引发的异常
        &quot;&quot;&quot;
        self.assertRaises(ZeroDivisionError, div, 0)



if __name__ == '__main__':
    unittest.main()
</code></pre>
<h2 id="mounttabpy">mounttab.py</h2>
<p>mounttab.py 中只有一个 mount_details() 函数，函数分析并打印挂载详细信息</p>
<pre><code>import os


def mount_details():
    &quot;&quot;&quot;
    打印挂载详细信息
    &quot;&quot;&quot;
    if os.path.exists('/proc/mounts'):
        fd = open('/proc/mounts')
        for line in fd:
            line = line.strip()
            words = line.split()
            print('{} on {} type {}'.format(words[0],words[1],words[2]), end=' ')
            if len(words) &gt; 5:
                print('({})'.format(' '.join(words[3:-2])))
            else:
                print()
        fd.close()


if __name__ == '__main__':
    mount_details()
</code></pre>
<p><strong>重构 mounttab.py</strong><br>
现在我们在 mounttab2.py 中重构了上面的代码并且有一个我们能容易的测试的新函数 parse_mounts()</p>
<pre><code>import os

def parse_mounts():
    &quot;&quot;&quot;
    分析 /proc/mounts 并 返回元祖的列表
    &quot;&quot;&quot;
    result = []
    if os.path.exists('/proc/mounts'):
        fd = open('/proc/mounts')
        for line in fd:
            line = line.strip()
            words = line.split()
            if len(words) &gt; 5:
                res = (words[0],words[1],words[2],'({})'.format(' '.join(words[3:-2])))
            else:
               res = (words[0],words[1],words[2])
            result.append(res)
        fd.close()
    return result

def mount_details():
    &quot;&quot;&quot;
    打印挂载详细信息
    &quot;&quot;&quot;
    result = parse_mounts()
    for line in result:
        if len(line) == 4:
            print('{} on {} type {} {}'.format(*line))
        else:
            print('{} on {} type {}'.format(*line))


if __name__ == '__main__':
    mount_details()
</code></pre>
<p>同样我们测试代码，编写 mounttest.py 文件</p>
<pre><code>#!/usr/bin/env python
import unittest
from mounttab2 import parse_mounts

class TestMount(unittest.TestCase):
    &quot;&quot;&quot;
    我们的基本测试类
    &quot;&quot;&quot;

    def test_parsemount(self):
        &quot;&quot;&quot;
        实际测试
        任何以 `test_` 开头的方法都被视作测试用例
        &quot;&quot;&quot;
        result = parse_mounts()
        self.assertIsInstance(result, list)
        self.assertIsInstance(result[0], tuple)

    def test_rootext4(self):
        &quot;&quot;&quot;
        测试找出根文件系统
        &quot;&quot;&quot;
        result = parse_mounts()
        for line in result:
            if line[1] == '/' and line[2] != 'rootfs':
                self.assertEqual(line[2], 'ext4')


if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>运行程序</p>
<pre><code>$ python3 mounttest.py
..
----------------------------------------------------------------------
Ran 2 tests in 0.001s

OK
</code></pre>
<h2 id="测试覆盖率">测试覆盖率</h2>
<p>测试覆盖率是找到代码库未经测试的部分的简单方法。它并不会告诉你的测试好不好</p>
<p>在 Python 中我们已经有了一个不错的覆盖率工具来帮助我们。你可以在实验楼环境中安装它</p>
<pre><code>$ sudo pip3 install coverage
</code></pre>
<p><strong>覆盖率示例</strong></p>
<pre><code>$ coverage3 run mounttest.py
..
----------------------------------------------------------------------
Ran 2 tests in 0.013s

OK
$ coverage3 report -m
Name           Stmts   Miss  Cover   Missing
--------------------------------------------
mounttab2.py      22      7    68%   16, 25-30, 34
mounttest.py      14      0   100%
--------------------------------------------
TOTAL             36      7    81%
</code></pre>
<p>我们还可以使用下面的命令以 HTML 文件的形式输出覆盖率结果，然后在浏览器中查看它</p>
<pre><code>$ coverage3 html
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python基础16-Virtualenv]]></title>
        <id>https://y-rui.github.io/post/python-ji-chu-16-virtualenv/</id>
        <link href="https://y-rui.github.io/post/python-ji-chu-16-virtualenv/">
        </link>
        <updated>2020-08-22T06:56:06.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>虚拟的 Python 环境（简称 venv） 是一个能帮助你在本地目录安装不同版本的 Python 模块的 Python 环境，你可以不再需要在你系统中安装所有东西就能开发并测试你的代码</li>
</ul>
<h2 id="安装-virtualenv">安装 virtualenv</h2>
<p>首先安装 pip3，打开 xfce 终端输入下面的命令</p>
<pre><code>$ sudo apt-get update
$ sudo apt-get install python3-pip
</code></pre>
<p>用如下命令安装 virtualenv</p>
<pre><code>$ sudo pip3 install virtualenv
</code></pre>
<h2 id="用法">用法</h2>
<p>我们会创建一个叫做 virtual 的目录，在里面我们会有两个不同的虚拟环境</p>
<pre><code>$ cd /home/shiyanlou
$ mkdir virtual
</code></pre>
<p>下面的命令创建一个叫做 virt1 的环境</p>
<pre><code>$ cd virtual
$ virtualenv virt1
</code></pre>
<p>现在我们激活这个 virt1 环境</p>
<pre><code>$ source virt1/bin/activate
(virt1)shiyanlou：~/$
</code></pre>
<p>提示符的第一部分是当前虚拟环境的名字，当你有多个环境的时候它会帮助你识别你在哪个环境里面</p>
<p>现在我们将安装 redis 这个 Python 模块</p>
<pre><code>(virt1)$ sudo pip3 install redis
</code></pre>
<p>使用 deactivate 命令关闭虚拟环境</p>
<pre><code>(virt1)$ deactivate
$
</code></pre>
<p>现在我们将创建另一个虚拟环境 virt2，我们会在里面同样安装 redis 模块，但版本是 2.8 的旧版本</p>
<pre><code>$ virtualenv virt2
$ source virt2/bin/activate
(virt2)$ sudo pip3 install redis==2.8
</code></pre>
<p>这样可以为你的所有开发需求拥有许多不同的环境</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python基础15-迭代器、生成器、装饰器]]></title>
        <id>https://y-rui.github.io/post/python-ji-chu-15-die-dai-qi-sheng-cheng-qi-zhuang-shi-qi/</id>
        <link href="https://y-rui.github.io/post/python-ji-chu-15-die-dai-qi-sheng-cheng-qi-zhuang-shi-qi/">
        </link>
        <updated>2020-08-22T03:30:07.000Z</updated>
        <content type="html"><![CDATA[<h2 id="迭代器">迭代器</h2>
<p>Python 迭代器（<em>Iterators</em>）对象在遵守迭代器协议时需要支持如下两种方法</p>
<ul>
<li><code>__iter__()</code>，返回迭代器对象自身。这用在 for 和 in 语句中</li>
<li><code>__next__()</code>，返回迭代器的下一个值。如果没有下一个值可以返回，那么应该抛出 <code>StopIteration</code> 异常</li>
</ul>
<pre><code>class Counter(object):
    def __init__(self, low, high):
        self.current = low
        self.high = high

    def __iter__(self):
        return self

    def __next__(self):
        #返回下一个值直到当前值大于 high
        if self.current &gt; self.high:
            raise StopIteration
        else:
            self.current += 1
            return self.current - 1
</code></pre>
<p>现在我们能把这个迭代器用在我们的代码里</p>
<pre><code>&gt;&gt;&gt; c = Counter(5,10)
&gt;&gt;&gt; for i in c:
...   print(i, end=' ')
...
5 6 7 8 9 10
</code></pre>
<p>请记住迭代器只能被使用一次。这意味着迭代器一旦抛出 StopIteration，它会持续抛出相同的异常</p>
<pre><code>&gt;&gt;&gt; c = Counter(5,6)
&gt;&gt;&gt; next(c)
5
&gt;&gt;&gt; next(c)
6
&gt;&gt;&gt; next(c)
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
File &quot;&lt;stdin&gt;&quot;, line 11, in next
StopIteration
&gt;&gt;&gt; next(c)
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
File &quot;&lt;stdin&gt;&quot;, line 11, in next
StopIteration
</code></pre>
<p>我们已经看过在 for 循环中使用迭代器的例子了，下面的例子试图展示迭代器被隐藏的细节</p>
<pre><code>&gt;&gt;&gt; iterator = iter(c)
&gt;&gt;&gt; while True:
...     try:
...         x = iterator.__next__()
...         print(x, end=' ')
...     except StopIteration as e:
...         break
...
5 6 7 8 9 10
</code></pre>
<h2 id="生成器">生成器</h2>
<p>在这一节我们学习有关 Python 生成器（<em>Generators</em>）的知识。生成器是更简单的创建迭代器的方法，这通过在函数中使用 yield 关键字完成</p>
<pre><code>&gt;&gt;&gt; def my_generator():
...     print(&quot;Inside my generator&quot;)
...     yield 'a'
...     yield 'b'
...     yield 'c'
...
&gt;&gt;&gt; my_generator()
&lt;generator object my_generator at 0x7fbcfa0a6aa0&gt;
</code></pre>
<p>在上面的例子中我们使用 yield 语句创建了一个简单的生成器。我们能在 for 循环中使用它，就像我们使用任何其它迭代器一样</p>
<pre><code>&gt;&gt;&gt; for char in my_generator():
...     print(char)
...
Inside my generator
a
b
c
</code></pre>
<p>在下一个例子里，我们会使用一个生成器函数完成与 Counter 类相同的功能，并且把它用在 for 循环中</p>
<pre><code>&gt;&gt;&gt; def counter_generator(low, high):
...     while low &lt;= high:
...        yield low
...        low += 1
...
&gt;&gt;&gt; for i in counter_generator(5,10):
...     print(i, end=' ')
...
5 6 7 8 9 10
</code></pre>
<p>在 While 循环中，每当执行到 yield 语句时，返回变量 low 的值并且生成器状态转为挂起。在下一次调用生成器时，生成器从之前冻结的地方恢复执行然后变量 low 的值增一。生成器继续 while 循环并且再次来到 yield 语句...</p>
<p>当你调用生成器函数时它返回一个生成器对象。如果你把这个对象传入 <code>dir()</code> 函数，你会在返回的结果中找到 <code>__iter__</code> 和 <code>__next__</code> 两个方法名</p>
<p>我们通常使用生成器进行惰性求值。这样使用生成器是处理大数据的好方法。如果你不想在内存中加载所有数据，你可以使用生成器，一次只传递给你一部分数据</p>
<p><code>os.path.walk()</code> 函数是最典型的这样的例子，它使用一个回调函数和当前的 <code>os.walk</code> 生成器。使用生成器实现节约内存</p>
<p>我们可以使用生成器产生无限多的值。以下是一个这样的例子</p>
<pre><code>&gt;&gt;&gt; def infinite_generator(start=0):
...     while True:
...         yield start
...         start += 1
...
&gt;&gt;&gt; for num in infinite_generator(4):
...     print(num, end=' ')
...     if num &gt; 20:
...         break
...
4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21
</code></pre>
<p>如果我们回到 <code>my_generator()</code> 这个例子，我们会发现生成器的一个特点：它们是不可重复使用的</p>
<pre><code>&gt;&gt;&gt; g = my_generator()
&gt;&gt;&gt; for c in g:
...     print(c)
...
Inside my generator
a
b
c
&gt;&gt;&gt; for c in g:
...     print(c)
...
</code></pre>
<p>我们无法创建一个可重复使用的生成器，但可以创建一个对象，将它的 <code>__iter__</code> 方法调用得到一个生成器，举例如下</p>
<pre><code>&gt;&gt;&gt; class Counter(object):
...     def __init__(self, low, high):
...         self.low = low
...         self.high = high
...     def __iter__(self):
...          counter = self.low
...          while self.high &gt;= counter:
...              yield counter
...              counter += 1
...
&gt;&gt;&gt; gobj = Counter(5, 10)
&gt;&gt;&gt; for num in gobj:
...     print(num, end=' ')
...
5 6 7 8 9 10
&gt;&gt;&gt; for num in gobj:
...     print(num, end=' ')
...
5 6 7 8 9 10
</code></pre>
<p>上面的 gobj 并不是生成器或迭代器，因为它不具有 <code>__next__</code> 方法，只是一个可迭代对象，生成器是一定不能重复循环的。而 <code>gobj.__iter__()</code> 是一个生成器，因为它是一个带有 yield 关键字的函数</p>
<p>如果想要使类的实例变成迭代器，可以用 <code>__iter__</code> + <code>__next__</code> 方法实现</p>
<pre><code>&gt;&gt;&gt; from collections import Iterator
&gt;&gt;&gt; class Test():
...:     def __init__(self, a, b):
...:         self.a = a
...:         self.b = b
...:     def __iter__(self):
...:         return self
...:     def __next__(self):
...:         self.a += 1
...:         if self.a &gt; self.b:
...:             raise StopIteration()
...:         return self.a
...:

&gt;&gt;&gt; test = Test(5, 10)

&gt;&gt;&gt; isinstance(test, Iterator)
True
</code></pre>
<h2 id="生成器表达式">生成器表达式</h2>
<ul>
<li>在这一节我们学习生成器表达式（<em>Generator expressions</em>），生成器表达式是列表推导式和生成器的一个高性能，内存使用效率高的推广</li>
</ul>
<p>举个例子，我们尝试对 1 到 9 的所有数字进行平方求和</p>
<pre><code>&gt;&gt;&gt; sum([x*x for x in range(1,10)])
</code></pre>
<p>这个例子实际上首先在内存中创建了一个平方数值的列表，然后遍历这个列表，最终求和后释放内存。你能理解一个大列表的内存占用情况是怎样的</p>
<p>我们可以通过使用生成器表达式来节省内存使用</p>
<pre><code>&gt;&gt;&gt; sum(x*x for x in range(1,10))
</code></pre>
<p>生成器表达式的语法要求其总是直接在在一对括号内，并且不能在两边有逗号。这基本上意味着下面这些例子都是有效的生成器表达式用法示例</p>
<pre><code>&gt;&gt;&gt; sum(x*x for x in range(1,10))
285
&gt;&gt;&gt; g = (x*x for x in range(1,10))
&gt;&gt;&gt; g
&lt;generator object &lt;genexpr&gt; at 0x7fc559516b90&gt;
</code></pre>
<p>我们可以把生成器和生成器表达式联系起来，在下面的例子中我们会读取文件 '/var/log/cron' 并且查看任意指定任务（例中我们搜索 'anacron' ）是否成功运行</p>
<p>我们可以用 shell 命令 <code>tail -f /etc/crontab |grep anacron</code> 完成同样的事（按 Ctrl + C 终止命令执行）</p>
<pre><code>&gt;&gt;&gt; jobtext = 'anacron'
&gt;&gt;&gt; all = (line for line in open('/etc/crontab', 'r') )
&gt;&gt;&gt; job = ( line for line in all if line.find(jobtext) != -1)
&gt;&gt;&gt; text = next(job)
&gt;&gt;&gt; text
'25 6\t* * *\troot\ttest -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.daily )\n'
&gt;&gt;&gt; text = next(job)
&gt;&gt;&gt; text
'47 6\t* * 7\troot\ttest -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.weekly )\n'
&gt;&gt;&gt; text = next(job)
&gt;&gt;&gt; text
'52 6\t1 * *\troot\ttest -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.monthly )\n'
</code></pre>
<p>你可以写一个 for 循环遍历所有行</p>
<h2 id="闭包">闭包</h2>
<ul>
<li>闭包（<em>Closures</em>）是由另外一个函数返回的函数。我们使用闭包去除重复代码。在下面的例子中我们创建了一个简单的闭包来对数字求和</li>
</ul>
<pre><code>&gt;&gt;&gt; def add_number(num):
...     def adder(number):
...         #adder 是一个闭包
...         return num + number
...     return adder
...
&gt;&gt;&gt; a_10 = add_number(10)
&gt;&gt;&gt; a_10(21)
31
&gt;&gt;&gt; a_10(34)
44
&gt;&gt;&gt; a_5 = add_number(5)
&gt;&gt;&gt; a_5(3)
8
</code></pre>
<p>adder 是一个闭包，把一个给定的数字与预定义的一个数字相加</p>
<h2 id="装饰器">装饰器</h2>
<ul>
<li>装饰器（<em>Decorators</em>）用来给一些对象动态的添加一些新的行为，我们使用过的闭包也是这样的</li>
</ul>
<p>我们会创建一个简单的示例，将在函数执行前后打印一些语句</p>
<pre><code>&gt;&gt;&gt; def my_decorator(func):
...     def wrapper(*args, **kwargs):
...         print(&quot;Before call&quot;)
...         result = func(*args, **kwargs)
...         print(&quot;After call&quot;)
...         return result
...     return wrapper
...
&gt;&gt;&gt; @my_decorator
... def add(a, b):
...     #我们的求和函数
...     return a + b
...
&gt;&gt;&gt; add(1, 3)
Before call
After call
4
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python基础14-PEP8 代码风格指南]]></title>
        <id>https://y-rui.github.io/post/python-ji-chu-14-pep8-dai-ma-feng-ge-zhi-nan/</id>
        <link href="https://y-rui.github.io/post/python-ji-chu-14-pep8-dai-ma-feng-ge-zhi-nan/">
        </link>
        <updated>2020-08-21T03:12:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="代码排版">代码排版</h2>
<p><strong>缩进</strong></p>
<p>每层缩进使用 4 个空格</p>
<p>续行要么与圆括号、中括号、花括号这样的被包裹元素保持垂直对齐，要么放在 Python 的隐线（注：应该是相对于 def 的内部块）内部，或者使用悬挂缩进。使用悬挂缩进的注意事项：第一行不能有参数，用进一步的缩进来把其他行区分开</p>
<p>好的示例</p>
<pre><code># Aligned with opening delimiter.
foo = long_function_name(var_one, var_two,
                         var_three, var_four)

# More indentation included to distinguish this from the rest.
def long_function_name(
        var_one, var_two, var_three,
        var_four):
    print(var_one)

# Hanging indents should add a level.
foo = long_function_name(
    var_one, var_two,
    var_three, var_four)
</code></pre>
<p>不好的示例</p>
<pre><code># Arguments on first line forbidden when not using vertical alignment.
foo = long_function_name(var_one, var_two,
    var_three, var_four)

# Further indentation required as indentation is not distinguishable.
def long_function_name(
    var_one, var_two, var_three,
    var_four):
    print(var_one)
</code></pre>
<p>空格规则是可选的</p>
<pre><code># Hanging indents *may* be indented to other than 4 spaces.
foo = long_function_name(
  var_one, var_two,
  var_three, var_four)
</code></pre>
<p>当 if 语句的条件部分足够长，需要将它写入到多个行，值得注意的是两个连在一起的关键字（i.e. if），添加一个空格，给后续的多行条件添加一个左括号形成自然地 4 空格缩进。如果和嵌套在 if 语句内的缩进代码块产生了视觉冲突，也应该被自然缩进 4 个空格。这份增强建议书对于怎样（或是否）把条件行和 if 语句的缩进块在视觉上区分开来是没有明确规定的。可接受的情况包括，但不限于</p>
<pre><code># No extra indentation.
if (this_is_one_thing and
    that_is_another_thing):
    do_something()

# Add a comment, which will provide some distinction in editors
# supporting syntax highlighting.
if (this_is_one_thing and
    that_is_another_thing):
    # Since both conditions are true, we can frobnicate.
    do_something()

# Add some extra indentation on the conditional continuation line.
if (this_is_one_thing
        and that_is_another_thing):
    do_something()
</code></pre>
<p>在多行结构中的右圆括号、右中括号、右大括号应该放在最后一行的第一个非空白字符的正下方，如下所示</p>
<pre><code>my_list = [
    1, 2, 3,
    4, 5, 6,
    ]
result = some_function_that_takes_arguments(
    'a', 'b', 'c',
    'd', 'e', 'f',
    )
</code></pre>
<p>或者放在多行结构的起始行的第一个字符正下方，如下</p>
<pre><code>my_list = [
    1, 2, 3,
    4, 5, 6,
]
result = some_function_that_takes_arguments(
    'a', 'b', 'c',
    'd', 'e', 'f',
)
</code></pre>
<p><strong>制表符还是空格</strong><br>
空格是首选的缩进方法</p>
<p>制表符（Tab）应该被用在那些以前就使用了制表符缩进的地方</p>
<p>Python 3 不允许混合使用制表符和空格来缩进代码</p>
<p>混合使用制表符和空格缩进的 Python 2 代码应该改为只使用空格</p>
<p>当使用-t选项来调用 Python 2 的命令行解释器的时候，会对混合使用制表符和空格的代码发出警告。当使用-tt选项的时候，这些警告会变成错误。这些选项是强烈推荐的！</p>
<p><strong>每行最大长度</strong><br>
限制每行的最大长度为 79 个字符</p>
<p>对于那些约束很少的文本结构（文档字符串或注释）的长块，应该限制每行长度为 72 个字符</p>
<p>限制编辑窗口的宽度使并排打开两个窗口成为可能，使用通过代码审查工具时，也能很好的通过相邻列展现不同代码版本</p>
<p>一些工具的默认换行设置打乱了代码的可视结构，使其更难理解。限制编辑器窗口宽为 80 来避免自动换行，即使有些编辑工具在换行的时候会在最后一列放一个标识符。一些基于 Web 的工具可能根本就不提供动态换行</p>
<p>一些团队更倾向于长的代码行。对于达成了一致意见来统一代码的团队而言，把行提升到 80~100 的长度是可接受的（实际最大长度为 99 个字符），注释和文档字符串的长度还是建议在 72 个字符内</p>
<p>Python 标准库是非常专业的，限制最大代码长度为 79 个字符（注释和文档字符串最大长度为 72 个字符）</p>
<p>首选的换行方式是在括号（小中大）内隐式换行（非续行符 \）。长行应该在括号表达式的包裹下换行。这比反斜杠作为续行符更好</p>
<p>反斜杠有时仍然适用。例如，多个很长的 with 语句不能使用隐式续行，因此反斜杠是可接受的</p>
<pre><code>with open('/path/to/some/file/you/want/to/read') as file_1, \
     open('/path/to/some/file/being/written', 'w') as file_2:
    file_2.write(file_1.read())
</code></pre>
<p>（见前面关于 多行 if 语句 的讨论来进一步思考这种多行 with 语句该如何缩进。）</p>
<p>另一种使用反斜杠续行的案例是 assert 语句</p>
<p>确保续行的缩进是恰到好处的。遇到二元操作符，首选的断行位置是操作符的后面而不是前面。这有一些例子</p>
<pre><code>class Rectangle(Blob):

    def __init__(self, width, height,
                 color='black', emphasis=None, highlight=0):
        if (width == 0 and height == 0 and
                color == 'red' and emphasis == 'strong' or
                highlight &gt; 100):
            raise ValueError(&quot;sorry, you lose&quot;)
        if width == 0 and height == 0 and (color == 'red' or
                                           emphasis is None):
            raise ValueError(&quot;I don't think so -- values are %s, %s&quot; %
                             (width, height))
        Blob.__init__(self, width, height,
                      color, emphasis, highlight)
</code></pre>
<p><strong>空行</strong><br>
顶级函数和类定义上下使用两个空行分隔</p>
<p>类内的方法定义使用一个空行分隔</p>
<p>可以使用额外的空行（有节制的）来分隔相关联的函数组。在一系列相关联的单行代码中空行可以省略（e.g. 一组虚拟的实现）</p>
<p>在函数中使用空白行（有节制的）来表明逻辑部分</p>
<p>Python 接受使用换页符（i.e. Ctrl+L）作为空格；许多工具都把 Ctrl+L 作为分页符，因此你可以用它们把你的文件中相似的章节分页。注意，一些编辑器和基于 Web 的代码查看工具可能不把 Ctrl+L 看做分页符，而是在这个位置放一个其它的符号</p>
<p><strong>源文件编码</strong><br>
在核心 Python 发布版中的代码应该总是使用UTF-8编码（或者在 Python 2 中使用 ASCII）</p>
<p>使用 ASCII(Python 2)或 UTF-8(Python 3)的文件不需要有编码声明（注：它们是默认的）</p>
<p>在标准库中，非缺省的编码应该仅仅用于测试目的，或者注释或文档字符串中的作者名包含非 ASCII 码字符；否则，优先使用 \x、\u、\U 或者 \N 来转义字符串中的非 ASCII 数据</p>
<p>对于 Python 3.0 和之后的版本，以下是有关标准库的政策（见PEP 3131）：所有 Python 标准库中的标识符必须使用只含 ASCII 的标识，并且只要可行，应该使用英语单词（在多数情况下，缩略语和技术术语哪个不是英语）。此外，字符串和注释也必须是 ASCII。仅有的例外是：(a)测试用例测试非 ASCII 特性时，(b)作者名。作者的名字不是基于拉丁字母的必须提供他们名字的拉丁字母音译</p>
<p><strong>导入包</strong><br>
import 不同的模块应该独立一行，如</p>
<pre><code>import os
import sys
</code></pre>
<p>这样也是可行的</p>
<pre><code>from subprocess import Popen, PIPE
</code></pre>
<p>import 语句应该总是放在文件的顶部，在模块注释和文档字符串之下，在模块全局变量和常量之前</p>
<p>import 语句分组顺序如下</p>
<ol>
<li>导入标准库模块</li>
<li>导入相关第三方库模块</li>
<li>导入当前应用程序 / 库模块</li>
</ol>
<p>每组之间应该用空行分开<br>
然后用 <code>__all__</code> 声明本文件内的模块</p>
<p>绝对导入是推荐的，它们通常是更可读的，并且在错误的包系统配置（如一个目录包含一个以 os.path 结尾的包）下有良好的行为倾向（至少有更清晰的错误消息）</p>
<pre><code>import mypkg.sibling
from mypkg import sibling
from mypkg.sibling import example
</code></pre>
<p>当然，相对于绝对导入，相对导入是个可选替代，特别是处理复杂的包结构时，绝对导入会有不必要的冗余</p>
<pre><code>from . import sibling
from .sibling import example
</code></pre>
<p>标准库代码应该避免复杂的包结构，并且永远使用绝对导入</p>
<p>应该从不使用隐式的相对导入，而且在 Python 3 中已经被移除</p>
<p>从一个包含类的模块导入类时，这样写通常是可行的</p>
<pre><code>from myclass import MyClass
from foo.bar.yourclass import YourClass
</code></pre>
<p>如果上面的方式会本地导致命名冲突，则这样写</p>
<pre><code>import myclass
import foo.bar.yourclass
</code></pre>
<p>以 <code>myclass.MyClass</code> 和 <code>foo.bar.yourclass.YourClass</code> 这样的方式使用</p>
<ul>
<li>应该避免通配符导入（from import *），这会使名称空间里存在的名称变得不清晰，迷惑读者和自动化工具。这里有一个可辩护的通配符导入用例，，重新发布一个内部接口作为公共 API 的一部分（例如，使用纯 Python 实现一个可选的加速器模块的接口，但并不能预知这些定义会被覆盖）</li>
<li>当以这种方式重新发布名称时，下面关于公共和内部接口的指南仍然适用</li>
</ul>
<h2 id="字符串引号">字符串引号</h2>
<p>在 Python 里面，单引号字符串和双引号字符串是相同的。这份指南对这个不会有所建议。选择一种方式并坚持使用。一个字符串同时包含单引号和双引号字符时，用另外一种来包裹字符串，而不是使用反斜杠来转义，以提高可读性</p>
<p>对于三引号字符串，总是使用双引号字符来保持与文档字符串约定的一致性</p>
<h2 id="表达式和语句中的空格">表达式和语句中的空格</h2>
<h2 id="注释">注释</h2>
<h2 id="版本注记">版本注记</h2>
<h2 id="命名约定">命名约定</h2>
<h2 id="公共和内部接口">公共和内部接口</h2>
<h2 id="程序编写建议">程序编写建议</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python挑战4-类和Collection模块]]></title>
        <id>https://y-rui.github.io/post/python-tiao-zhan-4-lei-he-collection-mo-kuai/</id>
        <link href="https://y-rui.github.io/post/python-tiao-zhan-4-lei-he-collection-mo-kuai/">
        </link>
        <updated>2020-08-20T03:05:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="介绍">介绍</h2>
<p>本次挑战中我们将通过改写之前实验中的 student_teacher.py 程序实现更加丰富的功能</p>
<h2 id="目标">目标</h2>
<p>改写 我们在 类 这个实验中 继承 部分的 student_teacher.py 脚本，实现以下功能</p>
<ul>
<li>在 Person() 类中增添函数 get_grade()</li>
<li>对于教师类，get_grade() 函数可以自动统计出老师班上学生的得分情况并按照频率的高低以 A: X, B: X, C: X, D: X 的形式打印出来</li>
<li>对于学生类，get_grade() 函数则可以以 Pass: X, Fail: X 来统计自己的成绩情况（A,B,C 为 Pass, 如果得了 D 就认为是 Fail）</li>
</ul>
<p>student_teacher.py 文件可以通过在 Xfce 终端中输入如下代码来获取</p>
<pre><code>cd /home/shiyanlou/Code
wget https://labfile.oss.aliyuncs.com/courses/790/student_teacher.py
</code></pre>
<p>要求:</p>
<ol>
<li>请把最终的student_teacher.py 代码文件放在 /home/shiyanlou/Code/ 路径下</li>
<li>根据命令行中的第一个参数 teacher 或者 student 来判断最终输出的格式</li>
<li>命令行中第二个输入的参数是需要统计的字符串</li>
</ol>
<p>执行实例</p>
<pre><code>$ python3 student_teacher.py teacher ABCCBADDAA
A: 4, D: 2, B: 2, C: 2
$ python3 student_teacher.py student ABCCBADDAA
Pass: 8, Fail: 2
</code></pre>
<h2 id="参考代码">参考代码</h2>
<pre><code>#!/usr/bin/env python3
import sys
from collections import Counter

class Person(object):
    &quot;&quot;&quot;
    返回具有给定名称的 Person 对象
    &quot;&quot;&quot;

    def __init__(self, name):
        self.name = name

    def get_details(self):
        &quot;&quot;&quot;
        返回包含人名的字符串
        &quot;&quot;&quot;
        return self.name

    def get_grade(self):
        return 0


class Student(Person):
    &quot;&quot;&quot;
    返回 Student 对象，采用 name, branch, year 3 个参数
    &quot;&quot;&quot;

    def __init__(self, name, branch, year,grade):
        Person.__init__(self, name)
        self.branch = branch
        self.year = year
        self.grade = grade

    def get_details(self):
        &quot;&quot;&quot;
        返回包含学生具体信息的字符串
        &quot;&quot;&quot;
        return &quot;{} studies {} and is in {} year.&quot;.format(self.name, self.branch, self.year)

    def get_grade(self):

        common = Counter(self.grade).most_common(4)
        n1 = 0
        n2 = 0
        for item in common:
            if item[0] != 'D':
                n1 += item[1]
            else:
                n2 += item[1]
        print(&quot;Pass: {}, Fail: {}&quot;.format(n1,n2))

class Teacher(Person):
    &quot;&quot;&quot;
    返回 Teacher 对象，采用字符串列表作为参数
    &quot;&quot;&quot;
    def __init__(self, name, papers, grade):
        Person.__init__(self, name)
        self.papers = papers
        self.grade = grade

    def get_details(self):
        return &quot;{} teaches {}&quot;.format(self.name, ','.join(self.papers))

    def get_grade(self):
        s = []
        common = Counter(self.grade).most_common(4)
        for i,j in common:
            s.append(&quot;{}: {}&quot;.format(i,j))
        print(', '.join(s))

person1 = Person('Sachin')
if sys.argv[1] == &quot;student&quot;:
    student1 = Student('Kushal', 'CSE', 2005, sys.argv[2])
    student1.get_grade()
else:
    teacher1 = Teacher('Prashad', ['C', 'C++'], sys.argv[2])
    teacher1.get_grade()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python基础13-Collections 模块]]></title>
        <id>https://y-rui.github.io/post/python-ji-chu-13-collections-mo-kuai/</id>
        <link href="https://y-rui.github.io/post/python-ji-chu-13-collections-mo-kuai/">
        </link>
        <updated>2020-08-19T02:57:27.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>collections 是 Python 内建的一个集合模块，提供了许多有用的集合类</li>
</ul>
<h2 id="counter">Counter</h2>
<p>在这个实验我们会学习 Collections 模块。这个模块实现了一些很好的数据结构，它们能帮助你解决各种实际问题</p>
<pre><code>&gt;&gt;&gt; import collections
</code></pre>
<ul>
<li><code>Counter</code> 是一个有助于 <em>hashable</em> 对象计数的 dict 子类。它是一个无序的集合，其中 hashable 对象的元素存储为字典的键，它们的计数存储为字典的值，计数可以为任意整数，包括零和负数</li>
<li>我们可以这样查看 <code>Counter</code> 的帮助信息，事实上这些信息来源于 Counter 的文档字符串<code>(collections.Counter.__doc__)</code></li>
</ul>
<pre><code>&gt;&gt;&gt; help(Collections.Counter)
</code></pre>
<p>下面我们来看一个例子，例子中我们查看 Python 的 LICENSE 文件中某些单词出现的次数</p>
<pre><code>&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; import re
&gt;&gt;&gt; path = '/usr/lib/python3.5/LICENSE.txt'
&gt;&gt;&gt; words = re.findall('\w+', open(path).read().lower())
&gt;&gt;&gt; Counter(words).most_common(10)
[('the', 80), ('or', 78), ('1', 66), ('of', 61), ('to', 50), ('and', 48), ('python', 46), ('in', 38), ('license', 37), ('any', 37)]
</code></pre>
<p>Counter 对象有一个叫做 elements() 的方法，其返回的序列中，依照计数重复元素相同次数，元素顺序是无序的</p>
<pre><code>&gt;&gt;&gt; c = Counter(a=4, b=2, c=0, d=-2)
&gt;&gt;&gt; list(c.elements())
['b','b','a', 'a', 'a', 'a']
</code></pre>
<p>most_common() 方法返回最常见的元素及其计数，顺序为最常见到最少</p>
<pre><code>&gt;&gt;&gt; Counter('abracadabra').most_common(3)
[('a', 5), ('r', 2), ('b', 2)]
</code></pre>
<h2 id="defaultdict">defaultdict</h2>
<ul>
<li><code>defaultdict</code> 是内建 dict 类的子类，它覆写了一个方法并添加了一个可写的实例变量。其余功能与字典相同</li>
</ul>
<p><code>defaultdict()</code> 第一个参数提供了 <code>default_factory</code> 属性的初始值，默认值为 <code>None</code>，<br>
<code>default_factory</code> 属性值将作为字典的默认数据类型。所有剩余的参数与字典的构造方法相同，包括关键字参数</p>
<p>同样的功能使用 <code>defaultdict</code> 比使用 <code>dict.setdefault</code> 方法快</p>
<pre><code>&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]
&gt;&gt;&gt; d = defaultdict(list)
&gt;&gt;&gt; for k, v in s:
...     d[k].append(v)
...
&gt;&gt;&gt; d.items()
dict_items([('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])])
</code></pre>
<p>在例子中你可以看到，即使 defaultdict 对象不存在某个键，它会自动创建一个空列表</p>
<h2 id="namedtuple">namedtuple</h2>
<p>命名元组有助于对元组每个位置赋予意义，并且让我们的代码有更好的可读性和自文档性。你可以在任何使用元组地方使用命名元组。在例子中我们会创建一个命名元组以展示为元组每个位置保存信息</p>
<pre><code>&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])  # 定义命名元组
&gt;&gt;&gt; p = Point(10, y=20)  # 创建一个对象
&gt;&gt;&gt; p
Point(x=10, y=20)
&gt;&gt;&gt; p.x + p.y
30
&gt;&gt;&gt; p[0] + p[1]  # 像普通元组那样访问元素
30
&gt;&gt;&gt; x, y = p     # 元组拆封
&gt;&gt;&gt; x
10
&gt;&gt;&gt; y
20
</code></pre>
]]></content>
    </entry>
</feed>