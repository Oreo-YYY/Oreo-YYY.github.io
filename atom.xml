<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://y-rui.github.io</id>
    <title>Gridea</title>
    <updated>2020-12-14T17:14:00.379Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://y-rui.github.io"/>
    <link rel="self" href="https://y-rui.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://y-rui.github.io/images/avatar.png</logo>
    <icon>https://y-rui.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[Vim基本操作]]></title>
        <id>https://y-rui.github.io/post/vim-ji-ben-cao-zuo/</id>
        <link href="https://y-rui.github.io/post/vim-ji-ben-cao-zuo/">
        </link>
        <updated>2020-12-13T03:10:42.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>vim 启动进入普通模式，处于插入模式或命令行模式时只需要按 Esc 或者 Ctrl+[（这在 vim 课程环境中不管用）即可进入普通模式。普通模式中按 i（插入）或 a（附加）键都可以进入插入模式，普通模式中按 : 进入命令行模式。命令行模式中输入 wq 回车后保存并退出 vim</li>
</ul>
<h2 id="进入vim">进入Vim</h2>
<ul>
<li>vim 后面加上你要打开的已存在的文件名或者不存在（则作为新建文件）的文件名</li>
</ul>
<pre><code>vim practice_1.txt
</code></pre>
<ul>
<li>直接使用 vim 也可以打开 vim 编辑器，但是不会打开任何文件</li>
</ul>
<pre><code>vim
</code></pre>
<ul>
<li>进入命令行模式后输入 <code>:e &lt;filepath&gt;</code> 同样可以打开相应文件</li>
<li>按Esc进入普通模式，在该模式下使用方向键或者 h，j，k，l 键可以移动游标</li>
</ul>
<table>
<thead>
<tr>
<th>按键</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>h</td>
<td>左</td>
</tr>
<tr>
<td>l</td>
<td>右</td>
</tr>
<tr>
<td>j</td>
<td>下</td>
</tr>
<tr>
<td>k</td>
<td>上</td>
</tr>
<tr>
<td>w</td>
<td>移动到下一个单词</td>
</tr>
<tr>
<td>b</td>
<td>移动到上一个单词</td>
</tr>
</tbody>
</table>
<ul>
<li>在普通模式下使用下面的键将进入插入模式，并可以从相应的位置开始输入</li>
</ul>
<table>
<thead>
<tr>
<th>按键</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>在当前光标处进行编辑</td>
</tr>
<tr>
<td>I</td>
<td>在行首插入</td>
</tr>
<tr>
<td>A</td>
<td>在行末插入</td>
</tr>
<tr>
<td>a</td>
<td>在光标后插入编辑</td>
</tr>
<tr>
<td>o</td>
<td>在当前行后插入一个新行</td>
</tr>
<tr>
<td>O</td>
<td>在当前行前插入一个新行</td>
</tr>
<tr>
<td>cw</td>
<td>替换从光标所在位置后到一个单词结尾的字符</td>
</tr>
</tbody>
</table>
<h2 id="退出-vim">退出 vim</h2>
<ul>
<li>从普通模式输入 : 进入命令行模式，输入 w 回车，保存文档。输入 :w <filename> 可以将文档另存为其他文件名或存到其它路径下</li>
<li>从普通模式输入 : 进入命令行模式，输入 wq 回车，保存并退出编辑</li>
<li>普通模式下按下 Shift+zz 即可保存退出 vim</li>
</ul>
<table>
<thead>
<tr>
<th>按键</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:q!</td>
<td>强制退出，不保存</td>
</tr>
<tr>
<td>:q</td>
<td>退出</td>
</tr>
<tr>
<td>:wq!</td>
<td>强制保存并退出</td>
</tr>
<tr>
<td>:w &lt;文件路径&gt;</td>
<td>另存为</td>
</tr>
<tr>
<td>:saveas 文件路径</td>
<td>另存为</td>
</tr>
<tr>
<td>:x</td>
<td>保存并退出</td>
</tr>
<tr>
<td>:wq</td>
<td>保存并退出</td>
</tr>
</tbody>
</table>
<h2 id="删除文本">删除文本</h2>
<p>进入普通模式，使用下列命令可以进行文本快速删除</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>删除游标所在的字符</td>
</tr>
<tr>
<td>X</td>
<td>删除游标所在前一个字符</td>
</tr>
<tr>
<td>Delete</td>
<td>同 x</td>
</tr>
<tr>
<td>dd</td>
<td>删除整行</td>
</tr>
<tr>
<td>dw</td>
<td>删除一个单词（不适用中文）</td>
</tr>
<tr>
<td>d$或D</td>
<td>删除至行尾</td>
</tr>
<tr>
<td>d^</td>
<td>删除至行首</td>
</tr>
<tr>
<td>dG</td>
<td>删除到文档结尾处</td>
</tr>
<tr>
<td>d1G</td>
<td>删至文档首部</td>
</tr>
</tbody>
</table>
<p>除此之外，你还可以在命令之前加上数字，表示一次删除多行，如</p>
<ul>
<li>2dd 表示一次删除 2 行</li>
</ul>
<h2 id="重复执行上次命令">重复执行上次命令</h2>
<ul>
<li>在普通模式下 .(小数点)表示重复上一次的命令操作</li>
</ul>
<h2 id="执行指定次数相同的命令">执行指定次数相同的命令</h2>
<ul>
<li>进入普通模式输入 <code>N&lt;command&gt;</code>，N 表示重复后面的次数</li>
</ul>
<p>实例</p>
<ul>
<li>输入 10x，删除 10 个连续字符</li>
<li>输入 3dd，将会删除 3 行文本</li>
<li>在普通模式下，你还可以使用 dw 或者 daw(delete a word)删除一个单词，所以你可以很容易的联想到 dnw(n 替换为相应数字) 表示删除 n 个单词</li>
</ul>
<h2 id="游标的快速跳转">游标的快速跳转</h2>
<p><strong>行间跳转</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>nG(n Shift+g) / ngg</td>
<td>游标移动到第 n 行 (如果默认没有显示行号，请先进入命令模式，输入 :set nu 以显示行号)</td>
</tr>
<tr>
<td>gg</td>
<td>游标移动到到第一行</td>
</tr>
<tr>
<td>G(Shift+g)</td>
<td>到最后一行</td>
</tr>
</tbody>
</table>
<ul>
<li>小技巧：你在完成依次跳转后，可以使用 Ctrl+o 快速回到上一次(跳转前)光标所在位置</li>
</ul>
<p><strong>行内跳转</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>w</td>
<td>到下一个单词的开头</td>
</tr>
<tr>
<td>e</td>
<td>到当前单词的结尾</td>
</tr>
<tr>
<td>b</td>
<td>到前一个单词的开头</td>
</tr>
<tr>
<td>ge</td>
<td>到前一个单词的结尾</td>
</tr>
<tr>
<td>0或^</td>
<td>到行头</td>
</tr>
<tr>
<td>$</td>
<td>到行尾</td>
</tr>
<tr>
<td>f&lt;字母&gt;</td>
<td>向后搜索&lt;字母&gt;并跳转到第一个匹配的位置(非常实用)</td>
</tr>
<tr>
<td>F&lt;字母&gt;</td>
<td>向前搜索&lt;字母&gt;并跳转到第一个匹配的位置</td>
</tr>
<tr>
<td>t&lt;字母&gt;</td>
<td>向后搜索&lt;字母&gt;并跳转到第一个匹配位置之前的一个字母(不常用)</td>
</tr>
<tr>
<td>T&lt;字母&gt;&gt;</td>
<td>向前搜索&lt;字母&gt;并跳转到第一个匹配位置之后的一个字母(不常用)</td>
</tr>
</tbody>
</table>
<h2 id="复制粘贴和剪切">复制粘贴和剪切</h2>
<p><strong>复制及粘贴文本</strong></p>
<ul>
<li>普通模式中使用 y 复制</li>
<li>普通模式中，yy 复制游标所在的整行（3yy 表示复制 3 行）</li>
<li>普通模式中，y^ 复制至行首，或 y0。不含光标所在处字符。</li>
<li>普通模式中，y$ 复制至行尾。含光标所在处字符。</li>
<li>普通模式中，yw 复制一个单词。</li>
<li>普通模式中，y2w 复制两个单词。</li>
<li>普通模式中，yG 复制至文本末。</li>
<li>普通模式中，y1G 复制至文本开头。</li>
<li>普通模式中使用 p 粘贴</li>
<li>普通模式中，p(小写)代表粘贴至光标后（下）</li>
<li>普通模式中，P(大写)代表粘贴至光标前（上）</li>
</ul>
<p><strong>剪切及粘贴</strong></p>
<ul>
<li>其实前面讲得 dd 删除命令就是剪切，你每次 dd 删除文档内容后，便可以使用 p 来粘贴，也这一点可以让我们实现一个很爽快的功能——交换上下行<code>ddp</code>即实现了快速交换光标所在行与它下面的行</li>
</ul>
<h2 id="替换和撤销undo命令">替换和撤销(Undo)命令</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>r+&lt;待替换字母&gt;</td>
<td>将游标所在字母替换为指定字母</td>
</tr>
<tr>
<td>R</td>
<td>连续替换，直到按下 Esc</td>
</tr>
<tr>
<td>cc</td>
<td>替换整行，即删除游标所在行，并进入插入模式</td>
</tr>
<tr>
<td>cw</td>
<td>替换一个单词，即删除一个单词，并进入插入模式</td>
</tr>
<tr>
<td>C(大写)</td>
<td>替换游标以后至行末</td>
</tr>
<tr>
<td>~</td>
<td>反转游标所在字母大小写</td>
</tr>
<tr>
<td><code>{n}u</code></td>
<td>撤销一次或 n 次操作</td>
</tr>
<tr>
<td>U(大写)</td>
<td>撤销当前行的所有修改</td>
</tr>
<tr>
<td>Ctrl+r</td>
<td>redo，即撤销 undo 的操作</td>
</tr>
</tbody>
</table>
<h2 id="快速缩进">快速缩进</h2>
<p><strong>使用命令进行快速调整缩进操作</strong></p>
<ul>
<li>普通模式下输入 &gt;&gt; 整行将向右缩进</li>
<li>普通模式下输入 &lt;&lt; 整行向左回退</li>
<li>普通模式下输入 : 进入命令行模式下对 shiftwidth 值进行设置可以控制缩进和回退的字符数</li>
</ul>
<p><strong>shiftwidth 命令</strong></p>
<ul>
<li>shiftwidth 命令是指上一节 &gt;&gt; 命令产生的缩进（可以简写成sw），普通模式下输入 : 进入命令行模式下对 shiftwidth 值进行设置可以控制缩进和回退的字符数</li>
</ul>
<p>获取目前的设定值 <code>:set shiftwidth?</code><br>
设置缩进为 10 个字符 <code>:set shiftwidth=10</code></p>
<p><strong>调整文本位置</strong><br>
命令行模式下输入 <code>:ce</code>(center)命令使本行内容居中<br>
命令行模式下输入 <code>:ri</code>(right)命令使本行文本靠右<br>
命令行模式下输入 <code>:le</code>(left)命令使本行内容靠左</p>
<p>##查找<br>
<strong>快速查找</strong></p>
<ul>
<li>普通模式下输入 / 然后键入需要查找的字符串，按回车后就会进行查找。? 与/ 功能相同，只不过 ? 是向上而 / 是向下查找</li>
<li>进入查找之后，输入 n 和 N 可以继续查找。n 是查找下一个内容，N 查找上一个内容</li>
</ul>
<p><strong>高级查找</strong></p>
<ul>
<li>普通模式下输入 * 寻找游标所在处的单词</li>
<li>普通模式下输入 # 同上，但 # 是向前（上）找，* 则是向后（下）找</li>
<li>普通模式下输入 g* 同 *，但部分符合该单词即可</li>
<li>普通模式下输入 g# 同 #，但部分符合该单词即可</li>
</ul>
<h2 id="多文件编辑">多文件编辑</h2>
<p><strong>使用 vim 编辑多个文件</strong></p>
<ul>
<li>编辑多个文件有两种形式，一种是在进入 vim 前使用的参数就是多个文件。另一种就是进入 vim 后再编辑其他的文件。 同时创建两个新文件并编辑<code>vim 1.txt 2.txt</code></li>
</ul>
<p>默认进入1.txt文件的编辑界面</p>
<ul>
<li>命令行模式下输入 <code>:n</code> 编辑 2.txt 文件，可以加 ! 即 <code>:n!</code> 强制切换，之前一个文件的输入没有保存，仅仅切换到另一个文件</li>
<li>命令行模式下输入 <code>:N</code> 编辑 1.txt 文件，可以加 ! 即 <code>:N!</code> 强制切换，之前文件内的输入没有保存，仅仅是切换到另一个文件</li>
</ul>
<p><strong>进入 vim 后打开新文件</strong></p>
<ul>
<li>命令行模式下输入<code>:e 3.txt</code> 打开新文件 3.txt</li>
<li>命令行模式下输入<code>:e#</code> 回到前一个文件</li>
<li>命令行模式下输入<code>:ls</code> 可以列出以前编辑过的文档</li>
<li>命令行模式下输入<code>:b 2.txt</code>（或者编号）可以直接进入文件 2.txt 编辑</li>
<li>命令行模式下输入<code>:bd 2.txt</code>（或者编号）可以删除以前编辑过的列表中的文件项目</li>
<li>命令行模式下输入<code>:e! 4.txt</code> 新打开文件 4.txt，放弃正在编辑的文件</li>
<li>命令行模式下输入<code>:f</code> 显示正在编辑的文件名</li>
<li>命令行模式下输入<code>:f new.txt</code> 改变正在编辑的文件名字为 new.txt</li>
</ul>
<p><strong>恢复文件</strong></p>
<ul>
<li>如果因为断电，终端意外关闭等原因造成文档没有保存，可以采用恢复方式</li>
<li>vim 在编辑的时候会自动在当前文件目录下生成一个交换文件，一般以 <code>&lt;filename&gt;.swp</code> 的格式保存，如果有多个版本的交换文件，还可能是 .swn，.swm 等字母。注意这个交换文件的更新不是实时的，因为实时的更新会占用磁盘，影响系统其他正常进程的速度</li>
<li>当 vim 意外终止且没有保存已编辑的内容时，可以使用交换文件对文件进行恢复，注意需要在编辑这个文件的地方进行编辑，因为交换文件默认在编辑的目录生成</li>
<li>例如假设 1.txt 意外关闭，我们可以输入 vim 然后输入 <code>:recover 1.txt</code></li>
</ul>
<pre><code>vim
:recover 1.txt

# 出现如下提示按下回车即可恢复，如果有多个版本需要输入对应的交换文件前的数字选择要恢复的版本。
Using swap file &quot;.1.txt.swp&quot;
Original file &quot;~/test/1.txt&quot;
Recovery completed. You should check if everything is OK.
(You might want to write out this file under another name
and run diff with the original file to check for changes)
You may want to delete the .swp file now.
</code></pre>
<ul>
<li>或者输入 vim -r 后直接选择用于恢复的文档的交换文件即可</li>
</ul>
<pre><code>vim -r 1.txt
</code></pre>
<h2 id="可视模式">可视模式</h2>
<p><strong>可视模式命令简介</strong></p>
<ul>
<li>在普通模式下输入 v（小写），进入字符选择模式，就可以移动光标，光标走过的地方就会选取。再次按下 v 后就会取消选取</li>
<li>在普通模式下输入 Shift+v（小写），进入行选择模式，按下 V 之后就会把整行选取，您可以上下移动光标选更多的行，同样，再按一次 Shift+v 就可以取消选取</li>
<li>在普通模式下输入 Ctrl+v（小写），这是区域选择模式，可以进行矩形区域选择，再按一次 Ctrl+v 取消选取</li>
<li>在可视模式下输入 d 删除选取区域内容</li>
<li>在可视模式下输入 y 复制选取区域内容</li>
</ul>
<h2 id="视窗操作">视窗操作</h2>
<p>vim 可以在一个界面里打开多个窗口进行编辑，这些编辑窗口称为 vim 的视窗。 打开方法有很多种，例如可以使用在命令行模式下输入 <code>:new</code> 打开一个新的 vim 视窗，并进入视窗编辑一个新文件（普通模式下输入 Ctrl+w 也可以），除了 <code>:new</code> 命令，下述列举的多种方法也可以在命令模式或普通模式下打开新的视窗</p>
<ul>
<li>命令行模式下输入 <code>:sp 1.txt</code> 打开新的水平分屏视窗来编辑 1.txt</li>
<li>命令行模式下输入 <code>:vsp 2.txt</code> 打开新的垂直分屏视窗来编辑 2.txt</li>
<li>普通模式下 Ctrl+w s 将当前窗口分割成两个水平的窗口</li>
<li>普通模式下 Ctrl+w v 将当前窗口分割成两个垂直的窗口</li>
<li>普通模式下 Ctrl+w q 即 :q 结束分割出来的视窗。如果在新视窗中有输入需要使用强制符！即:q!</li>
<li>普通模式下 Ctrl+w o 打开一个视窗并且隐藏之前的所有视窗</li>
<li>普通模式下 Ctrl+w j 移至下面视窗</li>
<li>普通模式下 Ctrl+w k 移至上面视窗</li>
<li>普通模式下 Ctrl+w h 移至左边视窗</li>
<li>普通模式下 Ctrl+w l 移至右边视窗</li>
<li>普通模式下 Ctrl+w J 将当前视窗移至下面</li>
<li>普通模式下 Ctrl+w K 将当前视窗移至上面</li>
<li>普通模式下 Ctrl+w H 将当前视窗移至左边</li>
<li>普通模式下 Ctrl+w L 将当前视窗移至右边</li>
<li>普通模式下 Ctrl+w - 减小视窗的高度</li>
<li>普通模式下 Ctrl+w + 增加视窗的高度</li>
</ul>
<h2 id="文档加密">文档加密</h2>
<p><strong>创建加密文档</strong></p>
<pre><code>vim -x file1
</code></pre>
<ul>
<li>输入您的密码，确认密码，这样在下一次打开时，vim 就会要求你输入密码</li>
</ul>
<h2 id="在-vim-执行外部命令">在 vim 执行外部命令</h2>
<p>在命令行模式中输入 ! 可以执行外部的 shell 命令</p>
<ul>
<li><code>:!ls</code> 用于显示当前目录的内容</li>
<li><code>:!rm FILENAME</code> 用于删除名为 FILENAME 的文件</li>
<li><code>:w FILENAME</code> 可将当前 VIM 中正在编辑的文件另存为 FILENAME 文件</li>
</ul>
<h2 id="帮助系统">帮助系统</h2>
<p>vim 中的查看帮助</p>
<ul>
<li>普通模式下按 F1 打开 vim 自己预设的帮助文档</li>
<li>命令行模式下输入 <code>:h shiftwidth</code> 打开名为 shiftwidth 的帮助文件</li>
<li>命令行模式下输入 <code>:ver</code> 显示版本及参数</li>
</ul>
<h2 id="功能设定">功能设定</h2>
<p><strong>vim 的功能设定</strong></p>
<ul>
<li>可以在编辑文件的时候进行功能设定，如命令行模式下输入 <code>:set nu</code>（显示行数），设定值退出 vim 后不会保存。要永久保存配置需要修改 vim 配置文件。</li>
<li>vim 的配置文件 ~/.vimrc（实验楼环境中配置文件在 /etc/vim/vimrc），可以打开文件进行修改，不过务必小心不要影响 vim 正常使用。</li>
</ul>
<p><strong>获取目前的设定</strong></p>
<ul>
<li>命令行模式下输入 <code>:set</code> 或者 <code>:se</code> 显示所有修改过的配置</li>
<li>命令行模式下输入 <code>:set all</code> 显示所有的设定值</li>
<li>命令行模式下输入 <code>:set &lt;option&gt;?</code> 显示 option 的设定值</li>
<li>命令行模式下输入 <code>:set nooption</code> 取消当前设定值</li>
</ul>
<p><strong>set 功能的说明</strong></p>
<ul>
<li>命令行模式下输入 <code>:set autoindent(ai)</code> 设置自动缩进</li>
<li>命令行模式下输入 <code>:set autowrite(aw)</code> 设置自动存档，默认未打开</li>
<li>命令行模式下输入 <code>:set background=dark</code> 或 <code>light</code>，设置背景风格</li>
<li>命令行模式下输入 <code>:set backup(bk)</code> 设置自动备份，默认未打开</li>
<li>命令行模式下输入 <code>: set cindent(cin)</code> 设置 C 语言风格缩进</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础3-常用类]]></title>
        <id>https://y-rui.github.io/post/java-2-chang-yong-lei/</id>
        <link href="https://y-rui.github.io/post/java-2-chang-yong-lei/">
        </link>
        <updated>2020-07-23T01:33:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="arrays">Arrays</h2>
<ul>
<li>Arrays 类包含用于操作数组的各种方法（例如排序和搜索）。还包含一个静态工厂，允许将数组转为 List</li>
</ul>
<p><strong>Arrays 常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;T&gt; List&lt;T&gt; asList(T... a)</code></td>
<td>返回由指定数组构造的 List</td>
</tr>
<tr>
<td><code>void sort(Object[] a)</code></td>
<td>对数组进行排序</td>
</tr>
<tr>
<td><code>void fill(Object[] a, Object val)</code></td>
<td>为数组的所有元素都赋上相同的值</td>
</tr>
<tr>
<td><code>boolean equals(Object[] a, Object[] a2)</code></td>
<td>检查两个数组是否相等</td>
</tr>
<tr>
<td><code>int binarySearch(Object[] a, Object key)</code></td>
<td>对排序后的数组使用二分法查找数据</td>
</tr>
</tbody>
</table>
<p><strong>实例</strong></p>
<pre><code>import java.util.Arrays;
import java.util.Random;

public class ArraysDemo {
    public static void main(String[] args) {
        int[] arr = new int[10];
        //将数组元素都设为9
        Arrays.fill(arr, 9);
        System.out.println(&quot;fill:&quot; + Arrays.toString(arr));
        Random random = new Random();
        for (int i = 0; i &lt; arr.length; i++) {
            //使用100以内的随机数赋值数组
            arr[i] = random.nextInt(101);
        }
        //重新赋值后的数组
        System.out.println(&quot;重新赋值：&quot; + Arrays.toString(arr));
        //将索引为5的元素设为50
        arr[5] = 50;
        //排序
        Arrays.sort(arr);
        //排序后的数组
        System.out.println(&quot;sort排序后：&quot; + Arrays.toString(arr));
        //查找50的位置
        int i = Arrays.binarySearch(arr, 50);
        System.out.println(&quot;值为50的元素索引：&quot;+i);
        //复制一份新数组
        int[] newArr = Arrays.copyOf(arr, arr.length);
        //比较
        System.out.println(&quot;equals:&quot;+Arrays.equals(arr, newArr));
    }
}
</code></pre>
<pre><code>$ javac ArraysDemo.java
$ java ArraysDemo
fill:[9, 9, 9, 9, 9, 9, 9, 9, 9, 9]
重新赋值：[69, 83, 40, 58, 94, 42, 2, 53, 43, 83]
sort排序后：[2, 40, 43, 50, 53, 58, 69, 83, 83, 94]
值为50的元素索引：3
equals:true
</code></pre>
<p><strong>练习题</strong></p>
<ul>
<li>使用 Arrays 将数组 [6, 17, 92, 32, 58, 22, 84, 66, 36, 33] 进行排序</li>
<li>找出排序后 33 所在的位置</li>
<li>测试一下如果不排序能否找到值 33</li>
</ul>
<pre><code>import java.util.Arrays;

public class ArraysTest {
    public static void main(String[] args) {
        int[] arr = {6, 17, 92, 32, 58, 22, 84, 66, 36, 33};
        Arrays.sort(arr);
        System.out.println(Arrays.binarySearch(arr, 33));
    }
}
</code></pre>
<h2 id="stringbuilder">StringBuilder</h2>
<ul>
<li>StringBuilder 类是可变的。它是 String 的对等类，它可以增加和编写字符的可变序列，并且能够将字符插入到字符串中间或附加到字符串末尾（当然是不用创建其他对象的）</li>
</ul>
<p><strong>StringBuilder 的构造方法</strong></p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>StringBuilder()</code></td>
<td>构造一个其中不带字符的 StringBuilder，其初始容量为 16 个字符</td>
</tr>
<tr>
<td><code>StringBuilder(CharSequence seq)</code></td>
<td>构造一个 StringBuilder，它包含与指定CharSequence 相同的字符</td>
</tr>
<tr>
<td><code>StringBuilder(int capacity)</code></td>
<td>构造一个具有指定初始容量的 StringBuilder</td>
</tr>
<tr>
<td><code>StringBuilder(String str)</code></td>
<td>并将其内容初始化为指定的字符串内容</td>
</tr>
</tbody>
</table>
<p><strong>StringBuilder 类的常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>返回值</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>insert(int offsetm,Object obj)</code></td>
<td>StringBuilder</td>
<td>在 offsetm 的位置插入字符串 obj</td>
</tr>
<tr>
<td><code>append(Object obj)</code></td>
<td>StringBuilder</td>
<td>在字符串末尾追加字符串 obj</td>
</tr>
<tr>
<td><code>length()</code></td>
<td>int</td>
<td>确定 StringBuilder 对象的长度</td>
</tr>
<tr>
<td><code>setCharAt(int index,char ch)</code></td>
<td>void</td>
<td>使用 ch 指定的新值设置 index 指定的位置上的字符</td>
</tr>
<tr>
<td><code>toString()</code></td>
<td>String</td>
<td>转换为字符串形式</td>
</tr>
<tr>
<td><code>reverse()</code></td>
<td>StringBuilder</td>
<td>反转字符串</td>
</tr>
<tr>
<td><code>delete(int start, int end)</code></td>
<td>StringBuilder</td>
<td>删除调用对象中从 start 位置开始直到end指定的索引（end-1）位置的字符序列</td>
</tr>
<tr>
<td><code>replace(int start, int end, String str)</code></td>
<td>StringBuilder</td>
<td>使用一组字符替换另一组字符。将用替换字符串从 start 指定的位置开始替换，直到 end 指定的位置结束</td>
</tr>
</tbody>
</table>
<pre><code>public class StringBuilderTest {

    public static void main(String[] args){
        //定义和初始化一个StringBuilder类的字串s
        StringBuilder s = new StringBuilder(&quot;I&quot;);
        //在s后面添加字串&quot; java&quot;
        s.append(&quot; java&quot;);
        //在s[1]的位置插入字串
        s.insert(1, &quot; love&quot;);
        String t = s.toString(); //转为字符串
        System.out.println(t);
    }
}
</code></pre>
<p>输出结果为：I love java</p>
<h2 id="calendar">Calendar</h2>
<p>在早期的 JDK 版本中，Date 类附有两大功能</p>
<ol>
<li>允许用年、月、日、时、分、秒来解释日期</li>
<li>允许对表示日期的字符串进行格式化和句法分析</li>
</ol>
<ul>
<li>在 JDK1.1 中提供了类 Calendar 来完成第一种功能，类 DateFormat 来完成第二项功能。DateFormat 是 java.text 包中的一个类。与 Date 类有所不同的是，DateFormat 类可以接受用各种语言和不同习惯表示的日期字符串</li>
<li>但是 Calendar 类是一个抽象类，它完成 Date 类与普通日期表示法之间的转换，而我们更多的是使用 Calendar 类的子类 GregorianCalendar 类。它实现了世界上普遍使用的公历系统。当然我们也可以继承 Calendar 类，然后自己定义实现日历方法</li>
</ul>
<p><strong>GregorianCalendar 类的构造函数</strong></p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>GregorianCalendar()</code></td>
<td>创建的对象中的相关值被设置成指定时区，缺省地点的当前时间，即程序运行时所处的时区、地点的当前时间</td>
</tr>
<tr>
<td><code>GregorianCalendar(TimeZone zone)</code></td>
<td>创建的对象中的相关值被设置成指定时区 zone，缺省地点的当前时间</td>
</tr>
<tr>
<td><code>GregorianCalendar(Locale aLocale)</code></td>
<td>创建的对象中的相关值被设置成缺省时区，指定地点 aLocale 的当前时间</td>
</tr>
<tr>
<td><code>GregorianCalendar(TimeZone zone,Locale aLocale)</code></td>
<td>创建的对象中的相关值被设置成指定时区，指定地点的当前时间</td>
</tr>
</tbody>
</table>
<ul>
<li>TimeZone 是 java.util 包中的一个类，其中封装了有关时区的信息。每一个时区对应一组 ID。类 TimeZone 提供了一些方法完成时区与对应 ID 两者之间的转换</li>
</ul>
<pre><code>//太平洋时区的 ID 为 PST
TimeZone tz0 = TimeZone.getTimeZone(&quot;PST&quot;)
//getDefault()可以获取主机所处时区的对象
TimeZone tz1 = TimeZone.getDefault()
</code></pre>
<ul>
<li>Locale 只是一种机制，它用来标识一个特定的地理、政治或文化区域获取一个 Locale 对象的构造方法</li>
</ul>
<pre><code>//调用Locale类的构造方法
Locale l0 = new Locale(String language)
Locale l1 = new Locale(String language, String country)
Locale l2 = new Locale(String languge, String country, String variant)

//调用Locale类中定义的常量
Locale  l1 = Locale.CHINA
</code></pre>
<p><strong>实例</strong></p>
<pre><code>import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

public class CalendarDemo {
    public static void main(String[] args) {
        System.out.println(&quot;完整显示日期时间：&quot;);
        // 字符串转换日期格式
        DateFormat fdate = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        String str = fdate.format(new Date());
        System.out.println(str);

        // 创建 Calendar 对象
        Calendar calendar = Calendar.getInstance();
        // 初始化 Calendar 对象，但并不必要，除非需要重置时间
        calendar.setTime(new Date());

        // 显示年份
        System.out.println(&quot;年： &quot; + calendar.get(Calendar.YEAR));

        // 显示月份 (从0开始, 实际显示要加一)
        System.out.println(&quot;月： &quot; + calendar.get(Calendar.MONTH));


        // 当前分钟数
        System.out.println(&quot;分钟： &quot; + calendar.get(Calendar.MINUTE));

        // 今年的第 N 天
        System.out.println(&quot;今年的第 &quot; + calendar.get(Calendar.DAY_OF_YEAR) + &quot;天&quot;);

        // 本月第 N 天
        System.out.println(&quot;本月的第 &quot; + calendar.get(Calendar.DAY_OF_MONTH) + &quot;天&quot;);

        // 3小时以后
        calendar.add(Calendar.HOUR_OF_DAY, 3);
        System.out.println(&quot;三小时以后的时间： &quot; + calendar.getTime());
        // 格式化显示
        str = (new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SS&quot;)).format(calendar.getTime());
        System.out.println(str);

        // 重置 Calendar 显示当前时间
        calendar.setTime(new Date());
        str = (new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SS&quot;)).format(calendar.getTime());
        System.out.println(str);

        // 创建一个 Calendar 用于比较时间
        Calendar calendarNew = Calendar.getInstance();

        // 设定为 5 小时以前，后者大，显示 -1
        calendarNew.add(Calendar.HOUR, -5);
        System.out.println(&quot;时间比较：&quot; + calendarNew.compareTo(calendar));

        // 设定7小时以后，前者大，显示 1
        calendarNew.add(Calendar.HOUR, +7);
        System.out.println(&quot;时间比较：&quot; + calendarNew.compareTo(calendar));

        // 退回 2 小时，时间相同，显示0
        calendarNew.add(Calendar.HOUR, -2);
        System.out.println(&quot;时间比较：&quot; + calendarNew.compareTo(calendar));

        // calendarNew创建时间点
        System.out.println((new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SS&quot;)).format(calendarNew.getTime()));
        // calendar创建时间点
        System.out.println((new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SS&quot;)).format(calendar.getTime()));
        System.out.println(&quot;时间比较：&quot; + calendarNew.compareTo(calendar));
    }
}
</code></pre>
<pre><code>$ javac CalendarDemo.java
$ java CalendarDemo
完整显示日期时间：
2018-12-12 15:50:49
年： 2018
月： 11
分钟： 50
今年的第 346天
本月的第 12天
三小时以后的时间： Wed Dec 12 18:50:49 CST 2018
2018-12-12 18:50:49:449
2018-12-12 15:50:49:455
时间比较：-1
时间比较：1
时间比较：1
2018-12-12 15:50:49:456
2018-12-12 15:50:49:455
时间比较：1
</code></pre>
<p>运行上面的代码后，看见控制台上的输出结果会不会有所疑问呢？</p>
<ul>
<li>其实 month 的含义与 Date 类相同，0 代表 1 月，11 代表 12 月</li>
<li>有的可能不明白最后一个的输出为什么有时是 0 ，有时是 1，在这里会涉及到 calendarNew 与 calendar 的创建时间点，calendarNew 经过增加和减少时间后恢复到原来的时间点，也就是最终比较的是谁先创建好，时间点靠后的大一些，而 calendarNew 创建的时间点只有可能是大于等于 calendar 的，需要根据实际的创建时间点进行比较</li>
</ul>
<h2 id="date">Date</h2>
<ul>
<li>Date 类表示日期和时间，里面封装了操作日期和时间的方法。Date 类经常用来获取系统当前时间</li>
</ul>
<p>类 Date 中定义的未过时的构造方法</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Date()</code></td>
<td>构造一个 Date 对象并对其进行初始化以反映当前时间</td>
</tr>
<tr>
<td><code>Date(long date)</code></td>
<td>构造一个 Date 对象，并根据相对于 GMT 1970 年 1 月 1 日 00:00:00 的毫秒数对其进行初始化</td>
</tr>
</tbody>
</table>
<p><strong>实例</strong></p>
<pre><code>import java.text.SimpleDateFormat;
import java.util.Date;

public class DateDemo {
    public static void main(String[] args) {
        String strDate, strTime;
        Date objDate = new Date();
        System.out.println(&quot;今天的日期是：&quot; + objDate);
        long time = objDate.getTime();
        System.out.println(&quot;自1970年1月1日起以毫秒为单位的时间（GMT）：&quot; + time);
        strDate = objDate.toString();
        //提取 GMT 时间
        strTime = strDate.substring(11, (strDate.length() - 4));
        //按小时、分钟和秒提取时间
        strTime = &quot;时间：&quot; + strTime.substring(0, 8);
        System.out.println(strTime);
        //格式化时间
        SimpleDateFormat formatter = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        System.out.println(formatter.format(objDate));
    }
}
</code></pre>
<pre><code>$ javac DateDemo.java
$ java DateDemo
今天的日期是：Wed Dec 12 14:43:15 CST 2018
自1970年1月1日起以毫秒为单位的时间（GMT）：1544596995669
时间：14:43:15
2018-12-12 14:43:15
</code></pre>
<ul>
<li>Date 类的很多方法自 JDK 1.1 开始就已经过时了</li>
</ul>
<h2 id="math">Math</h2>
<ul>
<li>Math 类在 java.lang 包中，包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数</li>
</ul>
<p><strong>常见方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>返回值</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pow(double a, double b)</code></td>
<td>double</td>
<td>计算 a 的 b 次方</td>
</tr>
<tr>
<td><code>sqrt(double numvalue)</code></td>
<td>double</td>
<td>计算给定值的正平方根</td>
</tr>
<tr>
<td><code>abs(int numvalue)</code></td>
<td>int</td>
<td>计算 int 类型值 numvalue 的绝对值，也接收 long、float 和 double 类型的参数</td>
</tr>
<tr>
<td><code>max(int a, int b)</code></td>
<td>int</td>
<td>返回 int 型 a 和 b 中的较大值，也接收 long、float 和 double 类型的参数</td>
</tr>
<tr>
<td><code>min(int a, int b)</code></td>
<td>int</td>
<td>返回 a 和 b 中的较小值，也可接受 long、float 和 double 类型的参数</td>
</tr>
<tr>
<td><code>random()</code></td>
<td>double</td>
<td>返回带正号的 double 值，该值大于等于 0.0 且小于 1.0</td>
</tr>
</tbody>
</table>
<p><strong>实例</strong></p>
<pre><code>public class MathDemo {
    public static void main(String[] args) {
        System.out.println(Math.abs(-12.7));
        System.out.println(Math.ceil(12.7));
        System.out.println(Math.rint(12.4));
        System.out.println(Math.random());
        System.out.println(&quot;sin30 = &quot; + Math.sin(Math.PI / 6));
        // 计算30°的正弦值，参数是用弧度表示的角，即π的六分之一
        System.out.println(&quot;cos30 = &quot; + Math.cos(Math.PI / 6));
        // 计算30°的余弦值，这些计算三角函数的方法，其参数和返回值的类型都为double
        System.out.println(&quot;tan30 = &quot; + Math.tan(Math.PI / 6));
        // 计算30°的正切值
    }
}
</code></pre>
<pre><code>$ javac MathDemo.java
$ java MathDemo
12.7
13.0
12.0
0.8011998172263968
sin30 = 0.49999999999999994
cos30 = 0.8660254037844387
tan30 = 0.5773502691896257
</code></pre>
<p><strong>练习题</strong></p>
<ul>
<li>使用 Math.random() 生成两个随机数 a 和 b</li>
<li>求出两个随机数中的较大值</li>
<li>只能使用 Math 类中的方法</li>
</ul>
<pre><code>public class MathTest {
    public static void main(String[] args) {
        double a = Math.random();
        double b = Math.random();
        System.out.println(a);
        System.out.println(b);
        System.out.println(Math.max(a, b));
    }

}
</code></pre>
<h2 id="system">System</h2>
<p>System 类提供了以下功能</p>
<ul>
<li>标准输入，标准输出和错误输出流</li>
<li>访问外部定义的属性和环境变量</li>
<li>加载文件和库的方法</li>
<li>以及用于快速复制数组的实用方法</li>
</ul>
<p>System 不可以被实例化，只可以使用其静态方法</p>
<pre><code>//从指定的源数组中复制一个数组，从源数组指定的位置开始，到目标数组指定的位置
public static void arraycopy(Object src,int srcPos, Object dest,int desPos,int length)
//返回以毫秒为单位的当前时间(从1970年到现在的毫秒数)
public static long currentTimeMillis()
//终止当前正在运行的Java虚拟机，status为 0时退出
public static void exit(int status)
//  运行垃圾收集器
public static void gc()
// 取得当前系统的全部属性
public static Properties getProperties()
//获取指定键的系统属性
public static String  getProperty(String key)
</code></pre>
<pre><code>$ javac SystemDemo.java
$ java SystemDemo
[1, 2, 8, 9, 10, 6]
当前时间：1544670501472
java版本信息：11
</code></pre>
<p><strong>练习题</strong></p>
<ul>
<li>获取 Java 的安装目录 (java.home)</li>
<li>练习 System.arraycopy 方法（自己随便复制两个数组）</li>
</ul>
<pre><code>import java.util.Arrays;

public class SystemTest {
    public static void main(String[] args) {
        int[] a = {7, 8, 9, 10, 11};
        int[] b = {1, 2, 3, 4, 5, 6};
        //从数组a的第二个元素开始，复制到b数组的第三个位置 复制的元素长度为3
        System.arraycopy(a, 1, b, 2, 3);
        //输出结果
        System.out.println(Arrays.toString(b));
        System.out.println(&quot;java安装路径：&quot; + System.getProperty(&quot;java.home&quot;));
    }
}
</code></pre>
<h2 id="random">Random</h2>
<ul>
<li>Random 类用于生成伪随机数流，在 java.util包下</li>
</ul>
<pre><code>import java.util.Random;

public class RandomDemo {
    public static void main(String[] args) {
        Random random = new Random();
        //随机生成一个整数 int范围
        System.out.println(random.nextInt());
        //生成 [0,n] 范围的整数  设n=100
        System.out.println(random.nextInt(100 + 1));
        //生成 [0,n) 范围的整数  设n=100
        System.out.println(random.nextInt(100));
        //生成 [m,n] 范围的整数  设n=100 m=40
        System.out.println((random.nextInt(100 - 40 + 1) + 40));
        //随机生成一个整数 long范围
        System.out.println(random.nextLong());
        //生成[0,1.0)范围的float型小数
        System.out.println(random.nextFloat());
        //生成[0,1.0)范围的double型小数
        System.out.println(random.nextDouble());
    }
}
</code></pre>
<pre><code>$ javac RandomDemo.java
$ java RandomDemo
272128541
67
93
66
-23177167376469717070.93104035
0.20044632645967309
</code></pre>
<p><strong>练习题</strong></p>
<ul>
<li>从控制台中获取 Int 数据 m，n (m &lt; n)，先输入 m，后输入 n</li>
<li>输出一个 [m,n] 之间的随机数</li>
</ul>
<pre><code>import java.util.Random;
import java.util.Scanner;

public class RandomTest {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int m = in.nextInt();
        int n = in.nextInt();
        Random random = new Random();
        System.out.println(random.nextInt(n - m + 1) + m);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础2-面对对象]]></title>
        <id>https://y-rui.github.io/post/java-2-mian-dui-dui-xiang/</id>
        <link href="https://y-rui.github.io/post/java-2-mian-dui-dui-xiang/">
        </link>
        <updated>2020-07-18T03:13:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="类">类</h2>
<p>定义类</p>
<ul>
<li>定义类名，用于区分不同的类。如下代码中 public class 后面跟的就是类名。class是声明类的关键字，类名后面跟上大括号，大括号里面就是类的一些信息。public 为权限修饰符</li>
<li>编写类的属性。对象有什么，需要通过属性来表示。属性的定义是写在类名后面的大括号里，在定义属性时，要明确属性的类型。在一个类当中可以写一个或多个属性。当然也可以不定义属性</li>
<li>编写类的方法。方法也是写在大括号里面。可以定义一个方法或多个方法，当然也可以不定义方法</li>
</ul>
<pre><code>public class People {
//属性（成员变量） 有什么
    double height;  //身高
    int age;     //年龄
    int sex;    //性别，0为男性，非0为女性

//方法 干什么
    void cry(){
        System.out.println(&quot;我在哭！&quot;);
    }
    void laugh(){
        System.out.println(&quot;我在笑！&quot;);
    }
    void printBaseMes(){
        System.out.println(&quot;我的身高是&quot;+height+&quot;cm&quot;);
        System.out.println(&quot;我的年龄是&quot;+age+&quot;岁&quot;);
        if(this.sex==0)
            System.out.println(&quot;我是男性！&quot;);
        else
            System.out.println(&quot;我是女性！&quot;);

    }
}
</code></pre>
<p>一个类可以包含以下<strong>类型变量</strong></p>
<ul>
<li>局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁</li>
<li>成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问</li>
<li>类变量：也叫静态变量，类变量也声明在类中，方法体之外，但必须声明为 static 类型</li>
</ul>
<h2 id="对象">对象</h2>
<pre><code>People LiLei = new People();
</code></pre>
<pre><code>public class NewObject {
    public static void main(String[] args) {
        People LiLei = new People(); //创建一个People对象LiLei

        LiLei.height =170;
        LiLei.age = 20;
        LiLei.sex = 1;

        LiLei.printBaseMes();
    }
}
</code></pre>
<pre><code>$ javac NewObject.java People.java
$ java NewObject
我的身高是170.0cm
我的年龄是20岁
我是女性！
</code></pre>
<h2 id="构造方法">构造方法</h2>
<pre><code>public class People{
    //无参构造方法
    public People(){

    }
    //有一个参数的构造方法
    public People(int age){

    }
}
</code></pre>
<pre><code>public class People {
//属性（成员变量）有什么
    double height;     //身高
    int age;           //年龄
    int sex;       //性别，0为男性，非0为女性

    //构造方法，初始化了所有属性
    public People(double h, int a, int s){
        height = h;
        age = a;
        sex = s;
    }
}
</code></pre>
<pre><code>//创建对象，调用我们自己定义的有参构造方法
People XiaoMing = new People(168, 21, 1);
</code></pre>
<ul>
<li>上面的例子中通过 new 关键字将类实例化成对象，而 new 后面跟的就是构造方法。于是可以知道 new + 构造方法 可以创建一个新的对象</li>
</ul>
<h2 id="引用与对象实例">引用与对象实例</h2>
<ul>
<li>在新建对象实例时，需要为对象实例设置一个对象名，就像这样</li>
</ul>
<pre><code>Object object=new Object();
</code></pre>
<ul>
<li>那么变量 object 就真的是 Object 对象么，这里其实只是创建了一个 object 对象的引用。如果同学们学过 C 语言，这里就和指针一样，变量 object 保存的其实 Object 对象的引用，指向了 Object 对象</li>
</ul>
<pre><code> ----------           ----------
 | object |---------&gt; | Object |
 ----------           ----------
 |        |           |        |
 ----------           ----------
 |        |           |        |
 ----------           ----------
 |        |           |        |
 ----------           ----------
 |        |           |        |
 ----------           ----------
</code></pre>
<ul>
<li>再看下面的例子</li>
</ul>
<pre><code>Object object1 = new Object();
Object object2 = object1;
System.out.println(object1 == object2);
</code></pre>
<ul>
<li>运行得到的结果为 true，说明 object1 和 object2 的内存地址相同 (== 会比较两个对象的内存地址是否相同），它们实际上是引用同一对象，如果改变 object1 对象内部的属性，那么 object2 的属性同样会改变</li>
</ul>
<h2 id="static">static</h2>
<p><strong>静态成员</strong></p>
<ul>
<li>Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问</li>
</ul>
<pre><code>public class StaticTest{
    public static String string=&quot;shiyanlou&quot;;
    public static void main(String[] args){
        //静态成员不需要实例化 直接就可以访问
        System.out.println(StaticTest.string);
        //如果不加static关键字 需要这样访问
        StaticTest staticTest=new StaticTest();
        System.out.println(staticTest.string);
        //如果加上static关键字，上面的两种方法都可以使用
    }
}
</code></pre>
<p><strong>静态方法</strong></p>
<ul>
<li>被 static 修饰的方法是静态方法，静态方法不依赖于对象，不需要将类实例化便可以调用，由于不实例化也可以调用，所以不能有 this，也不能访问非静态成员变量和非静态方法。但是非静态成员变量和非静态方法可以访问静态方法</li>
</ul>
<h2 id="final">final</h2>
<p>final 关键字可以修饰类、方法、属性和变量</p>
<ol>
<li>final 修饰类，则该类不允许被继承，为最终类</li>
<li>final 修饰方法，则该方法不允许被覆盖（重写）</li>
<li>final 修饰属性：则该类的属性不会进行隐式的初始化（类的初始化属性必须有值）或在构造方法中赋值（但只能选其一）</li>
<li>final 修饰变量，则该变量的值只能赋一次值，即常量</li>
</ol>
<pre><code>//静态常量
public final static String SHI_YAN_LOU=&quot;shiyanlou&quot;;
</code></pre>
<h2 id="权限修饰符">权限修饰符</h2>
<table>
<thead>
<tr>
<th>访问修饰符</th>
<th>本类</th>
<th>同包</th>
<th>子类</th>
<th>其他</th>
</tr>
</thead>
<tbody>
<tr>
<td>private</td>
<td>✔️</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>默认</td>
<td>✔️</td>
<td>✔️</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
</tr>
</tbody>
</table>
<ul>
<li>不同的访问修饰符的访问范围，比如 private 修饰的属性或者方法，只能在当前类中访问或者使用。默认 是什么修饰符都不加，默认在当前类中和同一包下都可以访问和使用。protected 修饰的属性或者方法，对同一包内的类和所有子类可见。public 修饰的属性或者方法，对所有类可见</li>
</ul>
<h2 id="封装">封装</h2>
<ul>
<li>封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别</li>
</ul>
<p>这样做有什么好处？</p>
<ol>
<li>只能通过规定的方法访问数据</li>
<li>隐藏类的实例细节，方便修改和实现</li>
</ol>
<p>如何去实现类的封装呢？</p>
<ol>
<li>修改属性的可见性，在属性的前面添加修饰符 (private)</li>
<li>对每个值属性提供对外的公共方法访问，如创建 getter/setter（取值和赋值）方法，用于对私有属性的访问</li>
<li>在 getter/setter 方法里加入属性的控制语句，例如我们可以加一个判断语句，对于非法输入给予否定</li>
</ol>
<pre><code>public class People {
    //属性（成员变量）有什么，前面添加了访问修饰符private
    //变成了私有属性，必须通过方法调用
    private double height;     //身高

    //属性已经封装好了，如果用户需要调用属性
    //必须用getter和setter方法进行调用
    //getter和setter方法需要程序员自己定义
    public double getHeight(){
    //getter 方法命名是get关键字加属性名（属性名首字母大写）
    //getter 方法一般是为了得到属性值
      return height;
    }

    //同理设置我们的setter方法
    //setter 方法命名是set关键字加属性名（首字母大写）
    //setter 方法一般是给属性值赋值，所以有一个参数
    public void setHeight(double newHeight){
      height = newHeight;
    }
}
</code></pre>
<pre><code>public class NewObject {

    public static void main(String[] args) {
        People LiLei = new People();    //创建了一个People对象LiLei

        //利用setter方法为属性赋值
        LiLei.setHeight(170.0);

        //利用getter方法取属性值
        System.out.println(&quot;LiLei的身高是&quot;+LiLei.getHeight());
    }
}
</code></pre>
<pre><code>$ javac NewObject.java People.java
$ java NewObject
LiLei的身高是170.0
</code></pre>
<h2 id="this">this</h2>
<ul>
<li>this 关键字代表当前对象。使用 this.属性 操作当前对象的属性，this.方法 调用当前对象的方法</li>
</ul>
<pre><code>public void setAge(int age) {
  this.age = age;
}
public int getAge() {
  return age;
}
</code></pre>
<ul>
<li>当成员变量和局部变量之间发生冲突时，在属性名前面添加了 this 关键字。 此时就代表将一个参数的值赋给当前对象的属性。同理 this 关键字可以调用当前对象的方法</li>
</ul>
<h2 id="继承">继承</h2>
<pre><code>public class Animal {
    public int legNum;     //动物四肢的数量

    //类方法
    public void bark() {
        System.out.println(&quot;动物叫！&quot;);
    }
}
</code></pre>
<pre><code>public class Dog extends Animal {
}
</code></pre>
<pre><code>public class Test{
    public static void main(String[] args) {
        Dog a = new Dog();
        a.legNum = 4;
        a.bark();
    }
}
</code></pre>
<pre><code>$ javac Test.java Animal.java Dog.java
$ java Test
动物叫！
</code></pre>
<p>继承的特点</p>
<ol>
<li>子类拥有父类除 private 以外的所有属性和方法</li>
<li>子类可以拥有自己的属性和方法</li>
<li>子类可以重写实现父类的方法</li>
<li>Java 中的继承是单继承，一个类只有一个父类</li>
</ol>
<ul>
<li>Java 实现多继承的一个办法是 implements（实现）接口，但接口不能有非静态的属性</li>
</ul>
<h2 id="super">super</h2>
<p>super 关键字在子类内部使用，代表父类对象</p>
<ol>
<li>访问父类的属性 super.属性名</li>
<li>访问父类的方法 super.bark()</li>
<li>子类构造方法需要调用父类的构造方法时，在子类的构造方法体里最前面的位置：super()</li>
</ol>
<h2 id="方法重载与重写">方法重载与重写</h2>
<p><strong>方法重载</strong></p>
<ul>
<li>方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。方法重载一般用于创建一组任务相似但是参数不同的方法</li>
</ul>
<pre><code>public class Test {
    void f(int i) {
        System.out.println(&quot;i=&quot; + i);
    }

    void f(float f) {
        System.out.println(&quot;f=&quot; + f);
    }

    void f(String s) {
        System.out.println(&quot;s=&quot; + s);
    }

    void f(String s1, String s2){
        System.out.println(&quot;s1+s2=&quot;+(s1+s2));
    }

    void f(String s, int i){
        System.out.println(&quot;s=&quot;+s+&quot;,i=&quot;+i);
    }

    public static void main(String[] args) {
        Test test = new Test();
        test.f(3456);
        test.f(34.56f);
        test.f(&quot;abc&quot;);
        test.f(&quot;abc&quot;,&quot;def&quot;);
        test.f(&quot;abc&quot;,3456);
    }
}
</code></pre>
<pre><code>$ javac Test.java
$ java Test
i=3456
f=34.56
s=abc
s1+s2=abcdef
s=abc,i=3456
</code></pre>
<p>方法重载有以下几种规则</p>
<ol>
<li>方法中的参数列表必须不同。比如：参数个数不同或者参数类型不同</li>
<li>重载的方法中允许抛出不同的异常</li>
<li>可以有不同的返回值类型，但是参数列表必须不同</li>
<li>可以有不同的访问修饰符</li>
</ol>
<p><strong>方法重写</strong></p>
<ul>
<li>子类可以继承父类的方法，但如果子类对父类的方法不满意，想在里面加入适合自己的一些操作时，就需要将方法进行重写。并且子类在调用方法中，优先调用子类的方法</li>
<li>当然在方法重写时要注意，重写的方法一定要与原父类的方法语法保持一致，比如返回值类型，参数类型及个数，和方法名都必须一致</li>
</ul>
<p>比如 Animal 类中有 bark() 这个方法代表了动物叫，但是不同的动物有不同的叫法，比如狗是汪汪汪，猫是喵喵喵</p>
<pre><code>public class Animal {
    //类方法
    public void bark() {
        System.out.println(&quot;动物叫！&quot;);
    }
}
</code></pre>
<pre><code>public class Dog extends Animal {
       //重写父类的bark方法
        public void bark() {
        System.out.println(&quot;汪！汪！汪！&quot;);
    }
}
</code></pre>
<pre><code>public class Test{
    public static void main(String args[]){
           Animal a = new Animal(); // Animal 对象
        Dog d = new Dog();   // Dog 对象

          Animal b = new Dog(); // Dog 对象,向上转型为Animal类型，具体会在后面的内容进行详解

          a.bark();// 执行 Animal 类的方法
         d.bark();//执行 Dog 类的方法
          b.bark();//执行 Dog 类的方法
       }
}
</code></pre>
<pre><code>$ javac Test.java Dog.java Animal.java
$ java Test
动物叫！
汪！汪！汪！
汪！汪！汪！
</code></pre>
<h2 id="多态">多态</h2>
<ul>
<li>多态是指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。多态也称作动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法</li>
<li>通俗地讲，只通过父类就能够引用不同的子类，这就是多态，我们只有在运行的时候才会知道引用变量所指向的具体实例对象</li>
</ul>
<p>多态的实现条件</p>
<ul>
<li>Java 实现多态有三个必要条件：继承、重写和向上转型（即父类引用指向子类对象）</li>
<li>只有满足上述三个条件，才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为</li>
</ul>
<p>多态的实现方式</p>
<ul>
<li>Java 中多态的实现方式：继承父类进行方法重写，抽象类和抽象方法，接口实现</li>
</ul>
<p><strong>向上转型</strong></p>
<pre><code>Animal a = new Animal();  //a是父类的引用指向的是本类的对象

Animal b = new Dog(); //b是父类的引用指向的是子类的对象
</code></pre>
<p>在这里，可以认为由于 Dog 继承于 Animal，所以 Dog 可以自动向上转型为 Animal，所以 b 是可以指向 Dog 实例对象的</p>
<ul>
<li>注：不能使用一个子类的引用去指向父类的对象，因为子类对象中可能会含有父类对象中所没有的属性和方法。</li>
</ul>
<p>如果定义了一个指向子类对象的父类引用类型，那么它除了能够引用父类中定义的所有属性和方法外，还可以使用子类强大的功能。但是对于只存在于子类的方法和属性就不能获取</p>
<pre><code>class Animal {
    //父类方法
    public void bark() {
        System.out.println(&quot;动物叫！&quot;);
    }
}

class Dog extends Animal {

    //子类重写父类的bark方法
    public void bark() {
        System.out.println(&quot;汪、汪、汪！&quot;);
    }
    //子类自己的方法
    public void dogType() {
        System.out.println(&quot;这是什么品种的狗？&quot;);
    }
}


public class Test {

    public static void main(String[] args) {
        Animal a = new Animal();
        Animal b = new Dog();
        Dog d = new Dog();

        a.bark();
        b.bark();
        //b.dogType();
        //b.dogType()编译不通过
        d.bark();
        d.dogType();
    }

}
</code></pre>
<pre><code>$ javac Test.java
$ java Test
动物叫！
汪、汪、汪！
汪、汪、汪！
这是什么品种的狗？
</code></pre>
<p>在这里，由于 b 是父类的引用，指向子类的对象，因此不能获取子类的方法（dogType() 方法）, 同时当调用 bark() 方法时，由于子类重写了父类的 bark() 方法，所以调用子类中的 bark() 方法</p>
<ul>
<li>因此，向上转型，在运行时，会遗忘子类对象中与父类对象中不同的方法，也会覆盖与父类中相同的方法——重写（方法名，参数都相同）</li>
</ul>
<h2 id="抽象类">抽象类</h2>
<ul>
<li>在定义类时，前面加上 abstract 关键字修饰的类叫抽象类</li>
</ul>
<p>抽象类中有抽象方法，这种方法是不完整的，仅有声明而没有方法体。抽象方法声明语法如下</p>
<pre><code>abstract void f();  //f()方法是抽象方法
</code></pre>
<p>那我们什么时候会用到抽象类呢？</p>
<ol>
<li>在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法。也就是说抽象类是约束子类必须要实现哪些方法，而并不关注方法如何去实现</li>
<li>从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性</li>
</ol>
<p>所以由上可知，抽象类是限制规定子类必须实现某些方法，但不关注实现细节<br>
那抽象类如何用代码实现呢，它的规则如下：</p>
<ol>
<li>用 abstract 修饰符定义抽象类</li>
<li>用 abstract 修饰符定义抽象方法，只用声明，不需要实现</li>
<li>包含抽象方法的类就是抽象类</li>
<li>抽象类中可以包含普通的方法，也可以没有抽象方法</li>
<li>抽象类的对象不能直接创建，通常是定义引用变量指向子类对象</li>
</ol>
<p>需要子类实现的抽象方法</p>
<pre><code>//抽象方法
public abstract class TelePhone {
    public abstract void call();  //抽象方法,打电话
    public abstract void message(); //抽象方法，发短信
}
</code></pre>
<p>构建子类，并实现抽象方法</p>
<pre><code>public class CellPhone extends TelePhone {

    @Override
    public void call() {
        System.out.println(&quot;我可以打电话！&quot;);
    }

    @Override
    public void message() {
        System.out.println(&quot;我可以发短信！&quot;);
    }

    public static void main(String[] args) {
        CellPhone cp = new CellPhone();
        cp.call();
        cp.message();
    }

}
</code></pre>
<pre><code>$ javac CellPhone.java TelePhone.java
$ java CellPhone

我可以打电话！
我可以发短信！
</code></pre>
<h2 id="接口">接口</h2>
<ul>
<li>接口用于描述类所具有的功能，而不提供功能的实现，功能的实现需要写在实现接口的类中，并且该类必须实现接口中所有的未实现方法</li>
</ul>
<pre><code>修饰符 interface 接口名称 [extends 其他的接口名] {
        // 声明变量
        // 抽象方法
}
</code></pre>
<pre><code>// Animal.java
interface Animal {
        //int x;
        //编译错误,x需要初始化，因为是 static final 类型
        int y = 5;
        public void eat();
        public void travel();
}
</code></pre>
<p><strong>注意点</strong><br>
在Java8中</p>
<ul>
<li>接口不能用于实例化对象</li>
<li>接口中方法只能是抽象方法、default 方法、静态方法</li>
<li>接口成员是 static final 类型</li>
<li>接口支持多继承</li>
</ul>
<p>在 Java9 中，接口可以拥有私有方法和私有静态方法，但是只能被该接口中的 default 方法和静态方法使用</p>
<p>多继承实现方式</p>
<pre><code>修饰符 interface A extends 接口1，接口2{

}

修饰符 class A implements 接口1，接口2{

}
</code></pre>
<p>实现上面的接口</p>
<pre><code>// Cat.java
public class Cat implements Animal{

     public void eat(){
         System.out.println(&quot;Cat eats&quot;);
     }

     public void travel(){
         System.out.println(&quot;Cat travels&quot;);
     }
     public static void main(String[] args) {
        Cat cat = new Cat();
        cat.eat();
        cat.travel();
    }
}
</code></pre>
<pre><code>$ javac Cat.java Animal.java
$ java Cat
Cat eats
Cat travels
</code></pre>
<h2 id="内部类">内部类</h2>
<ul>
<li>将一个类的定义放在另一个类的定义内部，这就是内部类。而包含内部类的类被称为外部类</li>
</ul>
<p>内部类的主要作用如下</p>
<ol>
<li>内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类</li>
<li>内部类的方法可以直接访问外部类的所有数据，包括私有的数据</li>
<li>内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便</li>
<li>内部类允许继承多个非接口类型</li>
</ol>
<ul>
<li>注：内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两类。对于一个名为 outer 的外部类和其内部定义的名为 inner 的内部类。编译完成后出现 outer.class 和 outer$inner.class 两类。所以内部类的成员变量 / 方法名可以和外部类的相同</li>
</ul>
<p><strong>成员内部类</strong></p>
<pre><code>// People.java
//外部类People
public class People {
    private String name = &quot;LiLei&quot;;         //外部类的私有属性
    //内部类Student
    public class Student {
        String ID = &quot;20151234&quot;;               //内部类的成员属性
        //内部类的方法
        public void stuInfo(){
            System.out.println(&quot;访问外部类中的name：&quot; + name);
            System.out.println(&quot;访问内部类中的ID：&quot; + ID);
        }
    }

    //测试成员内部类
    public static void main(String[] args) {
        People a = new People();     //创建外部类对象，对象名为a
        Student b = a.new Student(); //使用外部类对象创建内部类对象，对象名为b
        // 或者为 People.Student b = a.new Student();
        b.stuInfo();   //调用内部对象的suInfo方法
    }
}
</code></pre>
<pre><code>$ javac People.java
$ java People
访问外部类中的name：LiLei
访问内部类中的ID：20151234
</code></pre>
<p>成员内部类的使用方法</p>
<ol>
<li>Student 类相当于 People 类的一个成员变量，所以 Student 类可以使用任意访问修饰符</li>
<li>Student 类在 People 类里，所以访问范围在类里的所有方法均可以访问 People 的属性（即内部类里可以直接访问外部类的方法和属性，反之不行）</li>
<li>定义成员内部类后，必须使用外部类对象来创建内部类对象，即 内部类 对象名 = 外部类对象.new 内部类();</li>
<li>如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用 this 关键字。如上述代码中：a.this</li>
</ol>
<ul>
<li>注：成员内部类不能含有 static 的变量和方法，因为成员内部类需要先创建了外部类，才能创建它自己的</li>
</ul>
<p><strong>静态内部类</strong></p>
<ul>
<li>静态内部类通常被称为嵌套类</li>
</ul>
<pre><code>// People.java
//外部类People
public class People {
    private String name = &quot;LiLei&quot;;         //外部类的私有属性

/*外部类的静态变量。
Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问。
*/
    static String ID = &quot;510xxx199X0724XXXX&quot;;

    //静态内部类Student
    public static class Student {
        String ID = &quot;20151234&quot;;               //内部类的成员属性
        //内部类的方法
        public void stuInfo(){
            System.out.println(&quot;访问外部类中的name：&quot; + (new People().name));
            System.out.println(&quot;访问外部类中的ID：&quot; + People.ID);
            System.out.println(&quot;访问内部类中的ID：&quot; + ID);
        }
    }

    //测试成员内部类
    public static void main(String[] args) {
        Student b = new Student();   //直接创建内部类对象，对象名为b
        b.stuInfo();                 //调用内部对象的suInfo方法
    }
}
</code></pre>
<pre><code>$ javac People.java
$ java People
访问外部类中的name：LiLei
访问外部类中的ID：510xxx199X0724XXXX
访问内部类中的ID：20151234
</code></pre>
<p>静态内部类是 static 修饰的内部类，这种内部类的特点是</p>
<ol>
<li>静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问</li>
<li>如果外部类的静态成员与内部类的成员名称相同，可通过 类名.静态成员 访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过 成员名 直接调用外部类的静态成员</li>
<li>创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名 = new 内部类();</li>
</ol>
<p><strong>局部内部类</strong></p>
<ul>
<li>局部内部类，是指内部类定义在方法和作用域内</li>
</ul>
<pre><code>// People.java
//外部类People
public class People {
    //定义在外部类中的方法内：
    public void peopleInfo() {
        final String sex = &quot;man&quot;;  //外部类方法中的常量
        class Student {
            String ID = &quot;20151234&quot;; //内部类中的常量
            public void print() {
                System.out.println(&quot;访问外部类的方法中的常量sex：&quot; + sex);
                System.out.println(&quot;访问内部类中的变量ID:&quot; + ID);
            }
        }
        Student a = new Student();  //创建方法内部类的对象
        a.print();//调用内部类的方法
    }
    //定义在外部类中的作用域内
    public void peopleInfo2(boolean b) {
        if(b){
            final String sex = &quot;man&quot;;  //外部类方法中的常量
            class Student {
                String ID = &quot;20151234&quot;; //内部类中的常量
                public void print() {
                    System.out.println(&quot;访问外部类的方法中的常量sex：&quot; + sex);
                    System.out.println(&quot;访问内部类中的变量ID:&quot; + ID);
                }
            }
            Student a = new Student();  //创建方法内部类的对象
            a.print();//调用内部类的方法
        }
    }
    //测试方法内部类
    public static void main(String[] args) {
        People b = new People(); //创建外部类的对象
        System.out.println(&quot;定义在方法内：===========&quot;);
        b.peopleInfo();  //调用外部类的方法
        System.out.println(&quot;定义在作用域内：===========&quot;);
        b.peopleInfo2(true);
    }
}
</code></pre>
<pre><code>$ javac People.java
$ java People
定义在方法内：===========
访问外部类的方法中的常量sex：man
访问内部类中的变量ID:20151234
定义在作用域内：===========
访问外部类的方法中的常量sex：man
访问内部类中的变量ID:20151234
</code></pre>
<ul>
<li>局部内部类也像别的类一样进行编译，但只是作用域不同而已，只在该方法或条件的作用域内才能使用，退出这些作用域后无法引用的</li>
</ul>
<p><strong>匿名内部类</strong></p>
<ul>
<li>匿名内部类，顾名思义，就是没有名字的内部类。正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写。但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口</li>
</ul>
<pre><code>// Outer.java
public class Outer {

    public Inner getInner(final String name, String city) {
        return new Inner() {
            private String nameStr = name;
            public String getName() {
                return nameStr;
            }
        };
    }

    public static void main(String[] args) {
        Outer outer = new Outer();
        Inner inner = outer.getInner(&quot;Inner&quot;, &quot;NewYork&quot;);
        System.out.println(inner.getName());
    }
}
interface Inner {
    String getName();
}
</code></pre>
<p>运行结果：Inner</p>
<ul>
<li>匿名内部类是不能加访问修饰符的。要注意的是，new 匿名类，这个类是要先定义的, 如果不先定义，编译时会报错该类找不到</li>
<li>同时，在上面的例子中，当所在的方法的形参需要在内部类里面使用时，该形参必须为 final。这里可以看到形参 name 已经定义为 final 了，而形参 city 没有被使用则不用定义为 final</li>
</ul>
<p>然而，因为匿名内部类没名字，是用默认的构造方法的，无参数的，如果需要该类有带参数的构造方法，示例如下</p>
<pre><code>public Inner getInner(final String name, String city) {
  return new Inner(name, city) {
    private String nameStr = name;

    public String getName() {
      return nameStr;
    }
  };
}
</code></pre>
<ul>
<li>注意这里的形参 city，由于它没有被匿名内部类直接使用，而是被抽象类 Inner 的构造方法所使用，所以不必定义为 final</li>
</ul>
<h2 id="package">package</h2>
<ul>
<li>为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间</li>
</ul>
<p><strong>包的作用</strong></p>
<ul>
<li>把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用</li>
<li>包采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别</li>
<li>包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类</li>
</ul>
<pre><code>//在定义文件夹的时候利用&quot;/&quot;来区分层次
//包中用&quot;.&quot;来分层
package com.shiyanlou.java
</code></pre>
<p>如何在不同包中使用另一个包中的类？</p>
<ul>
<li>使用 import 关键字。比如要导入包 com.shiyanlou 下 People 这个类，import com.shiyanlou.People;。同时如果 import com.shiyanlou.<em>; 这是将包下的所有文件都导入进来，</em> 是通配符</li>
</ul>
<p><strong>包的命名规范是全小写字母拼写</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java - StringBuilder]]></title>
        <id>https://y-rui.github.io/post/java-stringbuilder/</id>
        <link href="https://y-rui.github.io/post/java-stringbuilder/">
        </link>
        <updated>2020-07-16T01:57:40.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>StringBuilder是可变对象，用来高效拼接字符串</li>
<li>StringBuilder可以支持链式操作，实现链式操作的关键是返回实例本身</li>
<li>StringBuffer是StringBuilder的线程安全版本，现在很少使用</li>
</ul>
<p>String s = &quot;&quot;;<br>
for (int i = 0; i &lt; 1000; i++) {<br>
s = s + &quot;,&quot; + i;<br>
}</p>
<pre><code>虽然可以直接拼接字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率


为了能高效拼接字符串，Java标准库提供了StringBuilder，它是一个可变对象，可以预分配缓冲区，这样，往StringBuilder中新增字符时，不会创建新的临时对象
</code></pre>
<p>StringBuilder sb = new StringBuilder(1024);<br>
for (int i = 0; i &lt; 1000; i++) {<br>
sb.append(',');<br>
sb.append(i);<br>
}<br>
String s = sb.toString();</p>
<pre><code></code></pre>
<p>// StringBuilder链式操作<br>
public class Main {<br>
public static void main(String[] args) {<br>
var sb = new StringBuilder(1024);<br>
sb.append(&quot;Mr &quot;)<br>
.append(&quot;Bob&quot;)<br>
.append(&quot;!&quot;)<br>
.insert(0, &quot;Hello, &quot;);<br>
System.out.println(sb.toString());<br>
}<br>
}<br>
// Hello, Mr Bob!</p>
<pre><code>如果我们查看StringBuilder的源码，可以发现，进行链式操作的关键是，定义的append()方法会返回this，这样，就可以不断调用自身的其他方法。
</code></pre>
<p>// 仿照StringBuilder，我们也可以设计支持链式操作的类。例如，一个可以不断增加的计数器<br>
public class Main {<br>
public static void main(String[] args) {<br>
Adder adder = new Adder();<br>
adder.add(3)<br>
.add(5)<br>
.inc()<br>
.add(10);<br>
System.out.println(adder.value());<br>
}<br>
}</p>
<p>class Adder {<br>
private int sum = 0;</p>
<pre><code>public Adder add(int n) {
    sum += n;
    return this;
}

public Adder inc() {
    sum ++;
    return this;
}

public int value() {
    return sum;
}
</code></pre>
<p>}</p>
<pre><code>对于普通的字符串+操作，并不需要我们将其改写为StringBuilder，因为Java编译器在编译时就自动把多个连续的+操作编码为StringConcatFactory的操作。在运行期，StringConcatFactory会自动把字符串连接操作优化为数组复制或者StringBuilder操作

StringBuffer，这是Java早期的一个StringBuilder的线程安全版本，它通过同步来保证多个线程操作StringBuffer也是安全的，但是同步会带来执行速度的下降
StringBuilder和StringBuffer接口完全相同，现在完全没有必要使用StringBuffer
## 练习题
</code></pre>
<p>// 请使用StringBuilder构造一个INSERT语句<br>
public class Main {<br>
public static void main(String[] args) {<br>
String[] fields = { &quot;name&quot;, &quot;position&quot;, &quot;salary&quot; };<br>
String table = &quot;employee&quot;;<br>
String insert = buildInsertSql(table, fields);<br>
System.out.println(insert);<br>
String s = &quot;INSERT INTO employee (name, position, salary) VALUES (?, ?, ?)&quot;;<br>
System.out.println(s.equals(insert) ? &quot;测试成功&quot; : &quot;测试失败&quot;);<br>
}<br>
static String buildInsertSql(String table, String[] fields) {<br>
// TODO:<br>
return &quot;&quot;;<br>
}<br>
}</p>
<pre><code></code></pre>
<p>// 答案<br>
StringBuilder sb = new StringBuilder(1024);<br>
sb.append(&quot;INSERT INTO &quot;)<br>
.append(table)<br>
.append(&quot; (&quot;);<br>
for(int i = 0; i&lt;= fields.length - 1;i++){<br>
sb.append(fields[i]);<br>
if (i != 2){<br>
sb.append(&quot;, &quot;);<br>
}<br>
}<br>
sb.append(&quot;)&quot;)<br>
.append(&quot; VALUES (?, ?, ?)&quot;);<br>
return sb.toString();</p>
<pre><code></code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础1-基础语法]]></title>
        <id>https://y-rui.github.io/post/java-ji-chu-yu-fa/</id>
        <link href="https://y-rui.github.io/post/java-ji-chu-yu-fa/">
        </link>
        <updated>2020-07-13T17:05:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="helloworld">HelloWorld</h2>
<pre><code>public class HelloWorld{
    public static void  main(String[] args){
        System.out.println(&quot;HelloWorld!&quot;);
    }
}
</code></pre>
<h2 id="命令行编译java">命令行编译Java</h2>
<pre><code>javac hello.java
java hello
</code></pre>
<h2 id="定义变量">定义变量</h2>
<pre><code>int a = 1;
</code></pre>
<pre><code>public class VarTest
{
  public static void main(String[] args)
  {
    System.out.println(&quot;Define a variable a is &quot;);
    int a; //声明变量a
    a = 5;
    System.out.println(a);  // 打印一个整数a
  }
}
</code></pre>
<h2 id="定义常量">定义常量</h2>
<pre><code>final double PI = 3.14;

final int FINAL_VARIABLE;
FINAL_VARIABLE = 100;
</code></pre>
<pre><code>public class FinalVar{
    public static void main(String[] args){
        final String FINAL_STRING=&quot;shiyanlou&quot;;
        System.out.println(FINAL_STRING);
    }
}
</code></pre>
<h2 id="string">String</h2>
<p><strong>String对象初始化</strong></p>
<pre><code>String s0 = &quot;abc&quot;;

String s1 = new String(&quot;abd&quot;);
</code></pre>
<p><strong>方法</strong></p>
<pre><code>length() //长度
equals() //字符串比较
equalsIgnoreCase() //忽略大小写的比较
== //比较连个对象在内存中存储的地址是否一样
+ concat() //字符串连接
charAt() //按照索引值获得字符串中的指定字符
</code></pre>
<pre><code>public class StringTest {
    public static void main(String[] args) {
         String s = &quot;abcdefabc&quot;;
         System.out.println(&quot;字符a第一次出现的位置为&quot;+s.indexOf('a'));
         System.out.println(&quot;字符串bc第一次出现的位置为&quot;+s.indexOf(&quot;bc&quot;));
         System.out.println(&quot;字符a最后一次出现的位置为&quot;+s.lastIndexOf('a'));
         System.out.println(&quot;从位置3开始到结束的字符串&quot;+s.substring(3));
         System.out.println(&quot;从位置3开始到6之间的字符串&quot;+s.substring(3,6));
    }
}
</code></pre>
<h2 id="运算符">运算符</h2>
<p><strong>算术运算符</strong></p>
<pre><code>public class ArithmeticOperation {
    public static void main(String args[]) {
        int a = 5;
        int b = 3;
        int c = 3;
        int d = 3;
        System.out.println(&quot;a + b = &quot; + (a + b));
        System.out.println(&quot;a - b = &quot; + (a - b));
        System.out.println(&quot;a * b = &quot; + (a * b));
        System.out.println(&quot;a / b = &quot; + (a / b));
        System.out.println(&quot;a % b = &quot; + (a % b));
        System.out.println(&quot;a++ = &quot; + (a++));
        System.out.println(&quot;++a = &quot; + (++a));
        System.out.println(&quot;b-- = &quot; + (b--));
        System.out.println(&quot;--b = &quot; + (--b));
        System.out.println(&quot;c++ = &quot; + (c++));
        System.out.println(&quot;++d = &quot; + (++d));
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac ArithmeticOperation.java
$ java ArithmeticOperation
a + b = 8
a - b = 2
a * b = 15
a / b = 1
a % b = 2
a++ = 5
++a = 7
b-- = 3
--b = 1
c++ = 3
++d = 4
</code></pre>
<ul>
<li>前缀自增自减法 (++i,--i): 先进行自增或者自减运算，再进行表达式运算</li>
<li>后缀自增自减法 (i++,i--): 先进行表达式运算，再进行自增或者自减运算</li>
</ul>
<p><strong>位运算符</strong></p>
<pre><code>public class BitOperation {
    public static void main(String args[]) {
        int a = 60;
        int b = 13;
        System.out.println(&quot;a &amp; b = &quot; + (a &amp; b));
        System.out.println(&quot;a | b = &quot; + (a | b));
        System.out.println(&quot;a ^ b = &quot; + (a ^ b));
        System.out.println(&quot;~a = &quot; + (~a));
        System.out.println(&quot;a &lt;&lt; 2 = &quot; + (a &lt;&lt; 2));
        System.out.println(&quot;a &gt;&gt; 2 = &quot; + (a &gt;&gt; 2));
        System.out.println(&quot;a &gt;&gt;&gt; 2 = &quot; + (a &gt;&gt;&gt; 2));
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac BitOperation.java
$ java BitOperation
a &amp; b = 12
a | b = 61
a ^ b = 49
~a = -61
a &lt;&lt; 2 = 240
a &gt;&gt; 2 = 15
a &gt;&gt;&gt; 2 = 15
</code></pre>
<p><strong>逻辑运算符</strong></p>
<pre><code>public class LogicOperation {
    public static void main(String args[]) {
        boolean a = true;
        boolean b = false;
        System.out.println(&quot;a &amp;&amp; b = &quot; + (a &amp;&amp; b));
        System.out.println(&quot;a || b = &quot; + (a || b));
        System.out.println(&quot;!a = &quot; + (!a));
        System.out.println(&quot;a ^ b = &quot; + (a ^ b));
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac LogicOperation.java
$ java LogicOperation
a &amp;&amp; b = false
a || b = true
!a = false
a ^ b = true
</code></pre>
<p><strong>关系运算符</strong></p>
<pre><code>public class RelationalOperation {
    public static void main(String args[]) {
        int a = 3;
        int b = 5;
        System.out.println(&quot;a == b = &quot; + (a == b));
        System.out.println(&quot;a != b = &quot; + (a != b));
        System.out.println(&quot;a &gt; b = &quot; + (a &gt; b));
        System.out.println(&quot;a &lt; b = &quot; + (a &lt; b));
        System.out.println(&quot;a &gt;= b = &quot; + (a &gt;= b));
        System.out.println(&quot;a &lt;= b = &quot; + (a &lt;= b));
        System.out.println(&quot;a &gt; b ? a : b = &quot; + (a &gt; b ? a : b));
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac RelationalOperation.java
$ java RelationalOperation
a == b = false
a != b = true
a &gt; b = false
a &lt; b = true
a &gt;= b = false
a &lt;= b = true
a &gt; b ? a : b = 5
</code></pre>
<h2 id="两数只和">两数只和</h2>
<pre><code>import java.util.Scanner;

public class Sum {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int a = in.nextInt();
        int b = in.nextInt();
        System.out.println(a + b);
    }
}
</code></pre>
<h2 id="调用方法">调用方法</h2>
<pre><code>public class MethodTest {
    private static void methodDemo() {
        System.out.println(&quot;Hello Shiyanlou&quot;);
    }

    public static void main(String[] args) {
        methodDemo();
    }
}
</code></pre>
<h2 id="流程控制">流程控制</h2>
<p><strong>if语句</strong></p>
<pre><code>if(条件){
    条件成立时执行的代码
}
</code></pre>
<pre><code>if(条件){
    代码块1
}
else{
    代码块2
}
</code></pre>
<pre><code>if(条件1){
    代码块1
}
else if(条件2){
    代码块2
}
...
else {
    代码块n
}
</code></pre>
<pre><code>//小明考了 78 分，60 分以上及格，80 分以上为良好，90 分以上为优秀，60 分以下要重考
public class ScoreJudge {
    public static void main(String[] args){
        int score = 78;
        if(score &gt;= 60){
            if(score &gt;= 80){
                if(score &gt;= 90){
                    System.out.println(&quot;成绩优秀&quot;);
                }
                else{
                    System.out.println(&quot;成绩良好&quot;);
                }
            }
            else{
                System.out.println(&quot;成绩及格&quot;);
            }
        }
        else{
            System.out.println(&quot;需要补考&quot;);
        }
    }
}
</code></pre>
<p><strong>switch语句</strong></p>
<pre><code>switch(表达式){
    case 值1:
        代码块1
        break;
    case 值2:
        代码块2
        break;
    ...
    default:
        默认执行的代码块
}
</code></pre>
<p><strong>while/do-while语句</strong></p>
<pre><code>while(条件){
    代码块
}
</code></pre>
<pre><code>do{
    代码块
}while(条件);
</code></pre>
<p><strong>for语句</strong></p>
<pre><code>for(循环变量初始化①; 循环条件②; 循环变量值操作③){
    循环操作④
}
</code></pre>
<pre><code>//计算 100 以内不能被 3 整除的数之和
    int sum = 0; // 保存不能被3整除的数之和
    // 循环变量 i 初始值为 1 ,每执行一次对变量加 1，只要小于等于 100 就重复执行循环
    for (int i = 1;i&lt;=100;i++) {
    // 变量 i 与 3 进行求模（取余），如果不等于 0 ，则表示不能被 3 整除
        if (i % 3 != 0) {
            sum = sum + i; // 累加求和
        }
    }
    System.out.println(&quot;1到100之间不能被3整除的数之和为：&quot; + sum);
</code></pre>
<p><strong>练习题</strong></p>
<ul>
<li>从控制台输入一行字符串<br>
去除字符串中的所有空格<br>
打印去除空格后的字符串</li>
</ul>
<pre><code>输入：
    shi ya n  lou
输出：
    shiyanlou
</code></pre>
<pre><code>import java.util.Scanner;

public class StringUtil {
    public static void main(String[] args) {
        Scanner in =new Scanner(System.in);
        //获取String值
        String a=in.nextLine();
        StringBuilder stringBuilder = new StringBuilder(a);
        for (int i = 0; i &lt; stringBuilder.length(); i++) {
            if (stringBuilder.charAt(i)==' ') {
                stringBuilder.deleteCharAt(i);
                i--;
            }
        }
        System.out.println(stringBuilder.toString());
    }
}
</code></pre>
<ul>
<li>从控制台输入字符串 a 和字符串 b<br>
比较字符串 a 和字符 b 是否完全一致，长度，内容等完全一致。<br>
如果完全一致，输出相同，如果不一致，输出不同。<br>
禁止使用equals方法</li>
</ul>
<pre><code>输入：
    abc3
    abc3
输出：
    相同
</code></pre>
<pre><code>import java.util.Scanner;

public class ContrastString {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        //获取String值
        String a = in.nextLine();
        String b = in.nextLine();
        if (a.length() != b.length()) {
            System.out.println(&quot;不同&quot;);
            return;
        }
        for (int i = 0; i &lt; a.length(); i++) {
            if (a.charAt(i) != b.charAt(i)) {
                System.out.println(&quot;不同&quot;);
                return;
            }
        }
        System.out.println(&quot;相同&quot;);
    }
}
</code></pre>
<p><strong>跳转语句</strong></p>
<ul>
<li>break 关键字经常用在条件和循环语句中，用来跳出循环语句</li>
<li>continue关键字的作用是跳过循环体中剩余的语句执行下一次循环</li>
</ul>
<pre><code>public class Jump{
    public static void main(String[] args){
        //break 练习
        for(int i = 1; i &lt;= 10; i++){
            System.out.println(&quot;循环第&quot;+i+&quot;次&quot;);
            if(0 == i % 3){
                break;
            }
            if(0 == i % 5){
                System.out.println(&quot;我进来了！&quot;);
            }
        }
        //continue练习 打印10以内的所有奇数
        for(int i = 1; i &lt;= 10; i++){
            if(0 == i % 2) //判断i是否为偶数
                continue;  //通过continue结束本次循环
            System.out.println(i);
        }
    }
}
</code></pre>
<pre><code>$ javac Jump.java
$ java Jump
循环第1次
循环第2次
循环第3次
1
3
5
7
9
</code></pre>
<p><strong>练习题</strong></p>
<ul>
<li>从控制台获取一个整型参数<br>
当输入数字 1 时输出今天是星期一<br>
当输入数字 2 时输出今天是星期二</li>
</ul>
<pre><code>输入：
    1
输出：
    今天是星期一
</code></pre>
<pre><code>import java.util.Scanner;

public class PrintWeek {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        //获取int值
        int x = in.nextInt();
        switch (x) {
            case 1:
                System.out.println(&quot;今天是星期一&quot;);
                break;
            case 2:
                System.out.println(&quot;今天是星期二&quot;);
                break;
            case 3:
                System.out.println(&quot;今天是星期三&quot;);
                break;
            case 4:
                System.out.println(&quot;今天是星期四&quot;);
                break;
            case 5:
                System.out.println(&quot;今天是星期五&quot;);
                break;
            case 6:
                System.out.println(&quot;今天是星期六&quot;);
                break;
            case 7:
                System.out.println(&quot;今天是星期天&quot;);
                break;
        }
    }
}
</code></pre>
<h2 id="数组">数组</h2>
<pre><code>int ages[];      //存放年龄的数组，类型为整型
char symbol[];   //存放符号的数组，类型为字符型
String [] name;  //存放名称的数组，类型为字符串型
</code></pre>
<pre><code>int [] ages = {12,18,9,33,45,60}; //声明并初始化了一个整型数组，它有6个元素
char [] symbol = new char[10] //声明并分配了一个长度为10的char型数组
</code></pre>
<pre><code>ages[0]=12;
</code></pre>
<pre><code>int [] a1 = {1,2,3};
int [] a2;
a2 = a1;
</code></pre>
<ul>
<li>a2 和 a1 是相同数组的不同名称</li>
</ul>
<pre><code>public class Test {
    public static void main(String[] args) {
        int [] a1 = {1,2,3};
        int [] a2;
        a2 = a1;
        for(int i = 0; i &lt; a2.length; i++){
            a2[i]++;
        }
        for(int i = 0; i &lt; a1.length; i++){
            System.out.println(a1[i]);
        }
    }
}
</code></pre>
<pre><code>$ javac Test.java
$ java Test
2
3
4
</code></pre>
<p><strong>数组遍历</strong></p>
<pre><code>int [] ages = {12, 18, 9, 33, 45, 60};
for(int i = 0; i &lt; ages.length; i++){ //ages.length是获取数组的长度
    System.out.println(&quot;数组中第&quot;+(i+1)+&quot;个元素是 &quot;+ages[i]); //数组下标是从零开始，一定要注意
}
</code></pre>
<ul>
<li>foreach</li>
</ul>
<pre><code>for(元素类型 元素变量:遍历对象){
    执行的代码
}
</code></pre>
<pre><code>public class JudgePrime {
    public static void main(String[] args){
        int [] ages = {12, 18, 9, 33, 45, 60};
        int i = 1;
        for(int age:ages){
            System.out.println(&quot;数组中第&quot;+i+&quot;个元素是&quot;+age);
            i++;
        }
    }
}
</code></pre>
<pre><code>$ javac JudgePrime.java
$ java JudgePrime
数组中第1个元素是12
数组中第2个元素是18
数组中第3个元素是9
数组中第4个元素是33
数组中第5个元素是45
数组中第6个元素是60
</code></pre>
<p><strong>二维数组</strong></p>
<pre><code>public class ArrayTest {
    public static void main(String[] args) {
        String[][] name = {{&quot;ZhaoYi&quot;, &quot;QianEr&quot;, &quot;SunSan&quot;},
                {&quot;LiSi&quot;, &quot;ZhouWu&quot;, &quot;WuLiu&quot;}};
        for (int i = 0; i &lt; 2; i++) {
            for (int j = 0; j &lt; 3; j++) {
                System.out.println(name[i][j]);
            }
        }
    }
}
</code></pre>
<pre><code>$ javac ArrayTest.java
$ java ArrayTest
ZhaoYi
QianEr
SunSan
LiSi
ZhouWu
WuLiu
</code></pre>
<p><strong>练习题</strong><br>
有一份成绩单，上面有 10 位学生的成绩（61，57，95，85，75，65，44，66，90，32），请求出平均成绩并输出</p>
<ul>
<li>将 10 位同学的成绩保存在数组中</li>
</ul>
<pre><code>public class AverageScore {
    public static void main(String[] args) {
        int[] data = {61, 57, 95, 85, 75, 65, 44, 66, 90, 32};
        int sum = 0;
        for (int i = 0; i &lt; data.length; i++) {
            sum += data[i];
        }
        System.out.println(&quot;平均成绩：&quot; + sum / data.length);
    }
}
</code></pre>
<h2 id="用户输入操作">用户输入操作</h2>
<pre><code>import java.util.Scanner;

public class ScannerDemo {
    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        //获取用户输入的一行数据  返回为字符串
        String s = in.nextLine();
        System.out.println(s);
        //循环读取String数据，当输入exit时退出循环
        while (!in.hasNext(&quot;exit&quot;)) {
            System.out.println(in.nextLine());
        }
        //关闭输入
        in.close();
    }
}
</code></pre>
<pre><code>shiyanlou
shiyanlou
aa
aa
bbb
bbb
cc
cc
exit
</code></pre>
<p><strong>练习题</strong></p>
<ul>
<li>获取用户的输入信息（字符串）<br>
当用户输入 end 时，结束输入并打印用户之前输入的所有信息（输入的信息数量不超过 100 个）</li>
</ul>
<pre><code>输入：
    shi
    yan
    lou
    end
输出：
    shi
    yan
    lou
</code></pre>
<pre><code>import java.util.Scanner;

public class InputTest {
    public static void main(String[] args) {
        String[] data = new String[100];
        Scanner in = new Scanner(System.in);
        for (int i = 0; i &lt; 100; i++) {
            if ((data[i] = in.nextLine()).equals(&quot;end&quot;)) {
                break;
            }
        }
        for (String a : data) {
            if (a.equals(&quot;end&quot;)) {
                break;
            }
            System.out.println(a);
        }
    }
}
</code></pre>
<h2 id="练习题">练习题</h2>
<ul>
<li>现给出一串数据（313, 89, 123, 323, 313, 15, 90, 56, 39）求出最大值和最小值并输出</li>
</ul>
<pre><code>import java.util.Arrays;

public class MaxAndMin {
    public static void main(String[] args) {
        int[] data = {313, 89, 123, 323, 313, 15, 90, 56, 39};
        //    方法1
        int max = data[0];
        int min = data[0];
        for (int i = 0; i &lt; data.length; i++) {
            if (data[i] &gt; max) {
                max = data[i];
            }
            if (data[i] &lt; min) {
                min = data[i];
            }
        }
        System.out.println(min);
        System.out.println(max);
        //方法二
        //Arrays.sort(data);
        //System.out.println(data[0]);
        //System.out.println(data[data.length - 1]);
        //方法三
        //System.out.println(Arrays.stream(data).min().getAsInt());
        //System.out.println(Arrays.stream(data).max().getAsInt());
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python]]></title>
        <id>https://y-rui.github.io/post/python/</id>
        <link href="https://y-rui.github.io/post/python/">
        </link>
        <updated>2020-05-08T15:28:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="逢7就跳过">逢7就跳过</h2>
<ul>
<li>while</li>
</ul>
<pre><code>a = 0
while a &lt; 100:
    a = a + 1
    if a % 7 == 0 or a % 10 == 7 or a // 10 == 7:
        continue
    else:
        print(a)
</code></pre>
<ul>
<li>for</li>
</ul>
<pre><code>for a in range(1,101):
    if a % 7 == 0 or a % 10 == 7 or a // 10 == 7:
        continue
    else:
        print(a)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jupyter Notebook 快捷键]]></title>
        <id>https://y-rui.github.io/post/jupyter-notebook-kuai-jie-jian/</id>
        <link href="https://y-rui.github.io/post/jupyter-notebook-kuai-jie-jian/">
        </link>
        <updated>2020-05-08T10:18:30.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><code>B</code>：在当前单元格下方新建空白单元格。</li>
<li><code>M</code>：将单元格格式转换为 Markdown。</li>
<li><code>Y</code>：将单元格格式转换为 Code。</li>
<li>连续按 <code>D</code>+<code>D</code>：删除当前单元格。（慎用，推荐使用 X 剪切单元格代替，因为其可以起到删除效果，且删错了还可以粘贴回来）</li>
<li><code>Shift + Enter</code>：运行当前单元格内容。（当 Markdown 单元格处于编辑状态时，运行即可复原）</li>
<li><code>Tab</code>: 代码补全</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[新手入门-Linux桌面环境使用]]></title>
        <id>https://y-rui.github.io/post/xin-shou-ru-men-linux-zhuo-mian-huan-jing-shi-yong/</id>
        <link href="https://y-rui.github.io/post/xin-shou-ru-men-linux-zhuo-mian-huan-jing-shi-yong/">
        </link>
        <updated>2020-05-07T02:03:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-打开终端">1. 打开终端</h2>
<pre><code>cd Code
//进入Code文件夹
touch hello_shiyanlou.c
//创建hello_shiyanlou.c文件
</code></pre>
<h2 id="2-输入c语言代码">2. 输入C语言代码</h2>
<pre><code>gedit hello_shiyanlou.c
//用gedit编辑器将hello_shiyanlou.c文件打开
</code></pre>
<p>在gedit里面输入以下代码</p>
<pre><code>#include&lt;stdio.h&gt;
int main()
{
    printf(&quot;Hello,Shiyanlou.&quot;);
    return 0;
}
</code></pre>
<h2 id="3-编译程序">3. 编译程序</h2>
<pre><code>gcc -o hello_shiyanlou hello_shiyanlou.c
//编译hello_shiyanlou.c程序并且生成hello_shiyanlou文件
</code></pre>
<h2 id="4-执行程序">4. 执行程序</h2>
<pre><code>./hello_shiyanlou
//执行hello_shiyanlou程序
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://y-rui.github.io/post/hello-gridea/</id>
        <link href="https://y-rui.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>