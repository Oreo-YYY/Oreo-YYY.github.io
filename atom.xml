<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://y-rui.github.io</id>
    <title>NoteForStudy</title>
    <updated>2020-12-30T16:54:51.285Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://y-rui.github.io"/>
    <link rel="self" href="https://y-rui.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://y-rui.github.io/images/avatar.png</logo>
    <icon>https://y-rui.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, NoteForStudy</rights>
    <entry>
        <title type="html"><![CDATA[MacOS下MySQL8.0忘记密码充值操作]]></title>
        <id>https://y-rui.github.io/post/macos-xia-mysql80-wang-ji-mi-ma-chong-zhi-cao-zuo/</id>
        <link href="https://y-rui.github.io/post/macos-xia-mysql80-wang-ji-mi-ma-chong-zhi-cao-zuo/">
        </link>
        <updated>2020-12-30T16:40:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="关闭数据库服务">关闭数据库服务</h2>
<h2 id="跳过权限认证">跳过权限认证</h2>
<pre><code>// 进入数据库指令文件
cd /usr/local/mysql/bin
// 跳过权限认证
sudo ./mysqld_safe --skip-grant-tables
</code></pre>
<h2 id="免密码进入数据库">免密码进入数据库</h2>
<p>在上述指令运行后，新开一个终端，同时保持原来那个终端也开着，在新的终端输入指令如下：</p>
<pre><code>//  执行mysql指令
/usr/local/mysql/bin/mysql
// 进入名为&lt;mysql&gt;的数据库
use mysql
// 刷新权限
flush privileges;
// 修改密码 但不适用于8.0+的版本
// set password for 'root'@'localhost' = password('新的密码');
// 8.0+版本修改密码
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'root123456';

// 退出mysql
exit
</code></pre>
<h2 id="配置环境变量">配置环境变量</h2>
<p>vi ~/.zshrc，在这里面添加：</p>
<p>export PATH=${PATH}:/usr/local/mysql/bin</p>
<p>保存后 source ~/.zshrc</p>
<h2 id="mac-navicat-出现-2003-cant-connect-to-mysql-server-on-127001-61-connection-refused">Mac Navicat 出现 2003 - Can't connect to MySQL server on '127.0.0.1' (61 &quot;Connection refused&quot;)</h2>
<ol>
<li>
<p>首先找到你的数据库鼠标右键编辑链接；</p>
</li>
<li>
<p>找到第二个选项勾选上 useSockt file;</p>
</li>
</ol>
<h2 id="命令行中停止mysql服务">命令行中停止mysql服务</h2>
<pre><code>sudo /usr/local/mysql/bin/mysqladmin -u root -p root123456 shutdown
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hadoop基础1-Hadoop 介绍与安装]]></title>
        <id>https://y-rui.github.io/post/hadoop-ji-chu-1-hadoop-jie-shao-yu-an-zhuang/</id>
        <link href="https://y-rui.github.io/post/hadoop-ji-chu-1-hadoop-jie-shao-yu-an-zhuang/">
        </link>
        <updated>2020-12-20T13:06:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="hadoop-介绍">Hadoop 介绍</h2>
<ul>
<li>Apache Hadoop 软件库是一个框架，允许在集群服务器上使用简单的编程模型对大数据集进行分布式处理。Hadoop 被设计成能够从单台服务器扩展到数以千计的服务器，每台服务器都有本地的计算和存储资源。Hadoop 的高可用性并不依赖硬件，其代码库自身就能在应用层侦测并处理硬件故障，因此能基于服务器集群提供高可用性的服务</li>
</ul>
<h2 id="hadoop-生态系统">Hadoop 生态系统</h2>
<p>经过多年的发展形成了 Hadoop1.X 生态系统，其结构如下图所示<br>
<img src="https://y-rui.github.io/post-images/1608469835785.png" alt="" loading="lazy"></p>
<ul>
<li>HDFS：Hadoop 生态圈的基本组成部分是 Hadoop 分布式文件系统（HDFS）。HDFS 是一种分布式文件系统，数据被保存在计算机集群上，HDFS 为 HBase 等工具提供了基础</li>
<li>MapReduce：Hadoop 的主要执行框架是 MapReduce，它是一个分布式、并行处理的编程模型，MapReduce 把任务分为 map（映射）阶段和 reduce（化简）阶段。由于 MapReduce 工作原理的特性，Hadoop 能以并行的方式访问数据，从而实现快速访问数据</li>
<li>Hbase：HBase 是一个建立在 HDFS 之上，面向列的 NoSQL 数据库，用于快速读 / 写大量数据，HBase 使用 Zookeeper 进行管理</li>
<li>Zookeeper：用于 Hadoop 的分布式协调服务。Hadoop 的许多组件依赖于 Zookeeper，它运行在计算机集群中，用于管理 Hadoop 集群</li>
<li>Pig：它是 MapReduce 编程的复杂性的抽象。Pig 平台包括运行环境和用于分析 Hadoop 数据集的脚本语言 (Pig Latin)，其编译器将 Pig Latin 翻译成 MapReduce 程序序列</li>
<li>Hive：类似于 SQL 高级语言，用于运行存储在 Hadoop 上的查询语句，Hive 让不熟悉 MapReduce 的开发人员也能编写数据查询语句，然后这些语句被翻译为 Hadoop 上面的 MapReduce 任务。像 Pig 一样，Hive 作为一个抽象层工具，吸引了很多熟悉 SQL 而不是 Java 编程的数据分析师</li>
<li>Sqoop：一个连接工具，用于在关系数据库、数据仓库和 Hadoop 之间转移数据。Sqoop 利用数据库技术描述架构，进行数据的导入 / 导出；利用 MapReduce 实现并行化运行和容错技术</li>
<li>Flume：提供了分布式、可靠、高效的服务，用于收集、汇总大数据，并将单台计算机的大量数据转移到 HDFS。它基于一个简单而灵活的架构，利用简单的可扩展的数据模型，将企业中多台计算机上的数据转移到 Hadoop 中</li>
</ul>
<h2 id="apache-版本衍化">Apache 版本衍化</h2>
<ul>
<li>Apache Hadoop 版本分为两代，我们将第一代 Hadoop 称为 Hadoop 1.0，第二代 Hadoop 称为 Hadoop 2.0</li>
<li>第一代 Hadoop 包含三个大版本，分别是 0.20.x，0.21.x 和 0.22.x。其中，0.20.x 最后演化成 1.0.x，变成了稳定版，而 0.21.x 和 0.22.x 则包括 NameNode HA 等新的重大特性</li>
<li>第二代 Hadoop 包含两个版本，分别是 0.23.x 和 2.x，它们完全不同于 Hadoop 1.0，是一套全新的架构，均包含 HDFS Federation 和 YARN 两个系统，相比于 0.23.x，2.x 增加了 NameNode HA 和 Wire-compatibility 两个重大特性</li>
</ul>
<h2 id="hadoop1x-伪分布安装">Hadoop1.X 伪分布安装</h2>
<p>Hadoop 安装有如下三种方式</p>
<ul>
<li>单机模式：安装简单，几乎不用做任何配置，但仅限于调试用途</li>
<li>伪分布模式：在单节点上同时启动 NameNode、DataNode、JobTracker、TaskTracker、Secondary Namenode 等 5 个进程，模拟分布式运行的各个节点</li>
<li>完全分布式模式：正常的 Hadoop 集群，由多个各司其职的节点构成</li>
</ul>
<p><strong>软硬件环境说明</strong></p>
<ul>
<li>节点使用 CentOS 系统，防火墙和 SElinux 需要禁用，创建了一个 shiyanlou 用户，并在系统根目录下创建 /app 目录，用于存放 Hadoop 等组件运行包。由于该目录用于安装 hadoop 等组件程序，用户对 shiyanlou 必须赋予 rwx 权限（一般做法是 root 用户在根目录下创建 /app 目录，并修改该目录拥有者为 shiyanlou(chown –R shiyanlou:shiyanlou /app)</li>
</ul>
<p><strong>Hadoop 搭建环境</strong></p>
<ul>
<li>虚拟机操作系统：CentOS6.6 64 位，单核，1G 内存</li>
<li>JDK：1.7.0_55 64 位</li>
<li>Hadoop：1.1.2</li>
</ul>
<p><strong>环境搭建</strong><br>
配置本地环境</p>
<p>设置机器名<br>
使用 sudo vi /etc/sysconfig/network<br>
打开配置文件，根据实际情况设置该服务器的机器名，新机器名在重启后生效</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring框架基础1-概述]]></title>
        <id>https://y-rui.github.io/post/spring-kuang-jia-ji-chu-1-gai-shu/</id>
        <link href="https://y-rui.github.io/post/spring-kuang-jia-ji-chu-1-gai-shu/">
        </link>
        <updated>2020-09-01T12:24:16.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>本节课程将介绍什么是 Spring。Spring 是一个容器，通过反转控制（IoC）和依赖注入（DI）来实现高内聚、低耦合的应用。除此之外它可以整合很多第三方框架，它还提供面向切面编程（AOP）的能力，对数据库事务的管理尤其方便。</li>
</ul>
<h2 id="spring-是什么">Spring 是什么</h2>
<p>Spring 是一个开源的轻量级 Java SE（Java 标准版本）/Java EE（Java 企业版本）开发应用框架，其目的是用于简化企业级应用程序开发。在传统应用程序开发中，一个完整的应用是由一组相互协作的对象组成的。所以开发一个应用除了要开发业务逻辑之外，最多的是关注使这些对象协作来完成所需功能的同时，实现低耦合、高内聚。所以，业务逻辑开发是不可避免的。如果有个框架可以帮我们来创建对象及管理这些对象之间的依赖关系，能通过配置方式来创建对象，管理对象之间依赖关系，我们不需要通过工厂和生成器来创建及管理对象之间的依赖关系，这样我们必然会减少许多工作量，加快开发。Spring 框架问世之初主要就是来完成这个功能。</p>
<p>Spring 框架除了帮我们管理对象及其依赖关系，还提供像通用日志记录、性能统计、安全控制、异常处理等面向切面的能力，可以帮我们管理最头疼的数据库事务，同时，它本身提供了一套简单的 JDBC 访问实现，能与第三方数据库访问框架集成（如 Hibernate、JPA），与各种 Java EE 技术整合（如 Java Mail、任务调度等等），提供一套自己的 Web 层框架 Spring MVC、而且还能非常简单的与第三方 Web 框架集成。从这里我们可以认为 Spring 是一个超级粘合平台，除了自己提供功能外，还提供粘合其他技术和框架的能力，从而使我们可以更自由的选择到底使用什么技术进行开发。而且不管是 JAVA SE（C/S 架构）应用程序还是 JAVA EE（B/S 架构）应用程序都可以使用这个平台进行开发。让我们来深入看一下 Spring 到底能帮我们做些什么？</p>
<h2 id="spring-能帮我们做什么">Spring 能帮我们做什么</h2>
<p><strong>Spring 能帮我们根据配置文件创建及组装对象之间的依赖关系</strong><br>
传统程序开发，创建对象及组装对象间依赖关系由我们在程序内部进行控制，这样会加大各个对象间的耦合，如果我们要修改对象间的依赖关系就必须修改源代码，重新编译、部署。而如果采用 Spring，则由 Spring 根据配置文件来进行创建及组装对象间依赖关系，只需要修改配置文件即可，无需重新编译。</p>
<p><strong>Spring 面向切面编程能帮助我们无耦合的实现日志记录、性能统计、安全控制</strong><br>
当我们要进行一些日志记录、权限控制、性能统计等工作时，在传统应用程序当中我们可能在需要的对象或方法中进行，而且比如权限控制、性能统计大部分是重复的，这样代码中就存在大量重复代码，即使把通用部分提取出来，仍旧存在重复调用。</p>
<p>像性能统计我们可能只是在必要时才进行，在诊断完毕后要删除这些代码；还有日志记录，比如记录一些方法访问日志、数据访问日志等等，这些都会渗透到各个访问方法中；还有权限控制，必须在方法执行时开始进行审核，可见这些工作急需优化。如果采用 Spring，这些日志记录、权限控制、性能统计从业务逻辑中分离出来，通过 Spring 支持的面向切面编程，动态添加这些功能，无需渗透到各个需要的方法或对象中。</p>
<p>反观其他的解决方案，通过使用“代理设计模式”或“包装器设计模式”，仍需通过编程方式来创建代理对象，仍需耦合这些代理对象，而采用 Spring 面向切面编程能提供一种更好的方式来完成上述功能。通过配置方式，而不需要在现有代码中添加任何额外代码，使现有代码专注业务逻辑。</p>
<p><strong>Spring 能非常简单的帮我们管理数据库事务</strong><br>
在传统应用程序当中，我们如何来完成数据库事务管理？需要一系列“获取连接，执行 SQL，提交或回滚事务，关闭连接”，而且还要保证在最后一定要关闭连接，多么可怕的事情，而且也很无聊。如果采用 Spring，我们只需获取连接，执行 SQL，其他的都交给 Spring 来管理，简单方便。</p>
<p><strong>除以上之外，Spring 还可以：</strong></p>
<ul>
<li>与第三方数据库访问框架（如 Hibernate、JPA）无缝集成，而且自己也提供了一套 JDBC 访问模板，来方便数据库访问。</li>
<li>与第三方 Web（如 Struts、JSF）框架无缝集成，而且自己也提供了一套 Spring MVC 框架，来方便 Web 层搭建。</li>
<li>与 Java EE（如 Java Mail、任务调度）整合，与更多技术整合（比如缓存框架）。</li>
</ul>
<h2 id="spring-的优点">Spring 的优点</h2>
<p><strong>关键概念</strong></p>
<ul>
<li>应用程序：能完成我们所需要功能的成品，比如购物网站、OA 系统。</li>
<li>框架：能完成一定功能的半成品，比如我们可以使用框架进行购物网站开发。框架做一部分功能，我们自己做一部分功能，辅助高效工作。而且框架规定了你在开发应用程序时的整体架构，提供了一些基础功能，还规定了类和对象的如何创建、如何协作等，从而简化我们的代码编写，让我们专注于业务逻辑开发。</li>
<li>非侵入式设计：从框架角度可以这样理解，无需继承框架提供的类，这种设计就可以看作是非侵入式设计；如果继承了这些框架类，就是侵入设计。如果以后想更换框架，之前写过的代码几乎无法重用，如果非侵入式设计则之前写过的代码仍然可以继续使用。</li>
<li>轻量级与重量级：轻量级是相对于重量级而言的，轻量级一般就是非入侵性的、所依赖的东西非常少、资源占用非常少、部署简单等等，其实就是比较容易使用，而重量级正好相反。</li>
<li>POJO：Plain Ordinary Java Object，简单的 Java 对象。它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其它 Java 框架的类或接口。</li>
<li>容器：在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是装对象的对象，因为存在放入、拿出等操作，所以容器还要管理对象的生命周期。</li>
<li>控制反转：即 Inversion of Control，缩写为 IoC，控制反转还有一个名字叫做依赖注入（Dependency Injection），就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。</li>
<li>Bean：一般指容器管理对象，在 Spring 中指 Spring IoC 容器管理对象。</li>
</ul>
<p><strong>Spring 的优点</strong></p>
<ul>
<li>非常轻量级的容器：以集中的、自动化的方式进行应用程序对象创建和装配，除此之外还会负责管理对象生命周期，能组合成复杂的应用程序。Spring 容器是非侵入式的（不需要依赖任何 Spring 特定类），而且完全采用 POJOs 进行开发，使应用程序更容易测试、更容易管理。而且核心 jar 包非常小，Spring 3.0.5 不到 1 M，而且不需要依赖任何应用服务器，可以部署在任何环境（Java SE 或 Java EE）。</li>
<li>AOP：AOP 是 Aspect Oriented Programming 的缩写，意思是面向切面编程。从另一个角度来考虑程序结构以完善面向对象编程（OOP），<em>即可以通过在编译期间、装载期间或运行期间实现在不修改源代码的情况下给程序动态添加功能的一种技术</em>。通俗点说就是把可重用的功能提取出来，然后将这些通用功能在合适的时候织入到应用程序中。比如安全，日志记录，这些都是通用的功能，我们可以把它们提取出来，然后在程序执行的合适地方植入这些代码并执行它们，从而完成需要的功能并复用了这些功能。</li>
<li>简单的数据库事务管理：在使用数据库的应用程序当中，自己管理数据库事务是一项很让人头疼的事，而且很容易出现错误，Spring 支持可插入的事务管理支持，而且无需 JavaEE 环境支持，通过 Spring 管理事务可以把我们从事务管理中解放出来来专注业务逻辑。</li>
<li>JDBC 抽象及 ORM（对象关系映射）框架支持：Spring 使 JDBC 更加容易使用。提供 DAO（数据访问对象）支持，非常方便集成第三方 ORM 框架，比如 Hibernate 等。并且完全支持 Spring 事务和使用 Spring 提供的一致的异常体系。</li>
<li>灵活的 Web 层支持：Spring 本身提供一套非常强大的 MVC 框架，而且可以非常容易的与第三方 MVC 框架集成，比如 Struts 等。</li>
<li>简化各种技术集成：提供对 Java Mail、任务调度、JMX、JMS、JNDI、EJB、动态语言、远程访问、Web Service 等的集成。</li>
</ul>
<p>Spring 能帮助我们简化应用程序开发，帮助我们创建和组装对象，为我们管理事务，简单的 MVC 框架，可以把 Spring 看作是一个超级粘合平台，能把很多技术整合在一起，形成一个整体，使系统结构更优良、性能更出众，从而加速我们程序开发。有如上优点，我们没有理由不考虑使用它。</p>
<h2 id="如何学好-spring">如何学好 Spring</h2>
<p>要学好 Spring，首先要明确 Spring 是个什么东西，能帮我们做些什么事情，知道了这些然后做个简单的例子，这样就基本知道怎么使用 Spring 了。Spring 核心是 IoC 容器，所以一定要透彻理解什么是控制反转（IoC）容器，以及如何配置及使用容器，其他所有技术都是基于容器实现的。理解好 IoC 后，接下来是面向切面编程（AOP），首先还是明确概念，基本配置，最后是实现原理，接下来就是数据库事务管理。其实 Spring 管理事务是通过面向切面编程实现的，所以基础很重要，IoC 容器和 AOP 学好，其余都是基于这两个核心东西的实现，学起来就更加轻松了。</p>
<h2 id="spring-架构图">Spring 架构图</h2>
<figure data-type="image" tabindex="1"><img src="https://y-rui.github.io/post-images/1608771232334.png" alt="" loading="lazy"></figure>
<p><strong>核心容器：包括 Core、Beans、Context、EL 模块</strong></p>
<ul>
<li>Core 模块：封装了框架依赖的最底层部分，包括资源访问、类型转换及一些常用工具类。</li>
<li>Beans 模块：提供了框架的基础部分，包括控制反转（IOC）和依赖注入（DI）。其中 BeanFactory 是容器核心，本质是“工厂设计模式”的实现，而且无需编程实现“单例设计模式”，单例完全由容器控制，而且提倡面向接口编程，而非面向实现编程。所有应用程序对象及对象间关系由框架管理，从而真正从程序逻辑中把维护对象之间的依赖关系提取出来，所有这些依赖关系都由 BeanFactory 来维护。</li>
<li>Context 模块：以 Core 和 Beans 为基础，集成 Beans 模块功能并添加资源绑定、数据验证、国际化、Java EE 支持、容器生命周期、事件传播等。核心接口是 ApplicationContext。</li>
<li>EL 模块：提供强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从 Spring 容器获取 Bean，它也支持列表投影、选择和一般的列表聚合等。</li>
</ul>
<p><strong>AOP、Aspects 模块</strong></p>
<ul>
<li>AOP 模块：Spring AOP 模块提供了符合 AOP Alliance 规范的面向切面的编程（aspect-oriented programming）实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中，这样各专其职，降低业务逻辑和通用功能的耦合。</li>
<li>Aspects 模块：提供了对 AspectJ 的集成，AspectJ 提供了比 Spring ASP 更强大的功能。</li>
<li>数据访问/集成模块：该模块包括了 JDBC、ORM、OXM、JMS 和事务管理。</li>
<li>事务模块：该模块用于 Spring 管理事务，只要是 Spring 管理对象都能得到 Spring 管理事务的好处，无需在代码中进行事务控制了，而且支持编程和声明性的事务管理。</li>
<li>JDBC 模块：提供了一个 JDBC 的样例模板，使用这些模板能消除传统冗长的 JDBC 编码还有必须的事务控制，而且能享受到 Spring 管理事务的好处。</li>
<li>ORM 模块：提供与流行的“对象-关系”映射框架的无缝集成，包括 Hibernate、JPA、MyBatis 等。而且可以使用 Spring 事务管理，无需额外控制事务。</li>
<li>OXM 模块：提供了一个对 Object/XML 映射实现，将 java 对象映射成 XML 数据，或者将 XML 数据映射成 java 对象，Object/XML 映射实现包括 JAXB、Castor、XMLBeans 和 XStream。</li>
<li>JMS 模块：用于 JMS（Java Messaging Service），提供一套“消息生产者、消息消费者”模板用于更加简单的使用 JMS。JMS 用于用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</li>
<li>Web/Remoting 模块：Web/Remoting 模块包含了 Web、Web-Servlet、Web-Struts、Web-Porlet 模块。</li>
<li>Web 模块：提供了基础的 Web 功能。例如多文件上传、集成 IoC 容器、远程过程访问（RMI、Hessian、Burlap）以及 Web Service 支持，并提供一个 RestTemplate 类来提供方便的 Restful services 访问。</li>
<li>Web-Servlet 模块：提供了一个 Spring MVC Web 框架实现。Spring MVC 框架提供了基于注解的请求资源注入、更简单的数据绑定、数据验证等及一套非常易用的 JSP 标签，完全无缝与 Spring 其他技术协作。</li>
<li>Web-Struts 模块：提供了与 Struts 无缝集成，Struts 1.x 和 Struts 2.x 都支持。</li>
<li>Test 模块：Spring 支持 Junit 和 TestNG 测试框架，而且还额外提供了一些基于 Spring 的测试功能，比如在测试 Web 框架时，模拟 Http 请求的功能。</li>
</ul>
<h2 id="典型应用场景">典型应用场景</h2>
<p>Spring 可以应用到许多场景，从最简单的标准 Java SE 程序到企业级应用程序都能使用 Spring 来构建。以下介绍几个比较流行的应用场景：</p>
<ul>
<li>典型 Web 应用程序应用场景：</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://y-rui.github.io/post-images/1608771369230.png" alt="" loading="lazy"></figure>
<ul>
<li>远程访问应用场景：</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://y-rui.github.io/post-images/1608771390589.png" alt="" loading="lazy"></figure>
<ul>
<li>EJB 应用场景：</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://y-rui.github.io/post-images/1608771414258.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础13-设计模式]]></title>
        <id>https://y-rui.github.io/post/java-ji-chu-13-she-ji-mo-shi/</id>
        <link href="https://y-rui.github.io/post/java-ji-chu-13-she-ji-mo-shi/">
        </link>
        <updated>2020-08-30T12:07:36.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。本节主要介绍中介模式、代理模式、责任模式。</li>
</ul>
<h2 id="中介模式">中介模式</h2>
<p><strong>简介</strong></p>
<ul>
<li>定义了一个对象，该对象封装了一组对象的交互方式。对象之间的通信将封装在中介对象中。对象不再直接相互通信，而是通过中介进行通信。这减少了通信对象之间的依赖性，从而减少了耦合。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>避免一组交互对象之间的紧密耦合。</li>
<li>可以独立地改变一组对象之间的交互。</li>
</ul>
<p><strong>类图</strong><br>
对应中介对象来说，互相交互的对象叫做同事类，中介者对象维护同事类之间的关系，中介对象需要知道所有同事对象，所以也会带来一个问题，当同事类过多时，中介者类将异常复杂。<br>
<img src="https://y-rui.github.io/post-images/1608725370862.png" alt="" loading="lazy"></p>
<ol>
<li>Mediator：抽象中介类，用于与各同事对象之间进行通信。</li>
<li>ConcreteMediator：具体中介类，协调各同事类。</li>
<li>Colleague：抽象同事类。</li>
<li>ConcreteColleague：具体同事类。</li>
</ol>
<p><strong>编程实战</strong><br>
比如我们要实现一个聊天室的功能，聊天室就是中介，而聊天的人就是一个同事类，发送的每个消息都由聊天室转发给其他人。</p>
<p>在 /home/project 目录下新建以下文件<br>
AbstractChatRoom.java（Mediator）：</p>
<pre><code>public abstract class AbstractChatRoom {
    public abstract void notice(String message, User user);
}
</code></pre>
<p>ChatRoom.java(ConcreteMediator)：</p>
<pre><code>import java.util.ArrayList;
import java.util.List;


public class ChatRoom extends AbstractChatRoom {
    private List&lt;User&gt; users = new ArrayList&lt;&gt;();

    public void register(User user) {
        users.add(user);
    }
    @Override
    public void notice(String message, User user) {
        for (User u : users) {
            if (u != user) {
                u.getMessage(message);
            }
        }
    }
}
</code></pre>
<p>User.java(Colleague)。</p>
<pre><code>public abstract class User {
    protected AbstractChatRoom chatRoom;

    public User(AbstractChatRoom chatRoom) {
        this.chatRoom = chatRoom;
    }

    /**
     * 发送消息
     *
     * @param msg
     */
    public abstract void sendMessage(String msg);

    /**
     * 接受消息
     *
     * @param msg
     */
    public abstract void getMessage(String msg);
}
</code></pre>
<p>UserA.java(ConcreteColleague)：</p>
<pre><code>public class UserA extends User {
    public UserA(AbstractChatRoom chatRoom) {
        super(chatRoom);
    }

    @Override
    public void sendMessage(String msg) {
        System.out.println(&quot;用户A发送 &quot; + msg);
        chatRoom.notice(msg, this);
    }

    @Override
    public void getMessage(String msg) {
        System.out.println(&quot;用户A收到 &quot; + msg);
    }
}
</code></pre>
<p>UserB.java(ConcreteColleague)：</p>
<pre><code>public class UserB extends User {
    public UserB(AbstractChatRoom chatRoom) {
        super(chatRoom);
    }

    @Override
    public void sendMessage(String msg) {
        System.out.println(&quot;用户B发送 &quot; + msg);
        chatRoom.notice(msg, this);
    }

    @Override
    public void getMessage(String msg) {
        System.out.println(&quot;用户B收到 &quot; + msg);
    }
}
</code></pre>
<p>Client.java：</p>
<pre><code>public class Client {
    public static void main(String[] args) {
        ChatRoom chatRoom = new ChatRoom();
        UserA userA = new UserA(chatRoom);
        UserB userB = new UserB(chatRoom);
        chatRoom.register(userA);
        chatRoom.register(userB);
        userA.sendMessage(&quot;你好！&quot;);
        userB.sendMessage(&quot;再见！&quot;);
    }
}
</code></pre>
<p>编译运行：</p>
<pre><code>javac Client.java
java Clent
用户A发送 你好！
用户B收到 你好！
用户B发送 再见！
用户A收到 再见！
</code></pre>
<h2 id="代理模式">代理模式</h2>
<p><strong>简介</strong></p>
<ul>
<li>代理模式：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>隐藏原始对象并控制对象的访问。</li>
<li>访问对象时提供其他的功能。</li>
</ul>
<p><strong>类图</strong><br>
<img src="https://y-rui.github.io/post-images/1608725558580.png" alt="" loading="lazy"><br>
说明：</p>
<ul>
<li>Subject: 一个客户端可用的公开的功能接口。</li>
<li>RealSubject：实现 Subject 接口的类，提供了接口方法的具体实现。</li>
<li>Proxy：实现 Subject 接口的代理类，通过 RealSubject 类的业务逻辑方法来实现抽象方法，可以附加自己的操作。</li>
</ul>
<p><strong>编程实战</strong><br>
假设我们需要建设一栋楼房，但是建设之前我们需要购买原材料（如水泥...)，接着才可以开始建设，楼房主体建设完成后，还需要封顶操作。</p>
<p>在 /home/project/ 目录下新建以下文件<br>
LouSubject.java：</p>
<pre><code>public interface LouSubject{
    void build();
}
</code></pre>
<p>LouRealSubject.java：</p>
<pre><code>public class LouRealSubject implements LouSubject{
    @Override
    public void build(){
        System.out.println(&quot;建设实验楼&quot;);
    }
}
</code></pre>
<p>LouProxy.java：</p>
<pre><code>public class LouProxy implements LouSubject{
    private LouSubject target;
    public LouProxy(){
        this.target = new LouRealSubject();
    }
    @Override
    public void build(){
        System.out.println(&quot;购买材料&quot;);
        target.build();
        System.out.println(&quot;封顶&quot;);
    }
}
</code></pre>
<p>LouClient.java</p>
<pre><code>public class LouClient{
    public static void main(String[] args){
        LouSubject proxy = new LouProxy();
        proxy.build();
    }
}
</code></pre>
<p>编译运行：</p>
<pre><code>javac LouClient.java
java LouClient
购买材料
建设实验楼
封顶
</code></pre>
<h2 id="责任链模式">责任链模式</h2>
<ul>
<li>责任链模式是一种由命令对象源和一系列处理对象组成的设计模式。每个处理对象都包含定义它可以处理的命令对象类型的逻辑；其余的传递给链中的下一个处理对象。还存在一种机制，用于将新处理对象添加到该链的末尾。责任链模式在结构上与装饰器模式几乎相同，不同之处在于对于装饰器，所有类都处理请求，而对于责任链，链中的一个类恰好处理请求。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>避免将请求的发送方与其接收方耦合。</li>
<li>可以使用多个接收器处理请求。</li>
</ul>
<p><strong>类图</strong><br>
<img src="https://y-rui.github.io/post-images/1608725688081.png" alt="" loading="lazy"><br>
handler：抽象处理者。<br>
ConcreteHandler：具体处理者，接受到请求后，可以选择处理请求或者传递给下一个处理者。</p>
<p><strong>编程实战</strong><br>
假设我们有一个请假系统，不同的职位可以处理不同的请假请求，比如：<br>
组长：可以处理两天以内的请求<br>
厂长：可以处理七天以内的请求<br>
老板：可以处理十五天以内的请求<br>
如果组长可以处理，那么就直接处理了，如果组长不可以处理，那么我们再继续往下传递。</p>
<p>在 /home/project 目录下新建以下文件<br>
Handler.java：</p>
<pre><code>public abstract class Handler {
    /**
     * 下个处理者
     */
    protected Handler successor;

    public void setSuccessor(Handler successor) {
        this.successor = successor;
    }

    public abstract void handlerRequest(int heaven);
}
</code></pre>
<p>GroupLeaderHandler.java</p>
<pre><code>public class GroupLeaderHandler extends Handler {
    @Override
    public void handlerRequest(int heaven) {
        if (heaven &lt;= 2) {
            System.out.println(&quot;组长处理&quot;);
        }else {
            if (super.successor != null) {
                super.successor.handlerRequest(heaven);
            }
        }
    }
}
</code></pre>
<p>FactoryManagerHandler.java：</p>
<pre><code>public class FactoryManagerHandler extends Handler{
    @Override
    public void handlerRequest(int heaven) {
        if (heaven &lt;= 7) {
            System.out.println(&quot;厂长处理&quot;);
        }else {
            if (super.successor != null) {
                super.successor.handlerRequest(heaven);
            }
        }
    }
}
</code></pre>
<p>BossHandler.java：</p>
<pre><code>public class BossHandler extends Handler {
    @Override
    public void handlerRequest(int heaven) {
        if (heaven &lt;= 15) {
            System.out.println(&quot;老板处理&quot;);
        }else {
            if (super.successor != null) {
                super.successor.handlerRequest(heaven);
            }
        }
    }
}
</code></pre>
<p>Client.java：</p>
<pre><code>public class Client {
    public static void main(String[] args) {
        Handler groupLeaderHandler = new GroupLeaderHandler();
        Handler factoryManagerHandler = new FactoryManagerHandler();
        Handler bossHandler = new BossHandler();
        groupLeaderHandler.setSuccessor(factoryManagerHandler);
        factoryManagerHandler.setSuccessor(bossHandler);
        //请假一天
        groupLeaderHandler.handlerRequest(1);
        //请假6天
        groupLeaderHandler.handlerRequest(6);
        //请假10天
        groupLeaderHandler.handlerRequest(10);
    }
}
</code></pre>
<p>编译运行：</p>
<pre><code>javac Client.java
java Client
组长处理
厂长处理
老板处理
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础12-正则表达式]]></title>
        <id>https://y-rui.github.io/post/java-ji-chu-12-zheng-ze-biao-da-shi/</id>
        <link href="https://y-rui.github.io/post/java-ji-chu-12-zheng-ze-biao-da-shi/">
        </link>
        <updated>2020-08-30T12:05:09.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为 regex、regexp 或 RE ），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式（规则）的文本。</li>
</ul>
<p>Java 通过 java.util.regex 包支持正则表达式的的功能。<br>
Java 使用正则表达式匹配非常简单，这里我们以匹配邮箱地址为例。在 /home/project 目录下新建一个源代码文件 RegexDemo.java。</p>
<pre><code>import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexDemo {
    public static void main(String[] args) {
//       Pattern类 正则表达式的编译表示。
        Pattern pattern = Pattern.compile(&quot;^[a-zA-Z0-9_!#$%&amp;'*+/=?`{|}~^.-]+@[a-zA-Z0-9.-]+$&quot;);
        String[] emails = {&quot;shiyanlou@shiyanlou.com&quot;, &quot;shiyanlou&quot;};
        for (String email :
                emails) {
//Matcher 通过解释Pattern对字符序列执行匹配操作的引擎
            Matcher matcher = pattern.matcher(email);
            System.out.println(email + &quot;匹配结果：&quot; + matcher.matches());
        }
    }
}
</code></pre>
<p>编译运行：</p>
<pre><code>$ javac RegexDemo.java
$ java RegexDemo
shiyanlou@shiyanlou.com匹配结果：true
shiyanlou匹配结果：false
</code></pre>
<p><strong>练习题：正则表达式</strong><br>
在 /home/project 目录下新建一个源代码文件 RegexTest.java。你需要完成以下要求：</p>
<ul>
<li>从控制台输入一串字符串，使用正则表达式判断其是不是 11 位手机号码。</li>
<li>如果是 11 位手机号码，输出 true，如果不是输出 false。</li>
</ul>
<p>示例：</p>
<pre><code>输入：
    13408199578
输出：
    true
</code></pre>
<p>参考答案</p>
<pre><code>import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexTest {
    public static void main(String[] args) {
        Pattern pattern = Pattern.compile(&quot;^1([34578])\\d{9}$&quot;);
        Scanner in = new Scanner(System.in);
        String phone = in.nextLine();
        Matcher matcher = pattern.matcher(phone);
        System.out.println(matcher.matches());
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础11-反射]]></title>
        <id>https://y-rui.github.io/post/java-ji-chu-11-fan-she/</id>
        <link href="https://y-rui.github.io/post/java-ji-chu-11-fan-she/">
        </link>
        <updated>2020-08-30T11:48:18.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>ava 反射说的是在运行状态中，对于任何一个类，我们都能够知道这个类有哪些方法和属性。对于任何一个对象，我们都能够对它的方法和属性进行调用。我们把这种动态获取对象信息和调用对象方法的功能称之为反射机制。本节主要讲解 Java 反射机制中的常用类。</li>
</ul>
<h2 id="什么是反射">什么是反射</h2>
<ul>
<li>反射是 Java 编程语言的一个特性，它提供了在运行时检查和动态调用类、方法、属性的能力。</li>
</ul>
<h2 id="反射能做什么">反射能做什么</h2>
<ul>
<li>反射可以在运行时检查类，接口，方法和变量。还可以实例化对象、调用方法、获取和设置变量值。比如当我们不知道一个类中是否拥有某个方法时，我们就可以使用反射来检查是否拥有这个方法。</li>
</ul>
<h2 id="反射常用类">反射常用类</h2>
<p><strong>常用类</strong></p>
<ul>
<li>Class：Class 类表示正在运行的 Java 程序中的类和接口。</li>
<li>Field：提供有关类或接口的单个域的信息和动态访问。如数据类型，访问修饰符，域的名称和值。</li>
<li>Method：提供有关类或接口上的单个方法的信息和访问权限。如访问修饰符，返回类型，名称，参数类型和方法的异常类型。</li>
<li>Constructor：提供有关类的单个构造函数的信息和访问权限。例如构造函数的访问修饰符，名称和参数类型。</li>
<li>Modifier：提供了有关访问修饰符的信息。</li>
</ul>
<p><strong>Class</strong><br>
Class 类没有公共构造方法，可以通过以下方法获取 Class 实例。</p>
<ul>
<li>Object 提供的 getClass() 方法。</li>
<li>类名.Class。</li>
<li>Class.forName(String className) 方法，className 为类的全限定名。</li>
</ul>
<p>Class 类常用方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Field getField(String name)</code></td>
<td>获取指定的域对象</td>
</tr>
<tr>
<td><code>Field[] getFields()</code></td>
<td>返回所有的公有域对象数组</td>
</tr>
<tr>
<td><code>Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code></td>
<td>返回指定的方法对象</td>
</tr>
<tr>
<td><code>Method[] getMethods()</code></td>
<td>返回所有的公有方法对象数组</td>
</tr>
<tr>
<td><code>Method[] getDeclaredMethods()</code></td>
<td>返回所有方法对象数组</td>
</tr>
<tr>
<td><code>String getName()</code></td>
<td>获取全限定名</td>
</tr>
</tbody>
</table>
<p><strong>编程实战</strong><br>
在 /home/project/ 目录下新建 ReflectDemo.java。</p>
<pre><code>import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;

public class ReflectDemo {
    public int a;
    private int b;

    public static void main(String[] args) {
        Class&lt;ReflectDemo&gt; reflectDemoClass = ReflectDemo.class;
        //输出所有的域名称
        for (Field declaredField : reflectDemoClass.getDeclaredFields()) {
            //可以通过Modifier将具体的权限信息输出，否则只会显示代表权限的数值
            System.out.println(&quot;域：&quot; + declaredField.getName() + &quot; 修饰符：&quot; + Modifier.toString(declaredField.getModifiers()));
        }
        //输出所有的公有域名称
        for (Field field : reflectDemoClass.getFields()) {
            System.out.println(&quot;公有域：&quot; + field.getName() + &quot; 修饰符：&quot; + Modifier.toString(field.getModifiers()));
        }
        //输出类的所有方法名
        for (Method declaredMethod : reflectDemoClass.getDeclaredMethods()) {
            System.out.println(&quot;方法：&quot; + declaredMethod.getName() + &quot; 修饰符：&quot; + Modifier.toString(declaredMethod.getModifiers()));
        }
    }

    public void fun1() {
    }

    private void fun2() {
    }

}
</code></pre>
<p>编译运行：</p>
<pre><code>javac ReflectDemo.java
java ReflectDemo
</code></pre>
<p>运行结果：</p>
<pre><code>域：a 修饰符：public
域：b 修饰符：private
公有域：a 修饰符：public
方法：main 修饰符：public static
方法：fun1 修饰符：public
方法：fun2 修饰符：private
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础10-JDBC]]></title>
        <id>https://y-rui.github.io/post/java-ji-chu-10-jdbc/</id>
        <link href="https://y-rui.github.io/post/java-ji-chu-10-jdbc/">
        </link>
        <updated>2020-08-29T08:04:58.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>JDBC 是连接数据库和 Java 程序的桥梁，通过 JDBC API 可以方便地实现对各种主流数据库的操作。本节将重点讲解 JDBC 的内容</li>
</ul>
<h2 id="数据库简介">数据库简介</h2>
<p>数据库，简而言之可视为电子化的文件柜——存储电子文件的处所，用户可以对文件中的数据运行新增、截取、更新、删除等操作</p>
<p>所谓“数据库”系以一定方式储存在一起、能予多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。一个数据库由多个表空间（Tablespace）构成</p>
<h2 id="关系数据库">关系数据库</h2>
<h2 id="非关系型数据库nosql">非关系型数据库（NoSql）</h2>
<h2 id="sql-简介">SQL 简介</h2>
<ul>
<li>结构化查询语言 (Structured Query Language) 简称 SQL（发音：/ˈes kjuː ˈel/ &quot;S-Q-L&quot;)，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。</li>
<li>结构化查询语言是高级的非过程化编程语言，允许用户在高层数据结构上工作。它不要求用户指定对数据的存放方法，也不需要用户了解具体的数据存放方式，所以具有完全不同底层结构的不同数据库系统，可以使用相同的结构化查询语言作为数据输入与管理的接口。结构化查询语言语句可以嵌套，这使它具有极大的灵活性和强大的功能。</li>
</ul>
<p><strong>SQL 语法</strong></p>
<h2 id="jdbc">JDBC</h2>
<p>JDBC 的全称是 Java Database Connectivity，叫做 Java 数据库连接。它包括了一组与数据库交互的 API，还有与数据库进行通信的驱动程序</p>
<p>我们要写涉及到数据库的程序，是通过 C 语言或者 C++ 语言直接访问数据库的接口，如下图所示<br>
<img src="https://y-rui.github.io/post-images/1608710862742.png" alt="" loading="lazy"><br>
对于不同的数据库，我们需要知道不同数据库对外提供的系统 API，这就影响了我们程序的扩展和跨平台的实现</p>
<p>那么有没有一种方法来对不同的数据库接口进行统一呢？当然有。我们只需要和最上层接口进行交互，剩下的部分就交给其他各层去处理，我们的任务就变的轻松简单许多<br>
<img src="https://y-rui.github.io/post-images/1608710893585.png" alt="" loading="lazy"><br>
JDBC 为数据库开发人员提供了一个标准的 API，据此可以构建更高级的工具和接口使数据库开发人员能够用纯 Java API 编写数据库应用程序<br>
<img src="https://y-rui.github.io/post-images/1608710914425.png" alt="" loading="lazy"></p>
<p><strong>JDBC 连接数据库</strong><br>
涉及到建立一个 JDBC 连接的编程主要有四个步骤</p>
<ol>
<li>导入 JDBC 驱动： 只有拥有了驱动程序我们才可以注册驱动程序完成连接的其他步骤</li>
<li>注册 JDBC 驱动程序：这一步会导致 JVM 加载所需的驱动类实现到内存中，然后才可以实现 JDBC 请求</li>
<li>数据库 URL 指定：创建具有正确格式的地址，指向到要连接的数据库</li>
<li>创建连接对象：最后，代码调用 DriverManager 对象的 getConnection() 方法来建立实际的数据库连接</li>
</ol>
<p>接下来我们便详细讲解这四步</p>
<p><strong>导入 JDBC 驱动</strong><br>
需要下载对应数据库的 jdbc 驱动，将其导入到项目中，具体的导入方式根据个人的 IDE 确定，本节课程不使用 IDE，直接使用 javac -cp 命令导入包</p>
<p><strong>注册 JDBC 驱动程序</strong><br>
我们在使用驱动程序之前，必须注册你的驱动程序。注册驱动程序的本质就是将我们将要使用的数据库的驱动类文件动态的加载到内存中，然后才能进行数据库。比如我们使用的 Mysql 数据库。我们可以通过以下两种方式来注册我们的驱动程序</p>
<p>1、Class.forName()<br>
动态加载一个类最常用的方法是使用 Java 的 Class.forName() 方法，通过使用这个方法来将数据库的驱动类动态加载到内存中，然后我们就可以使用</p>
<p>使用 Class.forName() 来注册 Mysql 驱动程序</p>
<pre><code>try {
   Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
}
catch(ClassNotFoundException ex) {
   System.out.println(&quot;Error: unable to load driver class!&quot;);
   System.exit(1);
}
</code></pre>
<p>2、DriverManager.registerDriver()</p>
<pre><code>Driver driver = new com.mysql.jdbc.Driver();
DriverManager.registerDriver(driver);
</code></pre>
<p><strong>指定数据库连接 URL</strong><br>
当加载了驱动程序，便可以使用 DriverManager.getConnection() 方法连接到数据库了</p>
<p>这里给出 DriverManager.getConnection() 三个重载方法</p>
<pre><code>getConnection(String url)

getConnection(String url, Properties prop)

getConnection(String url, String user, String password)
</code></pre>
<p>数据库的 URL 是指向数据库地址。下表列出了下来流行的 JDBC 驱动程序名和数据库的 URL</p>
<table>
<thead>
<tr>
<th>RDBMS</th>
<th>JDBC 驱动程序的名称</th>
<th>URL</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Mysql</code></td>
<td>com.mysql.jdbc.Driver</td>
<td>jdbc:mysql://hostname/ databaseName</td>
</tr>
<tr>
<td><code>Oracle</code></td>
<td>oracle.jdbc.driver.OracleDriver</td>
<td>jdbc:oracle:thin:@hostname:port Number:databaseName</td>
</tr>
<tr>
<td><code>DB2</code></td>
<td>COM.ibm.db2.jdbc.net.DB2Driver</td>
<td>jdbc:db2:hostname:port Number/databaseName</td>
</tr>
<tr>
<td><code>Sybase</code></td>
<td>com.sybase.jdbc.SybDriver</td>
<td>jdbc:sybase:Tds:hostname: port Number/databaseName</td>
</tr>
</tbody>
</table>
<p><strong>创建连接对象</strong><br>
下面三种形式 DriverManager.getConnection() 方法来创建一个连接对象，以 Mysql 为例。getConnection() 最常用形式要求传递一个数据库 URL，用户名 username 和密码 password</p>
<ol>
<li>使用数据库 URL 的用户名和密码</li>
</ol>
<pre><code>String URL = &quot;jdbc:mysql://localhost/EXAMPLE&quot;;
String USER = &quot;username&quot;;
String PASS = &quot;password&quot;
Connection conn = DriverManager.getConnection(URL, USER, PASS);
</code></pre>
<ol start="2">
<li>只使用一个数据库 URL<br>
然而，在这种情况下，数据库的 URL，包括用户名和密码</li>
</ol>
<pre><code>String URL = &quot;jdbc:mysql://localhost/EXAMPLE?user=root&amp;password=0909&quot;;
//Mysql URL的参数设置详细可以查阅相关资料
Connection conn = DriverManager.getConnection(URL);
</code></pre>
<ol start="3">
<li>使用数据库的 URL 和一个 Properties 对象</li>
</ol>
<pre><code>import java.util.*;

String URL = &quot;jdbc:mysql://localhost/EXAMPLE&quot;;
Properties pro = new Properties( );

//Properties对象，保存一组关键字-值对
pro.put( &quot;user&quot;, &quot;root&quot; );
pro.put( &quot;password&quot;, &quot;&quot; );

Connection conn = DriverManager.getConnection(URL, pro);
</code></pre>
<ol start="4">
<li>关闭 JDBC 连接</li>
</ol>
<pre><code>conn.close();
</code></pre>
<h2 id="创建数据库">创建数据库</h2>
<p>在使用数据库之前第一件事情就是创建数据库，这里我们使用 JDBC 来创建数据库</p>
<p><strong>编程实战</strong><br>
实验楼数据库密码为空<br>
在 /home/project/ 目录下新建文件 CreateDatabase.java</p>
<pre><code>import java.sql.*;

public class CreateDatabase {
    public static void main(String[] args){
        Connection connection = null;
        try {
            //加载数据库驱动
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
            //打开数据库连接 第一个参数为数据库地址  后面2个参数分别为数据库用户名和密码
            // 实验楼中 MySQL 的用户名为: root, 密码为空。
            connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/&quot;,&quot;root&quot;,&quot;&quot;);
            //创建Statement
            Statement statement = connection.createStatement();
            //执行sql
            statement.execute(&quot;create database EXAMPLE&quot;);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                //关闭连接
                if (connection != null) {
                    connection.close();
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<p>启动 mysql</p>
<pre><code>$ sudo service mysql start
</code></pre>
<p>编译运行（需要带上 mysql-connector-java-5.1.45.jar）</p>
<pre><code>$ wget https://labfile.oss.aliyuncs.com/courses/1230/mysql-connector-java-5.1.47.jar
$ javac -cp mysql-connector-java-5.1.47.jar CreateDatabase.java
$ java -cp .:mysql-connector-java-5.1.47.jar CreateDatabase
</code></pre>
<h2 id="数据库操作">数据库操作</h2>
<p><img src="https://y-rui.github.io/post-images/1608711715625.png" alt="" loading="lazy"><br>
当连接上了数据库后，就需要通过 sql 语句对数据库进行操作。随着 Java 语言应用面的逐步拓宽，Sun 公司开发了一个标准的 SQL 数据库访问接口———JDBC API。它可以使 Java 编程人员通过一个一致的接口，访问多种关系数据库。而今天我们就来学习一下，如何利用 JDBC 的一些核心 API 与数据库进行交互</p>
<p>通过使用 JDBC Statement, CallableStatement 和 PreparedStatement 接口定义的方法和属性，使可以使用 SQL 或 PL/SQL 命令和从数据库接收数据。它们还定义了许多方法，帮助消除 Java 和数据库之间数据类型的差异</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>应用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Statement</code></td>
<td>当在运行时使用静态 SQL 语句时（Statement 接口不能接收参数）</td>
</tr>
<tr>
<td><code>CallableStatement</code></td>
<td>当要访问数据库中的存储过程时（CallableStatement 对象的接口还可以接收运行时输入参数）</td>
</tr>
<tr>
<td><code>PreparedStatement</code></td>
<td>当计划多次使用 SQL 语句时（PreparedStatement 接口接收在运行时输入参数）</td>
</tr>
</tbody>
</table>
<p><strong>Statement</strong><br>
我们要使用 Statement 接口，第一步肯定是创建一个 Statement 对象了。我们需要使用 Connection 对象的 createStatement() 方法进行创建</p>
<pre><code>Statement stmt = null;
try {
   stmt = conn.createStatement( );
   . . .
}
catch (SQLException e) {
   . . .
}
finally {
   . . .
}
</code></pre>
<p>一旦创建了一个 Statement 对象，我们就可以用它来执行 SQL 语句了，首先我们先来看看 Statement 里面有哪些方法吧！</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>boolean execute(String SQL)</code></td>
<td>如果 ResultSet 对象可以被检索返回布尔值 true，否则返回 false。使用这个方法来执行 SQL DDL 语句，或当需要使用真正的动态 SQL</td>
</tr>
<tr>
<td><code>int executeUpdate(String SQL)</code></td>
<td>用于执行 INSERT、UPDATE 或 DELETE 语句以及 SQLDDL（数据定义语言）语句。返回值是一个整数，指示受影响的行数（即更新计数）</td>
</tr>
<tr>
<td><code>ResultSet executeQuery(String SQL)</code></td>
<td>返回 ResultSet 对象。用于产生单个结果集的语句，例如 SELECT 语句</td>
</tr>
</tbody>
</table>
<p>正如关闭一个 Connection 对象来释放数据库连接资源，出于同样的原因，也应该关闭 Statement 对象</p>
<pre><code>Statement stmt = null;
try {
   stmt = conn.createStatement( );
   . . .
}
catch (SQLException e) {
   . . .
}
finally {
   stmt.close();
}
</code></pre>
<p>注：如果关闭了 Connection 对象首先它会关闭 Statement 对象，然而应该始终明确关闭 Statement 对象，以确保正确的清除</p>
<p><strong>PreparedStatement</strong><br>
PreparedStatement 接口扩展了 Statement 接口，有利于高效地执行多次使用的 SQL 语句。我们先来创建一个 PreparedStatement 对象。 Statement 为一条 SQL 语句生成执行计划。如果要执行两条 SQL 语句，会生成两个执行计划。一万个查询就生成一万个执行计划！</p>
<pre><code>select colume from table where colume=1;
select colume from table where colume=2;
</code></pre>
<p>PreparedStatement 用于使用绑定变量重用执行计划</p>
<pre><code>select colume from table where colume=:x;
</code></pre>
<p>通过 set 不同数据，只需要生成一次执行计划，并且可以重用</p>
<pre><code>PreparedStatement pstmt = null;
try {

/*
在JDBC中所有的参数都被代表？符号，这是已知的参数标记。在执行SQL语句之前，必须提供值的每一个参数。
*/
   String SQL = &quot;Update Students SET age = ? WHERE id = ?&quot;;
   pstmt = conn.prepareStatement(SQL);
   . . .
}
/*

setXXX()方法将值绑定到参数，其中XXX表示希望绑定到输入参数值的 Java 数据类型。如果忘了提供值，将收到一个 SQLException。
*/
catch (SQLException e) {
   . . .
}
finally {
//同理，我们需要关闭 PreparedStatement 对象
   pstmt.close();
}
</code></pre>
<p>说了这么多，我们手动操作一下吧<br>
先创建数据库和相应的内容</p>
<pre><code>sudo service mysql start
# 实验楼中 MySQL 的用户名为: root, 密码为空。
mysql -u root
create database EXAMPLE;
use EXAMPLE
</code></pre>
<pre><code>create table Students
(
id int not null,
age int not null,
name varchar(255),
primary key(id)
);
insert into Students values(1,18,'Tom'),
(2,20,'Aby'),(4,20,'Tomson');
</code></pre>
<p>在 /home/project/ 目录下创建 JdbcTest.java</p>
<pre><code>import java.sql.*;

public class JdbcTest {
   // JDBC 驱动器的名称和数据库地址
   static final String JDBC_DRIVER = &quot;com.mysql.jdbc.Driver&quot;;
   static final String DB_URL = &quot;jdbc:mysql://localhost/EXAMPLE&quot;;


   static final String USER = &quot;root&quot;;
   static final String PASS = &quot;&quot;;

   public static void main(String[] args) {
       Connection conn = null;
       PreparedStatement stmt = null;
       try{
           //注册 JDBC 驱动器
           Class.forName(&quot;com.mysql.jdbc.Driver&quot;);

           //打开连接
           System.out.println(&quot;Connecting to database...&quot;);
           conn = DriverManager.getConnection(DB_URL,USER,PASS);

           //执行查询
           System.out.println(&quot;Creating statement...&quot;);
           //这里我们要更改一个同学的年龄，参数待定
           String sql = &quot;UPDATE Students set age=? WHERE id=?&quot;;
           stmt = conn.prepareStatement(sql);

           //将值绑定到参数，参数从左至右序号为1，2...
           stmt.setInt(1, 22);  // 绑定 age 的值(序号为1)
           stmt.setInt(2, 1); // 绑定 ID 的值

           // 更新 ID 为1的同学的年龄
           int rows = stmt.executeUpdate();
           System.out.println(&quot;被影响的行数 : &quot; + rows );

           // 查询所有记录，并显示.
           sql = &quot;SELECT id, name, age FROM Students&quot;;
           ResultSet rs = stmt.executeQuery(sql);

           //处理结果集
           while(rs.next()){
               //检索
               int id  = rs.getInt(&quot;id&quot;);
               int age = rs.getInt(&quot;age&quot;);
               String name = rs.getString(&quot;name&quot;);


               //显示
               System.out.print(&quot;ID: &quot; + id);
               System.out.print(&quot;, Age: &quot; + age);
               System.out.print(&quot;, Name: &quot; + name);
               System.out.println();
           }
           //清理
           rs.close();
           stmt.close();
           conn.close();
       }catch(SQLException se){
           se.printStackTrace();
       }catch(Exception e){
           e.printStackTrace();
       }finally{
           try{
               if(stmt!=null)
                   stmt.close();
           }catch(SQLException se2){
           }
    try{
         if(conn!=null)
                 conn.close();
      }catch(SQLException se){
              se.printStackTrace();
          }
       }
           System.out.println(&quot;Goodbye!&quot;);
   }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ wget https://labfile.oss.aliyuncs.com/courses/1230/mysql-connector-java-5.1.47.jar
$ javac -cp .:mysql-connector-java-5.1.47.jar JdbcTest.java
$ java -cp .:mysql-connector-java-5.1.47.jar JdbcTest
</code></pre>
<p><strong>CallableStatement</strong><br>
CallableStatement 对象为所有的 DBMS 提供了一种以标准形式调用存储过程的方法。存储过程储存在数据库中。对储存过程的调用是 CallableStatement 对象所含的内容。三种类型的参数有：IN，OUT 和 INOUT。PreparedStatement 对象只使用 IN 参数。 CallableStatement 对象可以使用所有三个</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>IN</code></td>
<td>它的值是在创建 SQL 语句时未知的参数，将 IN 参数传给 CallableStatement 对象是通过 setXXX() 方法完成的</td>
</tr>
<tr>
<td><code>OUT</code></td>
<td>其值由它返回的 SQL 语句提供的参数。从 OUT 参数的 getXXX() 方法检索值</td>
</tr>
<tr>
<td><code>INOUT</code></td>
<td>同时提供输入和输出值的参数，绑定的 setXXX() 方法的变量，并使用 getXXX() 方法检索值</td>
</tr>
</tbody>
</table>
<p>在 JDBC 中调用存储过程的语法如下所示。注意，方括号表示其间的内容是可选项；方括号本身并不是语法的组成部份</p>
<pre><code>{call 存储过程名[(?, ?, ...)]}
</code></pre>
<p>返回结果参数的过程的语法为</p>
<pre><code>{? = call 存储过程名[(?, ?, ...)]}
</code></pre>
<p>不带参数的存储过程的语法类似</p>
<pre><code>{call 存储过程名}
</code></pre>
<p>CallableStatement 对象是用 Connection 方法 prepareCall 创建的</p>
<pre><code>CallableStatement cstmt = null;
try {
   String SQL = &quot;{call getEXAMPLEName (?, ?)}&quot;;
   cstmt = conn.prepareCall (SQL);
   . . .
}
catch (SQLException e) {
   . . .
}
finally {
   cstmt.close();
}
</code></pre>
<p>好了，CallableStatement 接口就不再详细地讲解了，同学们可以自己查阅相关的资料，对 CallableStatement 进行深入学习</p>
<h2 id="jdbc-结果集">JDBC 结果集</h2>
<p>结果集通常是通过执行查询数据库的语句生成，表示数据库查询结果的数据表</p>
<p><strong>ResultSet 介绍</strong><br>
ResultSet 对象具有指向其当前数据行的光标。最初，光标被置于第一行之前。next 方法将光标移动到下一行；因为该方法在 ResultSet 对象没有下一行时返回 false，所以可以在 while 循环中使用它来迭代结果集。光标可以方便我们对结果集进行遍历。默认的 ResultSet 对象不可更新，仅有一个向前移动的光标。因此，只能迭代它一次，并且只能按从第一行到最后一行的顺序进行</p>
<p>ResultSet 接口的方法可分为三类</p>
<ul>
<li>导航方法：用于移动光标</li>
<li>获取方法：用于查看当前行的光标所指向的列中的数据</li>
<li>更新方法：用于更新当前行的列中的数据</li>
</ul>
<p>JDBC 提供下列连接方法来创建所需的 ResultSet 语句</p>
<pre><code>createStatement(int RSType, int RSConcurrency);

prepareStatement(String SQL, int RSType, int RSConcurrency);

prepareCall(String sql, int RSType, int RSConcurrency);
</code></pre>
<p>RSType 表示 ResultSet 对象的类型，RSConcurrency 是 ResultSet 常量，用于指定一个结果集是否为只读或可更新</p>
<p>ResultSet 的类型，如果不指定 ResultSet 类型，将自动获得一个是 TYPE_FORWARD_ONLY</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ResultSet.TYPE_FORWARD_ONLY</code></td>
<td>游标只能向前移动的结果集</td>
</tr>
<tr>
<td><code>ResultSet.TYPE_SCROLL_INSENSITIVE</code></td>
<td>游标可以向前和向后滚动，但不及时更新，就是如果数据库里的数据修改过，并不在 ResultSet 中反应出来</td>
</tr>
<tr>
<td><code>ResultSet.TYPE_SCROLL_SENSITIVE</code></td>
<td>游标可以向前和向后滚动，并及时跟踪数据库的更新，以便更改 ResultSet 中的数据</td>
</tr>
</tbody>
</table>
<p>并发性的 ResultSet，如果不指定任何并发类型，将自动获得一个为 CONCUR_READ_ONLY</p>
<table>
<thead>
<tr>
<th>并发</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ResultSet.CONCUR_READ_ONLY</code></td>
<td>创建结果集只读。这是默认的</td>
</tr>
<tr>
<td><code>ResultSet.CONCUR_UPDATABLE</code></td>
<td>创建一个可更新的结果集</td>
</tr>
</tbody>
</table>
<p>如初始化一个 Statement 对象来创建一个双向、可更新的 ResultSet 对象</p>
<pre><code>try {
   Statement stmt = conn.createStatement(
                           ResultSet.TYPE_SCROLL_INSENSITIVE,
                           ResultSet.CONCUR_UPDATABLE);
}
catch(Exception ex) {
   ....
}
finally {
   ....
}
</code></pre>
<p><strong>导航</strong><br>
我们在上面已经知道了，导航方法是用于移动光标的。我们先来看一看，在 ResultSet 接口中有哪些方法会涉及光标的移动</p>
<p>先创建数据库和相应的内容</p>
<pre><code>sudo service mysql start
mysql -u root
create database EXAMPLE;
use EXAMPLE
</code></pre>
<pre><code>create table Students
(
id int not null,
age int not null,
name varchar(255),
primary key(id)
);
insert into Students values(1,18,'Tom'),
(2,20,'Aby'),(4,20,'Tomson');
</code></pre>
<p>在 /home/project/ 目录下创建文件JdbcTest.java</p>
<pre><code>import java.sql.*;

public class JdbcTest {
   // JDBC 驱动器名称 和数据库地址
   static final String JDBC_DRIVER = &quot;com.mysql.jdbc.Driver&quot;;
   //数据库的名称为 EXAMPLE
   static final String DB_URL = &quot;jdbc:mysql://localhost/EXAMPLE&quot;;

   // 数据库用户和密码
   static final String USER = &quot;root&quot;;
   static final String PASS = &quot;&quot;;

   public static void main(String[] args) {
       Connection conn = null;
       Statement stmt = null;
       try{
           //注册JDBC 驱动程序
           Class.forName(&quot;com.mysql.jdbc.Driver&quot;);

           //打开连接
           System.out.println(&quot;Connecting to database...&quot;);
           conn = DriverManager.getConnection(DB_URL,USER,PASS);



           System.out.println(&quot;Creating statement...&quot;);
           //创建所需的ResultSet，双向，只读
           stmt = conn.createStatement(
                           ResultSet.TYPE_SCROLL_INSENSITIVE,
                           ResultSet.CONCUR_READ_ONLY);
           String sql;
           sql = &quot;SELECT id, name, age FROM Students&quot;;
           ResultSet rs = stmt.executeQuery(sql);

           // 将光标移到最后一行
           System.out.println(&quot;Moving cursor to the last...&quot;);
           rs.last();

           //处理结果集
           System.out.println(&quot;Displaying record...&quot;);
           int id  = rs.getInt(&quot;id&quot;);
           int age = rs.getInt(&quot;age&quot;);
           String name = rs.getString(&quot;name&quot;);


           //显示
           System.out.print(&quot;ID: &quot; + id);
           System.out.print(&quot;, Age: &quot; + age);
           System.out.print(&quot;, Name: &quot; + name);
           System.out.println();

           // 将光标移到第一行
           System.out.println(&quot;Moving cursor to the first row...&quot;);
           rs.first();


           System.out.println(&quot;Displaying record...&quot;);
           id  = rs.getInt(&quot;id&quot;);
           age = rs.getInt(&quot;age&quot;);
           name = rs.getString(&quot;name&quot;);


           //显示
           System.out.print(&quot;ID: &quot; + id);
           System.out.print(&quot;, Age: &quot; + age);
           System.out.print(&quot;, Name: &quot; + name);

           //将光标移至下一行
           System.out.println(&quot;Moving cursor to the next row...&quot;);
           rs.next();


           System.out.println(&quot;Displaying record...&quot;);
           id  = rs.getInt(&quot;id&quot;);
           age = rs.getInt(&quot;age&quot;);
           name = rs.getString(&quot;name&quot;);

           // 显示
           System.out.print(&quot;ID: &quot; + id);
           System.out.print(&quot;, Age: &quot; + age);
           System.out.print(&quot;, Name: &quot; + name);

           rs.close();
           stmt.close();
           conn.close();
       }catch(SQLException se){
           se.printStackTrace();
       }catch(Exception e){
           e.printStackTrace();
       }finally{
           try{
               if(stmt!=null)
                   stmt.close();
           }catch(SQLException se2){
           }
           try{
               if(conn!=null)
                   conn.close();
           }catch(SQLException se){
               se.printStackTrace();
           }
       }
       System.out.println(&quot;Goodbye!&quot;);
   }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ wget https://labfile.oss.aliyuncs.com/courses/1230/mysql-connector-java-5.1.47.jar
$ javac -cp .:mysql-connector-java-5.1.47.jar JdbcTest.java
$ java -cp .:mysql-connector-java-5.1.47.jar JdbcTest
</code></pre>
<p><strong>获取</strong><br>
ResultSet 接口中我们经常使用 get 方法来查看结果集</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public int getInt(String columnName) throws SQLException</code></td>
<td>当前行中名为 ColumnName 列的值</td>
</tr>
<tr>
<td><code>public int getInt(int columnIndex) throws SQLException</code></td>
<td>当前行中指定列的索引的值。列索引从 1 开始，意味着一个行的第一列是 1，行的第二列是 2，依此类推</td>
</tr>
</tbody>
</table>
<p>当然还有 getString() 等等</p>
<p><strong>更新</strong><br>
更新的方法如下</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public void updateString(int columnIndex, String s) throws SQLException</code></td>
<td>指定列中的字符串更改为 s 的值</td>
</tr>
<tr>
<td><code>public void updateString(String columnName, String s) throws SQLException</code></td>
<td>类似于前面的方法，不同之处在于由它的名称，而不是它的索引指定的列</td>
</tr>
</tbody>
</table>
<p>类似的还有 updateDouble() 等等</p>
<p>我们在更新了结果集中的内容，当然需要更新一下数据库了。我们可以调用下面的方法更新数据库</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public void updateRow()</code></td>
<td>通过更新数据库中相应的行更新当前行</td>
</tr>
<tr>
<td><code>public void deleteRow()</code></td>
<td>从数据库中删除当前行</td>
</tr>
<tr>
<td><code>public void refreshRow()</code></td>
<td>刷新在结果集的数据，以反映最新变化在数据库中</td>
</tr>
<tr>
<td><code>public void cancelRowUpdates()</code></td>
<td>取消所做的当前行的任何更新</td>
</tr>
<tr>
<td><code>public void insertRow()</code></td>
<td>插入一行到数据库中。当光标指向插入行此方法只能被调用</td>
</tr>
</tbody>
</table>
<p>我们这里对上面的方法做一个小小的举例</p>
<pre><code>Statement stmt = conn.createStatement(
                           ResultSet.TYPE_SCROLL_INSENSITIVE,
                           ResultSet.CONCUR_UPDATABLE);

String sql = &quot;SELECT id, name, age FROM Students&quot;;
ResultSet rs = stmt.executeQuery(sql);

//结果集中插入新行
rs.moveToInsertRow();
rs.updateInt(&quot;id&quot;,5);
rs.updateString(&quot;name&quot;,&quot;John&quot;);
rs.updateInt(&quot;age&quot;,21);
//更新数据库
rs.insertRow();
</code></pre>
<p><strong>练习题：根据多种条件进行查询</strong><br>
启动数据库</p>
<pre><code>$ sudo service mysql start
</code></pre>
<p>创建一个数据库test，在数据库中创建一个数据表user，表内容如下</p>
<pre><code>create database test;
use test;
CREATE TABLE user
(
    id int PRIMARY KEY,
    name varchar(50),
    age int,
    sex varchar(50)
);
alter table user change sex sex varchar(50) character set utf8;
INSERT INTO `user`(`id`, `name`, `age`, `sex`) VALUES (1, 'shi', 20, '男');
INSERT INTO `user`(`id`, `name`, `age`, `sex`) VALUES (2, 'yan', 13, '女');
INSERT INTO `user`(`id`, `name`, `age`, `sex`) VALUES (3, 'lou', 22, '女');
INSERT INTO `user`(`id`, `name`, `age`, `sex`) VALUES (4, 'admin', 50, '男');
</code></pre>
<p>在 /home/project 目录下创建一个文件 QueryDemo.java，使用 jdbc 完成以下查询</p>
<ul>
<li>查询 Id 为 1 的用户</li>
<li>查询年龄为 12 岁，名字为 yan 的用语</li>
<li>查询年龄大于 20 岁的用户</li>
</ul>
<p>JDBC 驱动下载</p>
<pre><code>$ wget https://labfile.oss.aliyuncs.com/courses/1230/mysql-connector-java-5.1.47.jar
</code></pre>
<p>参考答案</p>
<pre><code>import java.sql.*;

public class QueryDemo {

    // JDBC 驱动器的名称和数据库地址
    private static final String JDBC_DRIVER = &quot;com.mysql.jdbc.Driver&quot;;
    private static final String DB_URL = &quot;jdbc:mysql://localhost/test&quot;;
    private static final String USER = &quot;root&quot;;
    private static final String PASS = &quot;&quot;;

    public static void main(String[] args) {
        Connection conn = null;
        PreparedStatement stmt = null;
        try {
            Class.forName(JDBC_DRIVER);
            conn = DriverManager.getConnection(DB_URL, USER, PASS);

            //id为1的用户
            String sql = &quot;select id,name,age,sex from user where id=?&quot;;
            stmt = conn.prepareStatement(sql);
            stmt.setInt(1, 1);
            ResultSet resultSet = stmt.executeQuery();
            printRS(resultSet);

            //年龄为12 名字为yan
            stmt = conn.prepareStatement(&quot;select id,name,age,sex from user where age=? and name=?&quot;);
            stmt.setInt(1, 12);
            stmt.setString(2, &quot;yan&quot;);
            resultSet = stmt.executeQuery();
            printRS(resultSet);

            //年龄为12 名字为yan
            stmt = conn.prepareStatement(&quot;select id,name,age,sex from user where age&gt;?&quot;);
            stmt.setInt(1, 20);
            resultSet = stmt.executeQuery();
            printRS(resultSet);
            //清理
            resultSet.close();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                if (stmt != null) {
                    stmt.close();
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
            try {
                if (conn != null) {
                    conn.close();
                }
            } catch (SQLException se) {
                se.printStackTrace();
            }
        }
    }

    private static void printRS(ResultSet resultSet) throws SQLException {
        while (resultSet.next()) {
            int id = resultSet.getInt(&quot;id&quot;);
            String name = resultSet.getString(&quot;name&quot;);
            int age = resultSet.getInt(&quot;age&quot;);
            String sex = resultSet.getString(&quot;sex&quot;);
            System.out.println(&quot;id:&quot; + id + &quot; name:&quot; + name + &quot; age:&quot; + age + &quot; sex:&quot; + sex);
        }
    }
}
</code></pre>
<p><strong>JDBC 事务</strong><br>
我们在编写 java 程序的时候，在默认情况下，JDBC 连接是在自动提交模式下，即每个 SQL 语句都是在其完成时提交到数据库。但有时候我们为了提高程序运行的性能或者保持业务流程的完整性，以及使用了分布式事务管理方式，这个时候我们可能想关闭自动提交而自己管理和控制自己的事务</p>
<p>让多条 SQL 在一个事务中执行，并且保证这些语句是在同一时间共同执行的时候，我们就应该为这多条语句定义一个事务。一个事务是把单个 SQL 语句或一组 SQL 语句作为一个逻辑单元，并且如果事务中任何语句失败，则整个事务失败</p>
<p>如果我们要启动一个事务，而不是让 JDBC 驱动程序默认使用 auto-commit 模式支持。这个时候我们就要使用 Connection 对象的 setAutoCommit() 方法。我们传递一个布尔值 false 到 setAutoCommit() 中，就可以关闭自动提交。反之我们传入一个 true 便将其重新打开</p>
<p>例如</p>
<pre><code>Connection conn = null;
conn = DriverManager.getConnection(URL);
//关闭自动提交
conn.setAutoCommit(false);
</code></pre>
<p>我们关闭了自动提交后，如果我们要提交数据库更改怎么办呢？这时候就要用到我们的提交和回滚了。我们要提交更改，可以调用 commit() 方法</p>
<pre><code>conn.commit();
</code></pre>
<p>尤其不要忘记，在 catch 块内添加回滚事务，表示操作出现异常，撤销事务</p>
<pre><code>conn.rollback();
</code></pre>
<h2 id="插入数据">插入数据</h2>
<p>JDBC 插入数据使用的频率非常高，接下来说明如何使用 JDBC 插入数据</p>
<p><strong>编程实战</strong><br>
创建数据库（若之前已经创建了 Students 表需提前删除再操作）</p>
<pre><code>    sudo service mysql start
    mysql -u root
    create database EXAMPLE;
    use EXAMPLE;
    create table Students
    (
        id int not null,
        age int not null,
        name varchar(255),
        primary key(id)
    );
</code></pre>
<p>在 /home/project 目录下新建一个JdbcInsertTest.java</p>
<pre><code>import java.sql.*;

public class JdbcInsertTest {
    public static Connection connection = null;
    public static void main(String[] args) {
        try {
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
            connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/EXAMPLE&quot;, &quot;root&quot;, &quot;&quot;);
            Statement statement = connection.createStatement();
            //单条插入
            boolean execute = statement.execute(&quot;insert into Students values (0,1,'shiyanlou')&quot;);
            if (execute) {
                System.out.println(&quot;插入失败&quot;);
            }else {
                System.out.println(&quot;单条插入成功&quot;);
            }
            // 批量插入  需要关闭自动提交
            connection.setAutoCommit(false);
            String sql = &quot;insert into Students values (?,?,?)&quot;;
            PreparedStatement preparedStatement = connection.prepareStatement(sql);
            //设置插入的值
            for (int i = 1; i &lt;= 10; i++) {
                preparedStatement.setInt(1, i);
                preparedStatement.setInt(2, i + 10);
                preparedStatement.setString(3, &quot;shiyanlou&quot;);
                preparedStatement.addBatch();
            }
            //执行批量插入，使用executeBatch 方法
            preparedStatement.executeBatch();
            //提交到数据库
            connection.commit();
            System.out.println(&quot;提交批量插入完成&quot;);
        } catch (ClassNotFoundException | SQLException e) {
            e.printStackTrace();
        }

    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ wget https://labfile.oss.aliyuncs.com/courses/1230/mysql-connector-java-5.1.47.jar
$ javac -cp .:mysql-connector-java-5.1.47.jar JdbcInsertTest.java
$ java -cp .:mysql-connector-java-5.1.47.jar JdbcInsertTest
单条插入成功
提交批量插入完成
</code></pre>
<p>如果成功运行，进入数据库查看数据是否有增加</p>
<pre><code>mysql -u root
use EXAMPLE;
select * from Students;
</code></pre>
<p><strong>练习题：插入数据</strong><br>
启动数据库</p>
<pre><code>$ sudo service mysql start
</code></pre>
<p>创建一个数据库test，在数据库中创建一个数据表user，表内容如下</p>
<pre><code>create database test;
use test;
CREATE TABLE user
(
    id int PRIMARY KEY,
    name varchar(50),
    age int,
    sex varchar(10)
);
</code></pre>
<p>在 /home/project 目录下创建一个文件 InsertDemo.java，使用 jdbc 完成以下操作</p>
<ul>
<li>将用户 id：10，name：shiyanlou，age：22，sex：男 插入到数据库</li>
</ul>
<p>JDBC 驱动下载</p>
<pre><code>$ wget https://labfile.oss.aliyuncs.com/courses/1230/mysql-connector-java-5.1.47.jar
</code></pre>
<p>参考答案</p>
<pre><code>import java.sql.*;

public class InsertDemo {
    public static Connection connection = null;
    public static void main(String[] args) {
        try {
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
            connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;, &quot;root&quot;, &quot;&quot;);
            Statement statement = connection.createStatement();
            statement.execute(&quot;insert into user values (10,'shiyanlou',22,'男')&quot;);
            statement.close();
            connection.close();
        } catch (ClassNotFoundException | SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                connection.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础9-多线程]]></title>
        <id>https://y-rui.github.io/post/java-ji-chu-9-duo-xian-cheng/</id>
        <link href="https://y-rui.github.io/post/java-ji-chu-9-duo-xian-cheng/">
        </link>
        <updated>2020-08-28T07:22:23.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>Java 给多线程编程提供了内置的支持。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。本节主要讲解 Java 多线程的一些概念以及其实现</li>
</ul>
<h2 id="什么是线程">什么是线程</h2>
<ul>
<li>线程：程序执行流的最小单元。它是进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派 CPU 的基本单位</li>
</ul>
<p>如同大自然中的万物，线程也有「生老病死」的过程，下图表示了一个线程从创建到消亡的过程，以及过程中的状态<br>
<img src="https://y-rui.github.io/post-images/1608708198359.png" alt="" loading="lazy"><br>
结合线程的生命周期来看看多线程的定义</p>
<ul>
<li>多线程：从软件或者硬件上实现多个线程并发执行的技术。在单个程序中同时运行多个线程完成不同的工作</li>
</ul>
<p>在 Java 中，垃圾回收机制就是通过一个线程在后台实现的，这样做的好处在于：开发者通常不需要为内存管理投入太多的精力。反映到我们现实生活中，在浏览网页时，浏览器能够同时下载多张图片；实验楼的服务器能够容纳多个用户同时进行在线实验，这些都是多线程带来的好处</p>
<p>从专业的角度来看，多线程编程是为了最大限度地利用 CPU 资源——当处理某个线程不需要占用 CPU 而只需要利用 IO 资源时，允许其他的那些需要 CPU 资源的线程有机会利用 CPU。这或许就是多线程编程的最终目的。当然，你也可以进一步了解</p>
<p>对于多线程和线程之间的关系，你可以这样理解：一个使用了多线程技术的程序，包含了两条或两条以上并发运行的线程（Thread）</p>
<h2 id="多线程实现">多线程实现</h2>
<p>Java 中的 Thread 类就是专门用来创建线程和操作线程的类</p>
<p><strong>创建线程</strong><br>
创建线程的方法</p>
<ol>
<li>继承 Thread 类并重写它的 run() 方法，然后用这个子类来创建对象并调用 start() 方法</li>
<li>定义一个类并实现 Runnable 接口，实现 run() 方法</li>
</ol>
<p>总的来说就是线程通过 start() 方法启动而不是 run() 方法，run() 方法的内容为我们要实现的业务逻辑</p>
<p><strong>编程实例</strong><br>
在 /home/project/ 目录下新建一个类 CreateThread</p>
<p>代码片段如下</p>
<pre><code>public class CreateThread {

    public static void main(String[] args) {
        Thread1 thread1 = new Thread1();
        //声明一个Thread1对象，这个Thread1类继承自Thread类的

        Thread thread2 = new Thread(new Thread2());
        //传递一个匿名对象作为参数

        thread1.start();
        thread2.start();
        //启动线程
    }
}

class Thread1 extends Thread {
    @Override
    public void run() {
        //在run()方法中放入线程要完成的工作

        //这里我们把两个线程各自的工作设置为打印100次信息
        for (int i = 0; i &lt; 100; ++i) {
            System.out.println(&quot;Hello! This is &quot; + i);
        }

        //在这个循环结束后，线程便会自动结束
    }
}

class Thread2 implements Runnable {
    //与Thread1不同，如果当一个线程已经继承了另一个类时，就建议你通过实现Runnable接口来构造

    @Override
    public void run() {
        for (int i = 0; i &lt; 100; ++i) {
            System.out.println(&quot;Thanks. There is &quot; + i);
        }
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac CreateThread.java
$ java CreateThread
Hello! This is 0
Hello! This is 1
Hello! This is 2
Thanks. There is 0
Thanks. There is 1
Hello! This is 3
Hello! This is 4
Thanks. There is 2
........
</code></pre>
<p>你在控制台就可以看到两个线程近似交替地在输出信息。受到系统调度的影响，两个线程输出信息的先后顺序可能不同</p>
<h2 id="线程变量">线程变量</h2>
<ul>
<li>ThreadLocal，即线程变量，是一个以 ThreadLocal 对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个 ThreadLocal 对象查询到绑定在这个线程上的一个值。 可以通过 set(T) 方法来设置一个值，在当前线程下再通过 get() 方法获取到原先设置的值</li>
</ul>
<p><strong>编程实例</strong><br>
在 /home/project/ 目录下新建一个源代码文件 ThreadLocalDemo.java</p>
<pre><code>public class ThreadLocalDemo {

    public static void main(String[] args) {
        ThreadDemo threadDemo = new ThreadDemo();
        //启动2个线程
        new Thread(threadDemo).start();
        new Thread(threadDemo).start();

    }
}

class ThreadDemo implements Runnable {
    //使用ThreadLocal提供的静态方法创建一个线程变量 并且初始化值为0
    private static ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; 0);

    @Override
    public void run() {
        for (int i = 0; i &lt; 10; i++) {
            //get方法获取线程变量值
            Integer integer = threadLocal.get();
            integer += 1;
            //set方法设置线程变量值
            threadLocal.set(integer);
            System.out.println(integer);
        }
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac ThreadLocalDemo.java
$ java ThreadLocalDemo
1
1
2
2
3
3
4
4
5
5
6
6
7
7
8
8
9
10
9
10
</code></pre>
<p>通过控制台的结果可以看到，两个线程之间的变量互不干涉</p>
<p><strong>线程共享变量</strong><br>
如果我们去掉了 ThreadLocal，其他的流程都不改变，已经使用 2 个线程自增变量会如何呢？</p>
<p>修改 ThreadLocalDemo.java</p>
<pre><code>public class ThreadLocalDemo {

    public static void main(String[] args) {
        ThreadDemo threadDemo = new ThreadDemo();
        new Thread(threadDemo).start();
        new Thread(threadDemo).start();

    }
}

class ThreadDemo implements Runnable {
    private Integer integer = 0;

    @Override
    public void run() {
        for (int i = 0; i &lt; 10; i++) {
            integer++;
            System.out.println(integer);
        }
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac ThreadLocalDemo.java
$ java ThreadLocalDemo

1
3
4
5
6
7
8
9
10
11
2
12
13
14
15
16
17
18
19
20
</code></pre>
<p>在没有加入 ThreadLocal 的情况下，发现 integer 变量的值增加到了 20，那是因为这个时候两个线程都是使用同一对象 threadDemo 的变量，这个时候的 integer 就变成了线程共享变量，如果同学们多运行几次，还有可能出现最后结果是 18 19 的情况，那是因为如果不做任何处理，线程共享变量都不是线程安全的，也就是说在多线程的情况下，共享变量有可能会出错</p>
<h2 id="线程同步">线程同步</h2>
<p>当多个线程操作同一个对象时，就会出现线程安全问题，被多个线程同时操作的对象数据可能会发生错误。线程同步可以保证在同一个时刻该对象只被一个线程访问</p>
<p><strong>Synchronized</strong><br>
关键字 synchronized 可以修饰方法或者以同步块的形式来进行使用，它确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，保证了线程对变量访问的可见性和排他性。它有三种使用方法</p>
<ul>
<li>对普通方式使用，将会锁住当前实例对象</li>
<li>对静态方法使用，将会锁住当前类的 Class 对象</li>
<li>对代码块使用，将会锁住代码块中的对象</li>
</ul>
<p><strong>使用示例</strong><br>
在下面的代码中，演示了三种加锁方式</p>
<pre><code>public class SynchronizedDemo {
    private static Object lock = new Object();

    public static void main(String[] args) {
        //同步代码块 锁住lock
        synchronized (lock) {
            //doSomething
        }
    }

    //静态同步方法  锁住当前类class对象
    public synchronized static void staticMethod(){

    }
    //普通同步方法  锁住当前实例对象
    public synchronized void memberMethod() {

    }
}
</code></pre>
<p><strong>java.util.concurrent</strong><br>
java.util.concurrent 包是 java5 开始引入的并发类库，提供了多种在并发编程中的适用工具类。包括原子操作类，线程池，阻塞队列，Fork/Join 框架，并发集合，线程同步锁等</p>
<p><strong>Lock 与 Unlock</strong><br>
JUC 中的 ReentrantLock 是多线程编程中常用的加锁方式，ReentrantLock 加锁比 synchronized 加锁更加的灵活，提供了更加丰富的功能</p>
<p><strong>编程实战</strong><br>
在 /home/project/ 目录下新建一个源代码文件 LockDemo.java</p>
<pre><code>import java.util.concurrent.locks.ReentrantLock;

public class LockDemo {
    private static ReentrantLock lock = new ReentrantLock();

    public static void main(String[] args) {
        Thread thread1 = new Thread(() -&gt; {
            lock.lock();
            try {
                //需要同步的代码块
                System.out.println(&quot;线程1加锁&quot;);
            }finally {
//                一定要在finally中解锁，否则可能造成死锁
                lock.unlock();
                System.out.println(&quot;线程1解锁&quot;);
            }
        });
        thread1.start();
        Thread thread2 = new Thread(() -&gt; {
            lock.lock();
            try {
                System.out.println(&quot;线程2加锁&quot;);
            }finally {
                lock.unlock();
                System.out.println(&quot;线程2解锁&quot;);
            }
        });
        thread2.start();
    }

}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac LockDemo.java
$ java LockDemo
线程1加锁
线程1解锁
线程2加锁
线程2解锁
</code></pre>
<h2 id="死锁">死锁</h2>
<p>在多线程环境下，锁的使用非常频繁，但是它会带来一下问题，比如死锁。当死锁发生时，系统将会瘫痪。比如两个线程互相等待对方释放锁</p>
<p><strong>死锁示例</strong><br>
在 /home/project/ 目录下新建一个源代码文件 DeadLockDemo.java</p>
<pre><code>public class DeadLockDemo {
    private static Object lockA = new Object();
    private static Object lockB = new Object();

    public static void main(String[] args) {
        //这里使用lambda表达式创建了一个线程
        //线程  1
        new Thread(() -&gt; {
            synchronized (lockA) {
                try {
                    //线程休眠一段时间  确保另外一个线程可以获取到b锁
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(&quot;D&quot;);
                synchronized (lockB) {
                }
            }
        }).start();
        //线程 2
        new Thread(() -&gt; {
            synchronized (lockB) {
                System.out.println(&quot;死锁...&quot;);
                synchronized (lockA) {
                }
            }
        }).start();
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac DeadLockDemo.java
$ java DeadLockDemo
死锁...
死锁...
</code></pre>
<p>在上面的编程实例中，线程 1 获取了 lockA 的锁后再去获取 lockB 的锁，而此时 lockB 已经被线程 2 获取，同时线程 2 也想获取 lockA，两个线程进这样僵持了下去，谁也不让，造成了死锁。在编程时，应该避免死锁的出现</p>
<h2 id="饥饿">饥饿</h2>
<p>饥饿是指一个可运行的进程尽管能继续执行，但被调度器无限期地忽视，而不能被调度执行的情况</p>
<p>比如当前线程处于一个低优先级的情况下，操作系统每次都调用高优先级的线程运行，就会导致当前线程虽然可以运行，但是一直不能被运行的情况</p>
<h2 id="线程生命周期">线程生命周期</h2>
<p>线程的声明周期共有 6 种状态，分别是：新建 New、运行（可运行）Runnable、阻塞Blocked、计时等待Timed Waiting、等待Waiting 和终止Terminate</p>
<ul>
<li>当你声明一个线程对象时，线程处于新建状态，系统不会为它分配资源，它只是一个空的线程对象</li>
<li>调用 start() 方法时，线程就成为了可运行状态，至于是否是运行状态，则要看系统的调度了</li>
<li>调用了 sleep() 方法、调用 wait() 方法和 IO 阻塞时，线程处于等待、计时等待或阻塞状态</li>
<li>当 run() 方法执行结束后，线程也就终止了</li>
</ul>
<p>我们通过一个例子来加深对于这些状态的理解<br>
在 /home/project/ 目录下新建 ThreadState 类，用于自定义线程的状态。主要的代码如下</p>
<pre><code>public class ThreadState implements Runnable {

    public synchronized void waitForAMoment() throws InterruptedException {

        wait(500);
        //使用wait()方法使当前线程等待500毫秒
        //或者等待其他线程调用notify()或notifyAll()方法来唤醒
    }

    public synchronized void waitForever() throws InterruptedException {

        wait();
        //不填入时间就意味着使当前线程永久等待，
        //只能等到其他线程调用notify()或notifyAll()方法才能唤醒
    }

    public synchronized void notifyNow() throws InterruptedException {

        notify();
        //使用notify()方法来唤醒那些因为调用了wait()方法而进入等待状态的线程
    }

    @Override
    public void run() {

        //这里用异常处理是为了防止可能的中断异常
        //如果任何线程中断了当前线程，则抛出该异常

        try {
            waitForAMoment();
            // 在新线程中运行waitMoment()方法

            waitForever();
            // 在新线程中运行waitForever()方法

        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>然后再新建一个测试类ThreadTest，用于输出这些状态<br>
接下来会用到 sleep() 方法，下面给出了这个方法的使用方法</p>
<ul>
<li>sleep()，在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。填入的参数为休眠的时间（单位：毫秒）</li>
</ul>
<pre><code>public class ThreadTest {
    public static void main(String[] args) throws InterruptedException {
        ThreadState state = new ThreadState();
        //声明并实例化一个ThreadState对象

        Thread thread = new Thread(state);
        //利用这个名为state的ThreadState对象来创建Thread对象

        System.out.println(&quot;Create new thread: &quot; + thread.getState());
        //使用getState()方法来获得线程的状态，并进行输出

        thread.start();
        //使用thread对象的start()方法来启动新的线程

        System.out.println(&quot;Start the thread: &quot; + thread.getState());
        //输出线程的状态

        Thread.sleep(100);
        //通过调用sleep()方法使当前这个线程休眠100毫秒，从而使新的线程运行waitForAMoment()方法

        System.out.println(&quot;Waiting for a moment (time): &quot; + thread.getState());
        //输出线程的状态

        Thread.sleep(1000);
        //使当前这个线程休眠1000毫秒，从而使新的线程运行waitForever()方法

        System.out.println(&quot;Waiting for a moment: &quot; + thread.getState());
        //输出线程的状态

        state.notifyNow();
        // 调用state的notifyNow()方法

        System.out.println(&quot;Wake up the thread: &quot; + thread.getState());
        //输出线程的状态

        Thread.sleep(1000);
        //使当前线程休眠1000毫秒，使新线程结束

        System.out.println(&quot;Terminate the thread: &quot; + thread.getState());
        //输出线程的状态
    }
}
</code></pre>
<p>检查一下代码，编译并运行</p>
<pre><code>$ javac ThreadState.java ThreadTest.java
$ java ThreadTest
Create new thread: NEW
Start the thread: RUNNABLE
Waiting for a moment (time): TIMED_WAITING
Waiting for a moment: WAITING
Wake up the thread: BLOCKED
Terminate the thread: TERMINATED
</code></pre>
<h2 id="练习题顺序打印字母">练习题：顺序打印字母</h2>
<p>在 /home/project/ 目录下新建文件ThreadTest.java<br>
你需要完成以下需求</p>
<ol>
<li>创建三个线程输出 A、B、C 三个字符。</li>
<li>要求 A、B、C 必须顺序输出，连续输出三次</li>
</ol>
<p>结果如下</p>
<pre><code>A
B
C
A
B
C
A
B
C
</code></pre>
<p><strong>参考答案</strong></p>
<pre><code>import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class ThreadTest {
    private static ReentrantLock lock = new ReentrantLock();
    private static int count = 0;
    private static Condition condition = lock.newCondition();

    public static void main(String[] args) {
        Thread A = new Thread(() -&gt; {
        //加锁 一次只有一个线程输出
            lock.lock();
            try {
                while (true) {
                //因为只循环3次 所以到9的时候就结束循环
                    if (count == 9) {
                        break;
                    }
                    //当余数为0 就输出A
                    if (count % 3 == 0) {
                        count++;
                        System.out.println(&quot;A&quot;);
                        //唤醒其他等待线程
                        condition.signalAll();
                    } else {
                        try {
                        //等待
                            condition.await();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            } finally {
                lock.unlock();
            }
        });
        Thread B = new Thread(() -&gt; {
            lock.lock();
            try {
                while (true) {
                    if (count == 9) {
                        break;
                    }
                    if (count % 3 == 1) {
                        count++;
                        System.out.println(&quot;B&quot;);
                        condition.signalAll();
                    } else {
                        try {
                            condition.await();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            } finally {
                lock.unlock();
            }
        });
        Thread C = new Thread(() -&gt; {
            lock.lock();
            try {
                while (true) {
                    if (count == 9) {
                        break;
                    }
                    if (count % 3 == 2) {
                        count++;
                        System.out.println(&quot;C&quot;);
                        condition.signalAll();
                    } else {
                        try {
                            condition.await();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            } finally {
                lock.unlock();
            }
        });

        A.start();
        B.start();
        C.start();

    }
}
</code></pre>
<h2 id="arrayblockingqueue">ArrayBlockingQueue</h2>
<p>ArrayBlockingQueue 是由数组支持的有界阻塞队列。位于 java.util.concurrent 包下<br>
首先看看其构造方法</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>public ArrayBlockingQueue(int capacity)</code></td>
<td>构造大小为 capacity 的队列</td>
</tr>
<tr>
<td><code>public ArrayBlockingQueue(int capacity, boolean fair)</code></td>
<td>指定队列大小，以及内部实现是公平锁还是非公平锁</td>
</tr>
<tr>
<td><code>public ArrayBlockingQueue(int capacity, boolean fair, Collection&lt;? extends E&gt; c)</code></td>
<td>指定队列大小，以及锁实现，并且在初始化是加入集合 c</td>
</tr>
</tbody>
</table>
<p>入队常用方法</p>
<table>
<thead>
<tr>
<th>入队方法</th>
<th>队列已满</th>
<th>队列未满</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>add</code></td>
<td>抛出异常</td>
<td>返回 true</td>
</tr>
<tr>
<td><code>offer</code></td>
<td>返回 false</td>
<td>返回 true</td>
</tr>
<tr>
<td><code>put</code></td>
<td>阻塞直到插入</td>
<td>没有返回值</td>
</tr>
</tbody>
</table>
<p>出队常用方法</p>
<table>
<thead>
<tr>
<th>出队方法</th>
<th>队列为空</th>
<th>队列不为空</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>remove</code></td>
<td>抛出异常</td>
<td>移出并返回队首</td>
</tr>
<tr>
<td><code>poll</code></td>
<td>返回 null</td>
<td>移出并返回队首</td>
</tr>
<tr>
<td><code>take</code></td>
<td>阻塞直到返回</td>
<td>移出并返回队首</td>
</tr>
</tbody>
</table>
<p><strong>编程实战</strong><br>
在 /home/project/ 目录下新建源代码文件 ABQDemo.java</p>
<pre><code>import java.util.concurrent.ArrayBlockingQueue;

public class ABQDemo {
    //构建大小为10的阻塞队列
    private static ArrayBlockingQueue&lt;Integer&gt; arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(10);

    public static void main(String[] args) {
        Thread thread1 = new Thread(() -&gt; {
            for (int i = 1; i &lt;= 10; i++) {
                arrayBlockingQueue.add(i);
            }
        });
        thread1.start();
        try {
            //等待线程1执行完毕
            thread1.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(() -&gt; {
            //如果插入失败
            if (!arrayBlockingQueue.offer(11)) {
                System.out.println(&quot;插入元素11失败&quot;);
            }
            try {
                //一直阻塞直到插入元素11，注意这里阻塞的不是主线程，main方法还是继续运行
                arrayBlockingQueue.put(11);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }).start();
        Thread thread2=new Thread(() -&gt; {
            Integer element;
            System.out.println(&quot;开始出队:&quot;);
            //打印队列中的元素
            while ((element = arrayBlockingQueue.poll()) != null) {
                System.out.print(&quot;\t&quot;+element);
            }
        });
        thread2.start();
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac ABQDemo.java
$ java ABQDemo
插入元素11失败
开始出队:
    1    2    3    4    5    6    7    8    9    10    11
</code></pre>
<h2 id="生产者消费者模式">生产者消费者模式</h2>
<p>生产者消费者模式是多线程编程中非常重要的设计模式，生产者负责生产数据，消费者负责消费数据。生产者消费者模式中间通常还有一个缓冲区，用于存放生产者生产的数据，而消费者则从缓冲区中获取，这样可以降低生产者和消费者之间的耦合度</p>
<p>举个例子来说吧，比如有厂家，代理商，顾客，厂家就是生产者，顾客就是消费者，代理商就是缓冲区，顾客从代理商这里买东西，代理商负责从厂家处拿货，并且销售给顾客，顾客不用直接和厂家打交道，并且通过代理商，就可以直接获取商品，或者从代理商处知道货物不足，需要等待</p>
<p><strong>编程实例</strong><br>
在 /home/project 目录下新建一个源代码文件 PCModel.java</p>
<pre><code>import java.util.Random;
import java.util.concurrent.LinkedBlockingQueue;

public class PCModel {
    //阻塞队列
    private static LinkedBlockingQueue&lt;Integer&gt; queue = new LinkedBlockingQueue&lt;&gt;();

    public static void main(String[] args) {
        //生产者
        Thread provider = new Thread(() -&gt; {
            Random random = new Random();
            for (int j = 0; j &lt; 5; j++) {
                try {
                    int i = random.nextInt();
                    //注释直到插入数据
                    queue.put(i);
                    System.out.println(&quot;生产数据：&quot; + i);
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        //消费者
        Thread consumer = new Thread(() -&gt; {
            Integer data;
            for (int i = 0; i &lt; 5; i++) {
                try {
                    //阻塞直到取出数据
                    data = queue.take();
                    System.out.println(&quot;消费数据：&quot; + data);
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        //启动线程
        provider.start();
        consumer.start();
    }
}
</code></pre>
<p><strong>练习题</strong><br>
在 /home/project 目录下新建一个源代码文件 ProviderConsumerTest.java，你需要完成以下需求</p>
<ul>
<li>参照编程实例，启动多个生产者和消费者生成和消费数据</li>
</ul>
<p>注意：不要直接使用上面的编程实例直接使用多个 provider.start() 或者 consumer.start()，会抛出异常报错，应该重新实例化多个生产者和消费者，不能一个实例启动多次</p>
<h2 id="线程池">线程池</h2>
<ul>
<li>线程池（英语：thread pool）：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度</li>
</ul>
<p>由于 Java 创建和销毁线程都会带来资源上的销毁，所以线程池可以帮助我们复用线程，减少资源消耗</p>
<p><strong>编程实战</strong><br>
Java 线程池可以通过 Executors 工具类创建，Executors 常用方法</p>
<ul>
<li>newFixedThreadPool(int nThreads): 创建一个固定大小为 n 的线程池</li>
<li>newSingleThreadExecutor(): 创建只有一个线程的线程池</li>
<li>newCachedThreadPool(): 创建一个根据需要创建新线程的线程池</li>
</ul>
<p>在 /home/project/ 目录下新建源代码文件 ThreadPoolDemo.java</p>
<pre><code>import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPoolDemo {
    //使用Executors 创建一个固定大小为5的线程池
    private static ExecutorService executorService = Executors.newFixedThreadPool(5);

    public static void main(String[] args) {
//        提交任务
        executorService.submit(() -&gt; {
            for (int i = 0; i &lt; 10; i++) {
                System.out.print(i + &quot; &quot;);
            }
        });
        //停止线程池 并不会立即关闭 ，而是在线程池中的任务执行完毕后才关闭
        executorService.shutdown();
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac ThreadPoolDemo.java
$ java ThreadPoolDemo
0 1 2 3 4 5 6 7 8 9
</code></pre>
<p>除了使用 Executors 工具类帮助我们创建之外，也可以直接创建线程池</p>
<p>在 /home/project/ 目录下新建源代码文件 ThreadPoolDemo2.java</p>
<pre><code>import java.util.concurrent.ExecutorService;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class ThreadPoolDemo2 {
    private static ExecutorService executorService = new ThreadPoolExecutor(
            5, //核心线程数为5
            10,//最大线程数为10
            0L, TimeUnit.MILLISECONDS,//非核心线程存活时间
            new LinkedBlockingQueue&lt;&gt;());//任务队列

    public static void main(String[] args) {
        //提交任务
        executorService.submit(() -&gt; {
            for (int i = 0; i &lt; 10; i++) {
                System.out.print(i + &quot; &quot;);
            }
        });
        //关闭线程池
        executorService.shutdown();
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac ThreadPoolDemo2.java
$ java ThreadPoolDemo2
0 1 2 3 4 5 6 7 8 9
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础8-网络编程]]></title>
        <id>https://y-rui.github.io/post/java-ji-chu-8-wang-luo-bian-cheng/</id>
        <link href="https://y-rui.github.io/post/java-ji-chu-8-wang-luo-bian-cheng/">
        </link>
        <updated>2020-08-28T07:09:11.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。java.net 包中 J2SE 的 API 包含有类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。本节重点讲解 Java 网络编程中的常用类，以及计算机网络的一些基础知识</li>
</ul>
<h2 id="socket-简介">Socket 简介</h2>
<p>网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个 socket</p>
<p>建立网络通信连接至少要一对端口号 (socket)。socket 本质是编程接口 (API)，对 TCP/IP 的封装，TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口；HTTP 是轿车，提供了封装或者显示数据的具体形式；Socket 是发动机，提供了网络通信的能力</p>
<p>Socket 的英文原义是“孔”或“插座”。作为 BSD UNIX 的进程通信机制，取后一种意思。通常也称作&quot;套接字&quot;，用于描述 IP 地址和端口，是一个通信链的句柄，可以用来实现不同虚拟机或不同计算机之间的通信。在 Internet 上的主机一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个 Socket，并绑定到一个端口上，不同的端口对应于不同的服务。Socket 正如其英文原义那样，像一个多孔插座。一台主机犹如布满各种插座的房间，每个插座有一个编号，有的插座提供 220 伏交流电， 有的提供 110 伏交流电，有的则提供有线电视节目。 客户软件将插头插到不同编号的插座，就可以得到不同的服务</p>
<h2 id="tcp">TCP</h2>
<p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。在简化的计算机网络 OSI 模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内另一个重要的传输协议。在因特网协议族（Internet protocol suite）中，TCP 层是位于 IP 层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是 IP 层不提供这样的流机制，而是提供不可靠的包交换</p>
<p>应用层向 TCP 层发送用于网间传输的、用 8 位字节表示的数据流，然后 TCP 把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制）。之后 TCP 把结果包传给 IP 层，由它来通过网络将包传送给接收端实体的 TCP 层。TCP 为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP 用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和</p>
<h2 id="udp">UDP</h2>
<p>UDP 是 User Datagram Protocol 的简称， 中文名是用户数据报协议，是 OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，IETF RFC 768 是 UDP 的正式规范。UDP 在 IP 报文的协议号是 17</p>
<p>UDP 协议全称是用户数据报协议，在网络中它与 TCP 协议一样用于处理数据包，是一种无连接的协议。在 OSI 模型中，在第四层——传输层，处于 IP 协议的上一层。UDP 有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。UDP 用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的客户 / 服务器模式的网络应用都需要使用 UDP 协议。UDP 协议从问世至今已经被使用了很多年，虽然其最初的光彩已经被一些类似协议所掩盖，但是即使是在今天 UDP 仍然不失为一项非常实用和可行的网络传输层协议</p>
<p>与所熟知的 TCP（传输控制协议）协议一样，UDP 协议直接位于 IP（网际协议）协议的顶层。根据 OSI（开放系统互连）参考模型，UDP 和 TCP 都属于传输层协议。UDP 协议的主要作用是将网络数据流量压缩成数据包的形式。一个典型的数据包就是一个二进制数据的传输单位。每一个数据包的前 8 个字节用来包含报头信息，剩余字节则用来包含具体的传输数据</p>
<h2 id="httpurlconnection">HttpURLConnection</h2>
<p>HttpURLConnection 位于 java.net 包中，支持 HTTP 特定功能。我们可以使用它来发起网络请求，获取服务器的相关资源</p>
<p><strong>编程实战</strong><br>
HttpURLConnection 提供了很多方法用于使用 Http，这里只演示了使用 HttpURLConnection 类的基本流程</p>
<p>在 /home/project/ 目录下新建源代码文件 HttpUrlTest.java</p>
<pre><code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;

public class HttpUrlTest {
    public static void main(String[] args) {
        try {
            //设置url
            URL shiyanlou = new URL(&quot;https://www.lanqiao.cn&quot;);
            //打开连接
            HttpURLConnection urlConnection = (HttpURLConnection)shiyanlou.openConnection();
            //设置请求方法
            urlConnection.setRequestMethod(&quot;GET&quot;);
            //设置连接超时时间
            urlConnection.setConnectTimeout(1000);
            //获取输入流
            InputStream inputStream = urlConnection.getInputStream();
            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
            //打印结果
            bufferedReader.lines().forEach(System.out::println);
            //关闭连接
            inputStream.close();
            bufferedReader.close();
            urlConnection.disconnect();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<pre><code>$ javac HttpUrlTest.java
$ java HttpUrlTest
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;zh-CN&quot;&gt;
.....内容过长省略.....
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>如果没有问题的话，那么我们将看到实验楼首页的 html 源代码</p>
<h2 id="inetaddress-类">InetAddress 类</h2>
<p>InetAddress类用于表示 IP 地址，比如在进行 Socket 编程时，就会使用到该类</p>
<p>InetAddress没有公共构造方法，我们只能使用它提供的静态方法来构建一个 InetAddress 类实例</p>
<ul>
<li>getLocalHost()： 返回本地主机地址</li>
<li>getAllByName（String host）：从指定的主机名返回 InetAddress 对象的数组，因为主机名可以与多个 IP 地址相关联</li>
<li>getByAddress（byte [] addr）：从原始 IP 地址的字节数组中返回一个 InetAddress 对象</li>
<li>getByName（String host）：根据提供的主机名创建一个 InetAddress 对象</li>
<li>getHostAddress()：返回文本表示的 IP 地址字符串</li>
<li>getHostname()：获取主机名</li>
</ul>
<p><strong>编程实战</strong><br>
在 /home/project 目录下新建一个 InetAddressDemo.java</p>
<pre><code>import java.net.InetAddress;
import java.net.UnknownHostException;

public class InetAddressDemo {
    public static void main(String[] args) {
        try {
            InetAddress shiyanlou = InetAddress.getByName(&quot;www.lanqiao.cn&quot;);
            //toString 方法将输出主机名和ip地址
            System.out.println(shiyanlou.toString());
            //获取ip地址
            String ip = shiyanlou.toString().split(&quot;/&quot;)[1];
            //根据IP地址获取主机名
            InetAddress byAddress = InetAddress.getByName(ip);
            System.out.println(&quot;get hostname by IP address:&quot; + byAddress.getHostName());
            System.out.println(&quot;localhost: &quot;+InetAddress.getLocalHost());
        } catch (UnknownHostException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>javac InetAddressDemo.java
java InetAddressDemo
</code></pre>
<p>运行结果</p>
<pre><code>www.lanqiao.cn/121.40.227.60
get hostname by IP address:www.shiyanlou.com
localhost: 90ce6f59cfd6/192.168.42.3
</code></pre>
<h2 id="socket">Socket</h2>
<p>Socket 类代表一个客户端套接字，可以使用该类向服务器发送和接受数据。一般需要通过下面几个步骤</p>
<ol>
<li>建立与服务器的连接</li>
<li>使用输出流将数据发送到服务器</li>
<li>使用输入流读取服务器返回的数据</li>
<li>关闭连接</li>
</ol>
<p><strong>构造方法</strong><br>
Socket 常用构造方法</p>
<ul>
<li>Socket(InetAddress address, int port)：创建一个套接字，连接到指定 IP 地址和端口的服务器</li>
<li>Socket(String host, int port)：创建一个套接字，连接到指定的主机名和端口的服务器</li>
<li>Socket(InetAddress address, int port, InetAddress localAddr, int localPort)：创建一个套接字连接到指定的 IP 地址和端口的服务器，并且显示的指定客户端地址和端口</li>
</ul>
<p>在创建 Socket 时，需要捕获异常</p>
<p><strong>getOutputStream()</strong><br>
该方法可以获取输出流，在建立连接后，可以使用该方法获取输出流，发送数据到服务器。发送数据的方式和使用 IO 流是相同的，使用 write 方法发送指定的数据即可</p>
<p><strong>getInputStream()</strong><br>
用户获取输入流，通过该方法获取输入流之后可以读取服务器发送来的数据。使用方法和 IO 流相同，使用 read 方法即可</p>
<p><strong>close()</strong><br>
关闭 Socket，可能抛出 IO 异常，所以我们同样需要捕获异常</p>
<h2 id="serversocket">ServerSocket</h2>
<p>ServerSocket类用于实现服务器套接字，服务器套接字会等待客户端网络连接，与客户端连接之后，会进行一系列操作，然后将结果返回给客户端</p>
<p>创建一个 ServerSocket 一般需要以下几个步骤</p>
<ol>
<li>创建服务器套接字并将其绑定到特定的接口</li>
<li>等待客户端连接</li>
<li>通过客户端套接字获取输入流，从客户端读取数据</li>
<li>通过客户端套接字获取输出流，发送数据到客户端</li>
<li>关闭套接字</li>
</ol>
<p><strong>构造方法</strong><br>
常见构造方法</p>
<ul>
<li>ServerSocket()：创建一个未绑定端口的服务器套接字</li>
<li>ServerSocket(int port)：创建绑定到指定端口号的服务器套接字</li>
<li>ServerSocket(int port,int backlog)：创建一个绑定到指定端口号的服务器套接字，并且backlog 参数指定了最大排队连接数</li>
<li>ServerSocket(int port,int backlog,InetAddress bindAddr)：创建服务器套接字并将其绑定到指定的端口号和本地 IP 地址</li>
</ul>
<p>示例</p>
<pre><code>ServerSocket serverSocket = new ServerSocket(8888);
</code></pre>
<p><strong>accept()</strong><br>
用于监听客户端连接请求，当调用该方法时，会阻塞当前线程，直到有客户端发起请求与其建立连接，否则将一直等待。当连接成功后，将返回一个 Socket 对象</p>
<p>ServerSocket<br>
ServerSocket类用于实现服务器套接字，服务器套接字会等待客户端网络连接，与客户端连接之后，会进行一系列操作，然后将结果返回给客户端。</p>
<p>创建一个 ServerSocket 一般需要以下几个步骤：</p>
<p>创建服务器套接字并将其绑定到特定的接口<br>
等待客户端连接<br>
通过客户端套接字获取输入流，从客户端读取数据<br>
通过客户端套接字获取输出流，发送数据到客户端<br>
关闭套接字<br>
构造方法<br>
常见构造方法：</p>
<p>ServerSocket()：创建一个未绑定端口的服务器套接字。</p>
<p>ServerSocket(int port)：创建绑定到指定端口号的服务器套接字。</p>
<p>ServerSocket(int port,int backlog)：创建一个绑定到指定端口号的服务器套接字，并且backlog 参数指定了最大排队连接数。</p>
<p>ServerSocket(int port,int backlog,InetAddress bindAddr)：创建服务器套接字并将其绑定到指定的端口号和本地 IP 地址。</p>
<p>示例：</p>
<p>ServerSocket serverSocket = new ServerSocket(8888);<br>
copy<br>
accept()<br>
用于监听客户端连接请求，当调用该方法时，会阻塞当前线程，直到有客户端发起请求与其建立连接，否则将一直等待。当连接成功后，将返回一个 Socket 对象。</p>
<p><strong>close()</strong><br>
用于关闭服务器套接字，服务器停止后，将断开所有连接</p>
<h2 id="网络编程实例">网络编程实例</h2>
<p>java.net 包提供了两个类 Socket 和 ServerSocket，分别实现 Socket 连接的客户端和服务器端</p>
<p>我们编译一个简单的 Socket 应用，实现客户端发送信息给服务端，服务端再将信息发送回客户端的回显的功能</p>
<p>在 /home/project/ 目录下新建源代码文件 EchoServer.java</p>
<pre><code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;


public class EchoServer {
    public static void main(String[] args) {
        try {
            //服务端需要使用ServerSocket类
            ServerSocket serverSocket = new ServerSocket(1080);
            //阻塞 等待客户端连接
            Socket client = serverSocket.accept();
            PrintWriter out = new PrintWriter(client.getOutputStream(), true);
            BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));
            String userIn;
            while ((userIn = in.readLine()) != null) {
                System.out.println(&quot;收到客户端消息：&quot; + userIn);
                //发回客户端
                out.println(userIn);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>在 /home/project/ 目录下新建源代码文件 EchoClient.java</p>
<pre><code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.Scanner;

public class EchoClient {
    public static void main(String[] args) {
        String hostname = &quot;127.0.0.1&quot;;
        //socket端口
        int port = 1080;
        Scanner userIn = new Scanner(System.in);
        try {
            //建立socket连接
            Socket socket = new Socket(hostname, port);
            //获取socket输出流
            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
            //获取输入流
            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            String userInput;
            System.out.println(&quot;请输入信息：&quot;);
            //当用户输入exit时退出
            while (!&quot;exit&quot;.equals(userInput = userIn.nextLine())) {
                out.println(userInput);
                System.out.println(&quot;收到服务端回应:&quot; + in.readLine());
            }
            //关闭socket
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>编译运行</p>
<p>打开两个 terminal，一个运行服务端，一个运行客户端</p>
<p>首先启动服务端，不能先启动客户端，否则报错</p>
<p>服务端启动命令</p>
<pre><code>$ javac EchoServer.java
$ java EchoServer
</code></pre>
<p>接着切换到客户端 terminal。客户端启动命令</p>
<pre><code>$ javac EchoClient.java
$ java EchoClient
</code></pre>
<p>运行结果</p>
<ul>
<li>客户端</li>
</ul>
<pre><code>请输入信息：
shi
收到服务端回应:shi
yan
收到服务端回应:yan
lou
收到服务端回应:lou
exit
</code></pre>
<ul>
<li>服务端</li>
</ul>
<pre><code>收到客户端消息：shi
收到客户端消息：yan
收到客户端消息：lou
</code></pre>
<h2 id="练习题多线程服务器">练习题：多线程服务器</h2>
<p>在 /home/project/ 目录下新建源代码文件 Server.java 和Client.java</p>
<p>你需要完成以下要求</p>
<ul>
<li>Server 可以同时接受多个客户端的连接</li>
<li>每个线程负责一个连接</li>
<li>客户端发送消息给服务端，服务端再将客户端发送的消息发回客户端</li>
</ul>
<p>参考答案<br>
client</p>
<pre><code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.Scanner;

public class Client {
    public static void main(String[] args) {
        String hostname = &quot;127.0.0.1&quot;;
        //socket端口
        int port = 1080;
        Scanner userIn = new Scanner(System.in);
        try {
            //建立socket连接
            Socket socket = new Socket(hostname, port);
            //获取socket输出流
            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
            //获取输入流
            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            String userInput;
            System.out.println(&quot;请输入信息：&quot;);
            //当用户输入exit时退出
            while (!&quot;exit&quot;.equals(userInput = userIn.nextLine())) {
                out.println(userInput);
                System.out.println(&quot;收到服务端回应:&quot; + in.readLine());
            }
            //关闭socket
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>server</p>
<pre><code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;


public class Server {
    public static void main(String[] args) {
        try {
            //服务端需要使用ServerSocket类
            ServerSocket serverSocket = new ServerSocket(1080);
            //阻塞 等待客户端连接
            while (true) {
                Thread thread = new Thread(new ServerThread(serverSocket.accept()));
                thread.start();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    static class ServerThread implements Runnable {
        Socket client;

        public ServerThread(Socket client) {
            this.client = client;
        }

        @Override
        public void run() {
            try {
                PrintWriter out = new PrintWriter(client.getOutputStream(), true);
                BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));
                String userIn;
                while ((userIn = in.readLine()) != null) {
                    System.out.println(&quot;收到客户端消息：&quot; + userIn);
                    //发回客户端
                    out.println(userIn);
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础7-IO]]></title>
        <id>https://y-rui.github.io/post/java-ji-chu-7-io/</id>
        <link href="https://y-rui.github.io/post/java-ji-chu-7-io/">
        </link>
        <updated>2020-08-27T05:03:04.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>整个 Java.io 包中最重要的就是 5 个类。指的是 File、OutputStream、InputStream、Writer、Reader；本节将重点讲解 Java.io 的相关内容</li>
</ul>
<h2 id="文件">文件</h2>
<ul>
<li>Java 使用 File 类来直接处理文件和文件系统。File 类没有指定信息怎样从文件读取或向文件存储；它描述了文件本身的属性。File 对象用来获取或处理与磁盘文件相关的信息，例如权限，时间，日期和目录路径。此外，File 还浏览子目录层次结构。Java 中的目录当成 File 对待，它具有附加的属性——一个可以被 list() 方法检测的文件名列表</li>
</ul>
<p><strong>构造方法</strong><br>
File 类提供了以下构造方法</p>
<pre><code>//根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例。
File(File parent, String child)

//通过将给定路径名字符串转换为抽象路径名来创建一个新 File 实例
File(String pathname)

// 根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例
File(String parent, String child)

//通过将给定的 file: URI 转换为一个抽象路径名来创建一个新的 File 实例
File(URI uri)
</code></pre>
<p><strong>使用示例</strong></p>
<pre><code>//一个目录路径参数
File f1 = new File(&quot;/home/project/&quot;);

//对象有两个参数——路径和文件名
File f2 = new File(&quot;/home/project/&quot;,&quot;a.bat&quot;);

//指向f1文件的路径及文件名
File f3 = new File(f1,&quot;a.bat&quot;);
</code></pre>
<p><strong>常用方法</strong></p>
<p><strong>编程实例</strong><br>
在 /home/porject/ 目录下创建源代码文件 FileDemo.java</p>
<pre><code>import java.io.File;
import java.io.IOException;

public class  FileDemo {
    public static void main(String[] args){
        //同学们可以根据自己的路径进行更改
        File f1 =new
        File(&quot;/home/project/1.txt&quot;);
        //File(String parent,String child)
        File f2 =new File(&quot;/home/project&quot;,&quot;2.txt&quot;);
        //separator 跨平台分隔符
        File f3 =new File(&quot;/home&quot;+File.separator+&quot;project&quot;);
        File f4 =new File(f3,&quot;3.txt&quot;);

        try {
             System.out.println(f1);
                //当文件存在时返回 false；不存在时返回 true
                System.out.println(f2.createNewFile());
                //当文件不存在时返回 false
                System.out.println(f3.delete());
        }catch(IOException e) {
                e.printStackTrace();
        }

        //列出磁盘下的文件和文件夹
        File[] files =File.listRoots();
        for(File file:files){
            System.out.println(file);
            if(file.length()&gt;0){
                String[] filenames =file.list();
                for(String filename:filenames){
                    System.out.println(filename);
                }
            }
        }
    }

}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac FileDemo.java
$ java FileDemo
</code></pre>
<p><strong>文件流</strong><br>
java.io 包中提供了文件操作类</p>
<ul>
<li>用于读写本地文件系统中的文件：FileInputStream 和 FileOutputStream</li>
<li>描述本地文件系统中的文件或目录：File、FileDescriptor 和 FilenameFilter</li>
<li>提供对本地文件系统中文件的随机访问支持：RandomAccessFile</li>
</ul>
<p>接下来将学习文件流的 FileInputStream 和 FileOutputStream</p>
<p>FileInputStream 类用于打开一个输入文件，若要打开的文件不存在，则会产生异常 FileNotFoundException，这是一个非运行时异常，必须捕获或声明抛弃</p>
<p>在进行文件的读 / 写操作时，会产生非运行时异常 IOException，必须捕获或声明抛弃（其他的输入 / 输出流处理时也同样需要进行输入 / 输出异常处理）</p>
<p><strong>文件流的构造方法</strong></p>
<pre><code>//打开一个以 f 描述的文件作为输入
FileInputStream(File f)

//打开一个文件路径名为 name 的文件作为输入
FileInputStream(String name)

//创建一个以 f 描述的文件作为输出
//如果文件存在，则其内容被清空
FileOutputStream(File f)

//创建一个文件路径名为 name 的文件作为输出
//文件如果已经存在，则其内容被清空
FileOutputStream(String name)

//创建一个文件路径名为 name 的文件作为输出
//文件如果已经存在，则在该输出上输出的内容被接到原有内容之后
FileOutputStream(String name, boolean append)
</code></pre>
<p>代码示例</p>
<pre><code>File f1 = new File(&quot;file1.txt&quot;);
File f2 = new File(&quot;file2.txt&quot;);
FileInputStream in = new FileInputStream(f1);
FileOutputStream out = new FileOutputStream(f2);
</code></pre>
<p>输入流的参数是用于指定输入的文件名，输出流的参数则是用于指定输出的文件名</p>
<p><strong>编程实战</strong><br>
使用输入流和输出将 file1.txt 的内容复制到 file2.txt。 在 /home/project/ 目录下新建 Txt 文件 file1.txt。填入内容比如 shiyanlou。 在 /home/project/ 目录下新建源代码文件 Test.java</p>
<pre><code>import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

public class Test {

    public static void main(String[] args) {
        try {
            //inFile 作为输入流的数据文件必须存在，否则抛出异常
            File inFile = new File(&quot;/home/project/file1.txt&quot;);

            //file2.txt没有，系统可以创建
            File outFile = new File(&quot;file2.txt&quot;);
            FileInputStream fis = new FileInputStream(inFile);
            FileOutputStream fos = new FileOutputStream(outFile);
            int c;
            while((c = fis.read()) != -1){
                fos.write(c);
            }
            //打开了文件一定要记着关，释放系统资源
            fis.close();
            fos.close();
        }catch(FileNotFoundException e) {
            System.out.println(&quot;FileStreamsTest:&quot; + e);
        }catch(IOException e){
            System.err.println(&quot;FileStreamTest:&quot; + e);
        }
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac Test.java
$ java Test
</code></pre>
<p>运行完成后，打开 file2.txt，可以看到 file2 和 file1 有相同的内容</p>
<p><strong>FileReader</strong><br>
如果文件内容保存的是字符信息，如 txt 文件等，还可以使用 FileReader 来读取文件内容</p>
<p>代码示例</p>
<pre><code>FileReader file = new FileReader(&quot;/home/project/shiyanlou.txt&quot;);
//声明一个文件输入流file，并指明该文件在系统中的路径以方便定位

int data = 0;
//声明一个整型变量用于存放读取的数据

while((data=file.read())!=-1){
    //在while循环中使用read()方法持续读取file，数据赋到data中
    //如果读取失败或者结束，则将返回-1，这个特殊的返回值可以作为读取结束的标识

    System.out.print((char)data);
    //输出读取到数据
}

file.close();
//一定要记得读取结束后要关闭文件
</code></pre>
<h2 id="随机读写">随机读写</h2>
<p>对于 FileInputStream/FileOutputStream、FileReader/FileWriter 来说，它们的实例都是顺序访问流，即只能进行顺序读 / 写。而类 RandomAccessFile 则允许文件内容同时完成读和写操作，它直接继承 Object，并且同时实现了接口 DataInput 和 DataOutput</p>
<p>随机访问文件的行为类似存储在文件系统中的一个大型 byte 数组。存在指向该隐含数组的光标或索引，称为文件指针；输入操作从文件指针开始读取字节，并随着对字节的读取而前移此文件指针。如果随机访问文件以读取 / 写入模式创建，则输出操作也可用；输出操作从文件指针开始写入字节，并随着对字节的写入而前移此文件指针</p>
<p>RandomAccessFile 提供了支持随机文件操作的方法</p>
<ol>
<li><code>readXXX()</code> 或者 <code>writeXXX()</code>: 如 <code>readInt()</code>, <code>readLine()</code>, <code>writeChar()</code>, <code>writeDouble()</code> 等</li>
<li><code>int skipBytes(int n)</code>: 将指针向下移动若干字节</li>
<li><code>int length()</code>: 返回文件长度</li>
<li><code>long getFilePointer()</code>: 返回指针当前位置</li>
<li><code>void seek(long pos)</code>: 将指针调用所需位置</li>
</ol>
<p>在生成一个随机文件对象时，除了要指明文件对象和文件名之外，还需要指明访问文件的模式</p>
<p>来看看 RandomAccessFile 的构造方法</p>
<pre><code>RandomAccessFile(File file,String mode)
RandomAccessFile(String name,String mode)
</code></pre>
<p>mode 的取值</p>
<ul>
<li>r: 只读，任何写操作都讲抛出 IOException</li>
<li>rw: 读写，文件不存在时会创建该文件，文件存在是，原文件内容不变，通过写操作改变文件内容</li>
<li>rws: 打开以便读取和写入，对于 &quot;rw&quot;，还要求对文件的内容或元数据的每个更新都同步写入到底层存储设备</li>
<li>rwd: 打开以便读取和写入，对于 &quot;rw&quot;，还要求对文件内容的每个更新都同步写入到底层存储设备</li>
</ul>
<p><strong>练习题：随机访问文件</strong><br>
在 /home/project/ 目录下新建源代码文件RandomFile.java，你需要完成以下需求</p>
<ul>
<li>下载文件 randomAccess.file</li>
<li>从偏移量为 10 的位置开始读取文件 randomAccess.file 的内容</li>
<li>输出文件内容（以字符串形式，不能直接输出字节内容）</li>
</ul>
<p>文件下载</p>
<pre><code>wget https://labfile.oss.aliyuncs.com/courses/1230/randomAccess.file
</code></pre>
<p>参考答案</p>
<pre><code>import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.Arrays;

public class RandomFile {
    public static void main(String[] args) {
        RandomAccessFile file;
        try {
            File d = new File(&quot;/home/project/randomAccess.file&quot;);
            file = new RandomAccessFile(d, &quot;rw&quot;);
            file.seek(10);
            byte[] b = new byte[(int) file.length()-10];
            file.read(b);
            System.out.println(new String(b));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p><strong>代码练习</strong><br>
在 /home/project/ 目录下新建 FileDemo.java</p>
<pre><code>// FileDemo.java
import java.io.IOException;
import java.io.RandomAccessFile;

public class  FileDemo {
    public static void main(String[] args){

            int data_arr[] = {12, 32, 43, 45, 1, 5};
            try {
                RandomAccessFile randf=new RandomAccessFile(&quot;temp.dat&quot;,&quot;rw&quot;);
                for(int i = 0; i &lt; data_arr.length; i++){
                    randf.writeInt(data_arr[i]);
                }
                for(int i = data_arr.length-1 ; i &gt;= 0; i--){
                    //int 数据占4个字节
                    randf.seek(i * 4L);
                    System.out.println(randf.readInt());
                }
                randf.close();
            }catch(IOException e){
                System.out.println(&quot;File access error&quot; + e);
            }
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac FileDemo.java
$ java FileDemo
5
1
45
43
32
12
</code></pre>
<h2 id="文件操作">文件操作</h2>
<p><strong>拷贝</strong><br>
可以使用 Files 工具类的 copy(Path source,Path target,CopyOption... options) 拷贝文件或者目录。如果目标文件存在，那么赋值将失败，除非我们在 options 中指定了 REPLACE_EXISTING 属性。当该命令复制目录时，如果目录中已经有了文件，目录中的文件将不会被复制。CopyOption 参数支持以下 StandardCopyOption 和 LinkOption 枚举</p>
<ul>
<li>REPLACE_EXISTING：即使目标文件已存在，也执行复制。如果目标是符号链接，则复制链接本身（而不是链接的目标）。如果目标是非空目录，则复制将失败并显示 FileAlreadyExistsException 异常</li>
<li>COPY_ATTRIBUTES：将与文件关联的文件属性复制到目标文件。支持的确切 - 文件属性是文件系统和平台相关的，但 last-modified-time 跨平台支持并复制到目标文件。 NOFOLLOW_LINKS：表示不应遵循符号链接。如果要复制的文件是符号链接，则复制链接（而不是链接的目标）</li>
</ul>
<p><strong>编程实例</strong><br>
在 /home/project/ 目录下新建文件 1.txt。 在 /home/project/ 目录下新建源代码文件 CopyDemo.java</p>
<pre><code>import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;

public class CopyDemo {
    public static void main(String[] args) {
        try {
            //被拷贝的文件一定要存在 否则会抛出异常  这里的1.txt一定要存在
            Files.copy(Paths.get(&quot;/home/project/1.txt&quot;), Paths.get(&quot;/home/project/2.txt&quot;), StandardCopyOption.REPLACE_EXISTING);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac CopyDemo.java
$ java CopyDemo
</code></pre>
<p>查看目录，如果没有报错，那么可以看到 1.txt 已经被复制了一份，叫做 2.txt</p>
<p><strong>移动和重命名</strong><br>
Files 类的 move(Path, Path, CopyOption... options) 方法移动文件或者目录，同样目标目录存在，那么比如使用REPLACE_EXISTING。 options 参数支持 StandardCopyOption 的以下枚举</p>
<ul>
<li>REPLACE_EXISTING：即使目标文件已存在，也执行移动。如果目标是符号链接，则替换符号链接，但它指向的内容不受影响</li>
<li>ATOMIC_MOVE：将移动作为原子文件操作执行。如果文件系统不支持原子移动，则抛出异常。使用，ATOMIC_MOVE 您可以将文件移动到目录中，并保证观察目录的任何进程都可以访问完整的文件</li>
</ul>
<p>move 方法除了可以移动之外，也可以用与重命名</p>
<p><strong>编程实例</strong><br>
在 /home/project/ 目录下新建源代码文件 MoveDemo.java</p>
<pre><code>import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;

public class MoveDemo {
    public static void main(String[] args) {
        try {
            //将1.txt 重命名为3.txt 如果只需要移动到不同的目录，文件名不变即可
            Files.move(Paths.get(&quot;/home/project/1.txt&quot;), Paths.get(&quot;/home/project/3.txt&quot;), StandardCopyOption.REPLACE_EXISTING);

        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac MoveDemo.java
$ java MoveDemo
renameTo移动结果：true
</code></pre>
<p>查看目录结构，可以看到之前的 1.txt 已经变成了 3.txt，2.txt 变成了 4.txt</p>
<p><strong>删除</strong><br>
可以通过 Files 的 delete(Path path) 方法或者 deleteIfExists(Path path) 方法删除文件</p>
<p><strong>编程实例</strong><br>
在 /home/project/ 目录下新建源代码文件 DeleteDemo.java</p>
<pre><code>import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

public class DeleteDemo {
    public static void main(String[] args) {
        try {
            //删除文件，文件必须存在，否则抛出异常
            Files.delete(Paths.get(&quot;/home/project/3.txt&quot;));
            //删除文件，返回是否删除成功 即使文件不存在，也不会保存，直接返回false
            System.out.println(Files.deleteIfExists(Paths.get(&quot;/home/project/3.txt&quot;)));
            //或者使用File类的delete方法
            File file = new File(&quot;/home/project/4.txt&quot;);
            System.out.println(file.delete());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<pre><code>$ javac DeleteDemo.java
$ java DeleteDemo
false
true
</code></pre>
<p>再次查看文件目录，3.txt 、4.txt 已经不存在了</p>
<p><strong>文件属性</strong><br>
Java 使用 File 类表示文件或者目录，可以通过 File 类获取文件或者目录的相关属性</p>
<p><strong>编程实例</strong><br>
在 /home/project/ 目录下新建源代码文件FileInfo.java</p>
<pre><code>import java.io.File;
import java.util.Arrays;

public class FileInfo {
   public static void main(String[] args) {
       File file = new File(&quot;/home/project&quot;);
       System.out.println(&quot;文件或者目录名：&quot; + file.getName());
       System.out.println(&quot;绝对路径：&quot; + file.getAbsolutePath());
       System.out.println(&quot;父目录：&quot; + file.getParent());
       System.out.println(&quot;文件路径：&quot; + file.getPath());
       //判断文件是否是目录
       if (file.isDirectory()) {
           //打印目录中的文件
           Arrays.stream(file.list()).forEach(System.out::println);
       }
       System.out.println(&quot;是否隐藏：&quot; + file.isHidden());
       System.out.println(&quot;是否存在：&quot; + file.exists());
   }
}
</code></pre>
<pre><code>$ javac FileInfo.java
$ java FileInfo
文件或者目录名：project
绝对路径：/home/project
父目录：/home
文件路径：/home/project
FileInfo.class
FileInfo.java
是否隐藏：false
是否存在：true
</code></pre>
<p><strong>目录读取</strong><br>
Java 中读取目录中的文件可以直接使用 listFiles() 方法读取，但是也只能读取当前目录中的文件，如果当前目录中还有二级目录如何解决呢？三级目录呢？接下来将使用 Java 读取当前目录和子目录中的所有文件</p>
<p><strong>编程实战</strong><br>
在 /home/project/ 目录下新建源代码文件 ReadDir.java</p>
<pre><code>import java.io.File;
public class ReadDir {
    public static void main(String[] args) {
        readDir(new File(&quot;/home&quot;));
    }

    static void readDir(File file) {
        if (file == null) {
            return;
        }
        //如果当前file是目录
        if (file.isDirectory()) {
            File[] files;
            //如果目录不为空
            if ((files = file.listFiles()) != null) {
                for (File file1 : files) {
                    //递归读取目录内容
                    readDir(file1);
                }
            }
        } else {
            //如果不是目录 直接输出文件名
            System.out.println(file.getName());
        }
    }
}
</code></pre>
<pre><code>$ javac ReadDir.java
$ java ReadDir
</code></pre>
<p><strong>练习题：目录树</strong><br>
在 /home/project/ 目录下新建源代码文件 PrintDirTree.java，你需要完成以下需求</p>
<ul>
<li>任意建立一个至少三层的目录</li>
<li>打印该目录以目录树的形式，就像这样</li>
</ul>
<pre><code>src
   main
       java
           a.java
           b.java
           c.java
        resources
    test
        java
            d.java
            e.java
</code></pre>
<p>提示</p>
<ul>
<li>使用递归</li>
</ul>
<p><strong>参考答案</strong></p>
<pre><code>import java.io.File;
import java.io.IOException;

public class PrintDirTree {

    public static void main(String[] args) {
        printDirTree(new File(&quot;/home/&quot;), &quot;&quot;);
    }

    public static void printDirTree(File file, String s) {
        if (file.isDirectory()) {
            File[] files;
            System.out.println(s + file.getName());
            if ((files = file.listFiles()) != null) {
                s = s + &quot;   &quot;;
                for (File file1 : files) {
                    printDirTree(file1, s);
                }
            }
        } else {
            System.out.println(s + file.getName());
        }
    }
}
</code></pre>
<h2 id="io-流">IO 流</h2>
<p>在大多数程序中，都需要对输入输出进行处理。例如我们中需要获取用户从键盘上的输入，需要在控制台输出结果等等。除此之外还有从文件中读取数据，向文件中写入数据等等。在 Java 中，我们把这些不同类型的输入输出源抽象地称为 <em>流</em>，也就是 Stream；在里面输入输出的数据则称为数据流（Data Stream），它们通常具有统一的接口</p>
<p>于是我们得到了数据流的定义</p>
<ul>
<li>一个 Java I/O 对象叫做数据流。读取数据到内存的对象叫做输入流，内存写出数据的对象叫做输出流</li>
</ul>
<p>针对其面向的不同角度，我们大致可以将流分为下面几种类型</p>
<ul>
<li>按照数据流的方向不同分为 输入流 和 <code>_输出流_</code>。这种分类不是绝对的，例如在向一个文件写入数据时，它就是输出流；而在读取数据时，它就是输入流</li>
<li>按照处理数据的单位不同分为 字节流 和 <code>_字符流_</code></li>
<li>按照功能的不同分为 节点流 和 <code>_处理流_</code></li>
</ul>
<p>需要特别说明，节点流是从特定的数据节点（文件、数据库、内存等）读写数据；处理流是连接在已有的流上，通过对数据的处理为程序提供更多功能</p>
<p>在 Java 环境中，java.io 包提供了大多数的类和接口来实现输入输出管理。一些标准的输入输出则来自 java.lang 包中的类，但它们都是继承自 java.io 中的类。我们可以将输入流理解为数据的提供者，而把输出流理解为数据的接收者。在最初的时候，这些派生自抽象类 InputStream 和 OutputStream 的输入输出类是面向 8 位的字节流的。但为了支持国际化，又引入了派生自抽象类 Reader 和 Writer 的类层次，用于读写一些双字节的 Unicode 字符</p>
<p><strong>因此，在学习 java 的输入输出上，我们希望你以字节流和字符流作为区分来学习</strong><br>
如果需要概括一下，则可以得到下面的定义</p>
<ul>
<li>字节流：表示以字节为单位从 stream 中读取或往 stream 中写入信息。通常用来读取二进制数据</li>
<li>字符流：以 Unicode 字符为单位从 stream 中读取或往 stream 中写入信息</li>
</ul>
<p>按照这样的定义，Java 中流的层级结构可以通过下图来表示<br>
<img src="https://y-rui.github.io/post-images/1608705833163.png" alt="" loading="lazy"><br>
图中蓝色的部分均为抽象类，而绿色的部分则为派生类，是可以直接使用的</p>
<p>而下图简要说明了字节流和字符流的区别<br>
<img src="https://y-rui.github.io/post-images/1608705916740.png" alt="" loading="lazy"><br>
我们知道 Java 是一门面向对象的语言，所以为了能够永久地保存对象的状态，java.io包还以字节流为基础，通过实现 ObjectInput 和 ObjectOutput 接口提供了 <code>_对象流_</code></p>
<p><strong>字节流</strong><br>
字节流主要操作 byte 类型数据，以 byte 数组为准，java 中每一种字节流的基本功能依赖于基本类 InputStream 和 Outputstream，他们是抽象类，不能直接使用。字节流能处理所有类型的数据（如图片、avi 等）</p>
<p><strong>InputStream</strong><br>
InputStream 是所有表示字节输入流的父类，继承它的子类要重新定义其中所定义的抽象方法。InputStream 是从装置来源地读取数据的抽象表示，例如 System 中的标准输入流 in 对象就是一个 InputStream 类型的实例</p>
<p><strong>InputStream 类方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>read()throws IOException</code></td>
<td>从输入流中读取数据的下一个字节（抽象方法）</td>
</tr>
<tr>
<td><code>skip(long n) throws IOException</code></td>
<td>跳过和丢弃此输入流中数据的 n 个字节</td>
</tr>
<tr>
<td><code>available()throws IOException</code></td>
<td>返回流中可用字节数</td>
</tr>
<tr>
<td><code>mark(int readlimit)throws IOException</code></td>
<td>在此输入流中标记当前的位置</td>
</tr>
<tr>
<td><code>reset()throws IOException</code></td>
<td>将此流重新定位到最后一次对此输入流调用 mark 方法时的位置</td>
</tr>
<tr>
<td><code>markSupport()throws IOException</code></td>
<td>测试此输入流是否支持 mark 和 reset 方法</td>
</tr>
<tr>
<td><code>close()throws IOException</code></td>
<td>关闭流</td>
</tr>
</tbody>
</table>
<p>在 InputStream 类中，方法 read() 提供了三种从流中读数据的方法</p>
<ol>
<li>int read()：从输入流中读一个字节，形成一个 0~255 之间的整数返回（是一个抽象方法）</li>
<li>int read(byte b[])：从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中</li>
<li>int read(byte b[],int off,int len)：从输入流中读取长度为 len 的数据，写入数组 b 中从索引 off 开始的位置，并返回读取得字节数</li>
</ol>
<p>对于这三个方法，若返回 -1，表明流结束，否则，返回实际读取的字符数</p>
<p><strong>OutputStream</strong><br>
OutputStream 是所有表示位输出流的类之父类。子类要重新定义其中所定义的抽象方法，OutputStream 是用于将数据写入目的地的抽象表示。例如 System 中的标准输出流对象 out 其类型是 java.io.PrintStream，这个类是 OutputStream 的子类</p>
<p><strong>OutputStream 类方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>write(int b)throws IOException</code></td>
<td>将指定的字节写入此输出流（抽象方法）</td>
</tr>
<tr>
<td><code>write(byte b[])throws IOException</code></td>
<td>将字节数组中的数据输出到流中</td>
</tr>
<tr>
<td><code>write(byte b[], int off, int len)throws IOException</code></td>
<td>将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流</td>
</tr>
<tr>
<td><code>flush()throws IOException</code></td>
<td>刷新此输出流并强制写出所有缓冲的输出字节</td>
</tr>
<tr>
<td><code>close()throws IOException</code></td>
<td>关闭流</td>
</tr>
</tbody>
</table>
<p><strong>编程实例</strong><br>
在 /home/project/ 目录下新建源代码文件 Test.java</p>
<pre><code>import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

public class Test {

    /**
     * 把输入流中的所有内容赋值到输出流中
     * @param in
     * @param out
     * @throws IOException
     */
    public void copy(InputStream in, OutputStream out) throws IOException {
        byte[] buf = new  byte[4096];
        int len = in.read(buf);
        //read 是一个字节一个字节地读，字节流的结尾标志是-1
        while (len != -1){
            out.write(buf, 0, len);
            len = in.read(buf);
        }
    }
    public static void main(String[] args) throws IOException {
        // TODO Auto-generated method stub
        Test t = new Test();
        System.out.println(&quot;输入字符：&quot;);
        t.copy(System.in, System.out);
    }

}
</code></pre>
<pre><code>$ javac Test.java
$ java Test
输入字符：
abc
abc
</code></pre>
<p>一般来说，很少直接实现 InputStream 或 OutputStream 上的方法，因为这些方法比较低级，通常会实现它们的子类</p>
<p><strong>练习题：文件分割</strong><br>
在 /home/project/ 目录下新建FileCut.java，你需要实现以下需求</p>
<ul>
<li>从控制台读取一个数值 n</li>
<li>在 /home/project 目录下新建一个文本文件 cut.txt，填入任意内容，尽量多输入一些字符</li>
<li>将 cut.txt 文件平均分割，每份文件大小为 n 字节</li>
<li>分割后的文件分别命名为 cut1.txt、cut2.txt ... cutn.txt 保存在 /home/project 目录下</li>
</ul>
<p>提示</p>
<ul>
<li>获取文件所占字节大小，根据字节平均分割文件</li>
</ul>
<p>参考答案</p>
<pre><code>import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Scanner;

public class FileCut {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        File file = new File(&quot;/home/project/file.txt&quot;);
        //需要分隔的文件份数
        int num;
        //如果不能整除，那么需要多加一个文件 用于保存剩余的数据
        if (file.length() % n == 0) {
            num = (int) (file.length() / n);
        } else {
            num = (int) (file.length() / n) + 1;
        }
        try {
            FileInputStream fileInputStream = new FileInputStream(file);
            byte[] bytes = new byte[(int) file.length()];
            //读取文件到bytes
            fileInputStream.read(bytes);
            fileInputStream.close();
            for (int i = 1; i &lt;= num; i++) {
                //文件名
                String fileName = &quot;/home/project/cut&quot; + i + &quot;.txt&quot;;
                FileOutputStream fileOutputStream = new FileOutputStream(fileName);
                //最后一份文件需要特殊处理 因为他的大小不是n
                if (i == num) {
//                    (file.length()-n*(i-1)) 文件的总字节数 再减去前面已经读取的字节数 就是剩余的字节数
                    fileOutputStream.write(bytes, n * (i - 1), (int) (file.length() - n * (i - 1)));
                } else {

                    fileOutputStream.write(bytes, n * (i - 1), n);
                }
                fileOutputStream.flush();
                fileOutputStream.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h2 id="字符流">字符流</h2>
<p>字符流以字符为单位，根据码表映射字符，一次可能读多个字节，只能处理字符类型的数据</p>
<p>java.io 包中专门用于字符流处理的类，是以 Reader 和 Writer 为基础派生的一系列类</p>
<p>同类 InputStream 和 OutputStream 一样，Reader 和 Writer 也是抽象类，只提供了一系列用于字符流处理的接口。它们的方法与类 InputStream 和 OutputStream 类似，只不过其中的参数换成字符或字符数组</p>
<p>Reader 是所有的输入字符流的父类，它是一个抽象类</p>
<p>我们先来看一看基类 Reader 的方法，其用法与作用都与 InputStream 和 OutputStream 类似，就不做过多的说明了</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>close()</code></td>
<td>close()</td>
</tr>
<tr>
<td><code>mark (int readAheadLimit)</code></td>
<td>close()</td>
</tr>
<tr>
<td><code>markSupported()</code></td>
<td>boolean</td>
</tr>
<tr>
<td><code>read()</code></td>
<td>int</td>
</tr>
<tr>
<td><code>read(char[] cbuf, int off,int len)</code></td>
<td>int</td>
</tr>
<tr>
<td><code>ready()</code></td>
<td>boolean</td>
</tr>
<tr>
<td><code>reset()</code></td>
<td>close()</td>
</tr>
<tr>
<td><code>skip(long n)</code></td>
<td>long</td>
</tr>
</tbody>
</table>
<p>Writer 是所有的输出字符流的父类，它是一个抽象类。Writer 的方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>close()</code></td>
<td>void</td>
</tr>
<tr>
<td><code>flush()</code></td>
<td>void</td>
</tr>
<tr>
<td><code>write(char[] cbuf)</code></td>
<td>void</td>
</tr>
<tr>
<td><code>write(char[] cbuf, int off,int len)</code></td>
<td>void</td>
</tr>
<tr>
<td><code>write(int c)</code></td>
<td>void</td>
</tr>
<tr>
<td><code>write(String str)</code></td>
<td>void</td>
</tr>
<tr>
<td><code>write(String str, int off, int len)</code></td>
<td>void</td>
</tr>
</tbody>
</table>
<p>在这里我们就列举一下有哪些类</p>
<ol>
<li>对字符数组进行处理： CharArrayReader、CharArrayWrite</li>
<li>对文本文件进行处理：FileReader、FileWriter</li>
<li>对字符串进行处理：StringReader、StringWriter</li>
<li>过滤字符流：FilterReader、FileterWriter</li>
<li>管道字符流：PipedReader、PipedWriter</li>
<li>行处理字符流：LineNumberReader</li>
<li>打印字符流：PrintWriter</li>
</ol>
<p>类有千万，方法更是不计其数，所以没有必要去掌握所有的方法和类，只需要知道常见常用的就行了，而大多数的类和方法，希望大家有一个印象，当我们在实际开发的时间，能够想到，并且借助其他工具去查询我们需要的方法的应用方式就可以了</p>
<h2 id="转换流">转换流</h2>
<p>InputStreamReader 和 OutputStreamWriter 是 java.io 包中用于处理字符流的最基本的类，用来在字节流和字符流之间作为中介：从字节输入流读入字节，并按编码规范转换为字符；往字节输出流写字符时先将字符按编码规范转换为字节。使用这两者进行字符处理时，在构造方法中应指定一定的平台规范，以便把以字节方式表示的流转换为特定平台上的字符表示</p>
<pre><code>InputStreamReader(InputStream in); //缺省规范说明

//指定规范 enc
InputStreamReader(InputStream in, String enc);

OutputStreamWriter(OutputStream out); //缺省规范说明

//指定规范 enc
OutputStreamWriter(OutputStream out, String enc);
</code></pre>
<p>如果读取的字符流不是来自本地时（比如网上某处与本地编码方式不同的机器），那么在构造字符输入流时就不能简单地使用缺省编码规范，而应该指定一种统一的编码规范“ISO 8859_1”，这是一种映射到 ASCCII 码的编码方式，能够在不同平台之间正确转换字符</p>
<pre><code>InputStreamReader ir = new InputStreamReader(is,&quot;8859_1&quot;);
</code></pre>
<h2 id="缓冲流">缓冲流</h2>
<p>类 BufferedInputStream 和 BufferedOutputStream 实现了带缓冲的过滤流，它提供了缓冲机制，把任意的 I/O 流“捆绑”到缓冲流上，可以提高 I/O 流的读取效率</p>
<p>在初始化时，除了要指定所连接的 I/O 流之外，还可以指定缓冲区的大小。缺省时是用 32 字节大小的缓冲区；最优的缓冲区大小常依赖于主机操作系统、可使用的内存空间以及机器的配置等；一般缓冲区的大小为内存页或磁盘块等的整数倍</p>
<p>BufferedInputStream 的数据成员 buf 是一个位数组，默认为 2048 字节。当读取数据来源时例如文件，BufferedInputStream 会尽量将 buf 填满。当使用 read() 方法时，实际上是先读取 buf 中的数据，而不是直接对数据来源作读取。当 buf 中的数据不足时，BufferedInputStream 才会再实现给定的 InputStream 对象的 read() 方法，从指定的装置中提取数据</p>
<p>BufferedOutputStream 的数据成员 buf 是一个位数组，默认为 512 字节。当使用 write() 方法写入数据时，实际上会先将数据写至 buf 中，当 buf 已满时才会实现给定的 OutputStream 对象的 write() 方法，将 buf 数据写至目的地，而不是每次都对目的地作写入的动作<br>
<img src="https://y-rui.github.io/post-images/1608706833085.png" alt="" loading="lazy"></p>
<p>构造方法</p>
<pre><code>//[ ]里的内容代表可选参数
BufferedInputStream(InputStream in [, int size])
BufferedOutputStream(OutputStream out [, int size])
</code></pre>
<p>举个例子，将缓冲流与文件流相接</p>
<pre><code>FileInputStream in = new FileInputStream(&quot;file.txt&quot;);
FileOutputStream out = new FileOutputStream(&quot;file2.txt&quot;);

//设置输入缓冲区大小为256字节
BufferedInputStream bin = new BufferedInputStream(in,256)
BufferedOutputStream bout = new BufferedOutputStream(out,256)

int len;
byte bArray[] = new byte[256];
len = bin.read(bArray); //len 中得到的是实际读取的长度，bArray 中得到的是数据
</code></pre>
<p><img src="https://y-rui.github.io/post-images/1608706876662.png" alt="" loading="lazy"><br>
对于 BufferedOutputStream，只有缓冲区满时，才会将数据真正送到输出流，但可以使用 flush() 方法人为地将尚未填满的缓冲区中的数据送出</p>
<p>例如方法 copy()</p>
<pre><code>public void copy(InputStream in, OutputStream out) throws IOException {
    out = new BufferedOutputStream(out, 4096);
    byte[] buf = new byte[4096];
    int len = in.read(buf);
    while (len != -1) {
    out.write(buf, 0, len);
    len = in.read(buf);
    }
    //最后一次读取得数据可能不到4096字节
    out.flush();
}
</code></pre>
<p><strong>BufferedReader 和 BufferedWrite</strong><br>
同样的，为了提高字符流处理的效率，java.io 中也提供了缓冲流 BufferedReader 和 BufferedWrite。其构造方法与 BufferedInputStream 和 BufferedOutPutStream 相类似。另外，除了 read() 和 write() 方法外，它还提供了整行字符处理方法</p>
<ul>
<li>public String readLine()：BufferedReader 的方法，从输入流中读取一行字符，行结束标志 \n、\r 或者两者一起（这是根据系统而定的）</li>
<li>public void newLine()：BufferedWriter 的方法，向输出流中写入一个行结束标志，它不是简单地换行符 \n 或\r，而是系统定义的行隔离标志（line separator）</li>
</ul>
<p>看一看例子吧</p>
<pre><code>// FileToUnicode.java
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;

public class FileToUnicode {
    public static void main(String args[]) {
        try {
            FileInputStream fis = new FileInputStream(&quot;file1.txt&quot;);
            InputStreamReader dis = new InputStreamReader(fis);
            BufferedReader reader = new BufferedReader(dis);
            String s;
            //每次读取一行，当改行为空时结束
            while((s = reader.readLine()) != null){
                System.out.println(&quot;read:&quot; + s);
            }
            dis.close();
        }
        catch(IOException e) {
            System.out.println(e);
        }
    }
}
</code></pre>
<p>如 file1.txt 的内容如下</p>
<pre><code>abc
efg
hij
</code></pre>
<p>编译运行</p>
<pre><code>$ javac FileToUnicode.java
$ java FileToUnicode
read:abc
read:efg
read:hij
</code></pre>
<p><strong>数据流</strong><br>
接口 DataInput 和 DataOutput，设计了一种较为高级的数据输入输出方式：除了可处理字节和字节数组外，还可以处理 int、float、boolean 等基本数据类型，这些数据在文件中的表示方式和它们在内存中的一样，无须转换，如 read(), readInt(), readByte()...; write(), writeChar(), writeBoolean()... 此外，还可以用 readLine() 方法读取一行信息</p>
<p><strong>常用方法</strong></p>
<p>数据流类 DataInputStream 和 DataOutputStream 的处理对象除了是字节或字节数组外，还可以实现对文件的不同数据类型的读写</p>
<ol>
<li>分别实现了 DataInput 和 DataOutput 接口</li>
<li>在提供字节流的读写手段同时，以统一的形式向输入流中写入 boolean，int，long，double 等基本数据类型，并可以再次把基本数据类型的值读取回来</li>
<li>提供了字符串读写的手段</li>
</ol>
<p>数据流可以连接一个已经建立好的数据对象，例如网络连接、文件等。数据流可以通过如下方式建立</p>
<pre><code>FileInputStream fis = new FileInputStream(&quot;file1.txt&quot;);
FileOutputStream fos = new FileOutputStream(&quot;file2.txt&quot;);
DataInputStream dis = new DataInputStream(fis);
DataOutputStream dos = new DataOutputStream(fos);
</code></pre>
<p><strong>编程实战</strong><br>
在 /home/project/ 目录下新建源代码文件 DataStream.java</p>
<pre><code>import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class DataStream {

    public static void main(String[] args) throws IOException{
        //向文件 a.txt 写入
        FileOutputStream fos = new FileOutputStream(&quot;a.txt&quot;);
        DataOutputStream dos = new DataOutputStream(fos);
        try {
            dos.writeBoolean(true);
            dos.writeByte((byte)123);
            dos.writeChar('J');
            dos.writeDouble(3.1415926);
            dos.writeFloat(2.122f);
            dos.writeInt(123);
        }
        finally {
            dos.close();
        }
        //从文件 a.txt 读出
        FileInputStream fis = new FileInputStream(&quot;a.txt&quot;);
        DataInputStream dis = new DataInputStream(fis);
        try {
            System.out.println(&quot;\t&quot; + dis.readBoolean());
            System.out.println(&quot;\t&quot; + dis.readByte());
            System.out.println(&quot;\t&quot; + dis.readChar());
            System.out.println(&quot;\t&quot; + dis.readDouble());
            System.out.println(&quot;\t&quot; + dis.readFloat());
            System.out.println(&quot;\t&quot; + dis.readInt());
        }
        finally {
            dis.close();
        }
    }

}
</code></pre>
<pre><code>$ javac DataStream.java
$ java DataStream
        true
        123
        J
        3.1415926
        2.122
        123
</code></pre>
<h2 id="读写对象">读写对象</h2>
<p>我们知道实例化的对象存在于内存中，如果我们想传输实例化的对象怎么办呢？可以通过 ObjectOutputStream 和 ObjectInputStream 将对象输入输出。 将对象的状态信息转换为可以存储或者传输的形式的过程又叫序列化</p>
<p><strong>编程实例</strong><br>
在 /home/project 目录下新建一个源代码文件 ReadWriteObject.java</p>
<pre><code>import java.io.*;

public class ReadWriteObject {
    public static void main(String[] args) {
        File file = new File(&quot;/home/project/user.file&quot;);
        try (ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(file))) {
            //将匿名对象 写入到file中，注意：被写入的对象必须实现了Serializable接口
            objectOutputStream.writeObject(new User(&quot;shiyanlou&quot;, &quot;password&quot;));
            objectOutputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
        //读取文件 打开输入流
        try (ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(file))) {
//            将信息还原为user实例
            User user = (User) objectInputStream.readObject();
            //打印user信息  和上面创建的匿名对象的信息一致
            System.out.println(user.toString());
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }

    }

//静态内部类 必须实现Serializable
    static class User implements Serializable {
        private String username;
        private String password;

        public User(String username, String password) {
            this.username = username;
            this.password = password;
        }

        @Override
        public String toString() {
            return &quot;User{&quot; +
                    &quot;username='&quot; + username + '\'' +
                    &quot;, password='&quot; + password + '\'' +
                    '}';
        }
    }
}
</code></pre>
<pre><code>$ javac ReadWriteObject.java
$ java ReadWriteObject
User{username='shiyanlou', password='password'}
</code></pre>
<h2 id="nio">NIO</h2>
<p>Java NIO(New IO) 发布于 JDK1.4，用于代替 Java 标准 IO 。Java NIO 是面向缓存的、非阻塞的 IO，而标准 IO 是面向流的，阻塞的 IO</p>
<p>首先理解 NIO 的重要概念：Buffer（缓冲区）</p>
<ul>
<li>NIO 读取或者写入数据都要通过 Buffer</li>
<li>通过 allocate() 方法分配 Buffer，Buffer 不可实例化，Buffer 是抽象类，需要使用具体的子类，比如 ByteBuffer</li>
<li>Buffer 的参数
<ul>
<li>capacity ：缓冲区的容量</li>
<li>position ：当前指针位置，每读取一次缓冲区数据或者写入缓冲区一个数据那么指针将会后移一位</li>
<li>limit ：限制指针的移动，指针不能读取 limit 之后的位置</li>
<li>mark ：如果设置该值，那么指针将移动到 0 - position 的位置</li>
<li>最后可以这几个参数的关系如下：mark &lt;= position &lt;= limit &lt;= capacity</li>
</ul>
</li>
</ul>
<p><strong>编程实例</strong><br>
学习编程的最好方式当然是通过代码来学习，接下来将使用 NIO 来完成的文件的读取和写入操作，同学们可以对比标准 IO 的基本操作理解其不同</p>
<p>在 /home/project/ 目录下新建源代码文件 NioDemo.java</p>
<pre><code>import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.util.Scanner;

public class NioDemo {
    public static void main(String[] args) {
        try {
            File file = new File(&quot;/home/project/nio.txt&quot;);
            if (!file.exists()) {
                file.createNewFile();
            }
            //创建channel  nio通过channel来连接文件 相当于桥梁
            FileChannel writeChannel = new RandomAccessFile(file, &quot;rw&quot;).getChannel();
            //创建一个ByteBuffer 容量为100
            ByteBuffer byteBuffer = ByteBuffer.allocate(100);
            System.out.println(&quot;请输入字符串&quot;);
            Scanner in = new Scanner(System.in);
            String s = in.nextLine();
            //将字符串写入到缓冲区
            byteBuffer.put(s.getBytes());
            System.out.println(&quot;写入数据后指针变化-position:&quot; + byteBuffer.position() + &quot; limit：&quot; + byteBuffer.limit() + &quot; capacity :&quot; + byteBuffer.capacity());
            //为输出数据做准备 将limit移动到position位置，position置0
            byteBuffer.flip();
            System.out.println(&quot;flip后指针变化-position:&quot; + byteBuffer.position() + &quot; limit：&quot; + byteBuffer.limit() + &quot; capacity :&quot; + byteBuffer.capacity());
            //将缓冲区写入channel
            writeChannel.write(byteBuffer);
            //清除缓冲区 为下次写入或者读取数据做准备 恢复到初始状态 position=0 limit=capacity=100  因为我们这里分配的容量大小为100
            byteBuffer.clear();
            System.out.println(&quot;clear后指针变化-position:&quot; + byteBuffer.position() + &quot; limit：&quot; + byteBuffer.limit() + &quot; capacity :&quot; + byteBuffer.capacity());
            //关闭channel
            writeChannel.close();
            FileChannel readChannel = new RandomAccessFile(file, &quot;r&quot;).getChannel();
            //从channel中将数据读取到缓冲区
            while (readChannel.read(byteBuffer) != -1) {
                //为读取数据做准备
                byteBuffer.flip();
                //输出数据 设置解码器
                Charset charset = Charset.forName(&quot;UTF-8&quot;);
                CharsetDecoder decoder = charset.newDecoder();
                System.out.println(&quot;读取结果：&quot; + decoder.decode(byteBuffer));
                //清除缓冲区
                byteBuffer.clear();
            }
            readChannel.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<pre><code>$ javac NioDemo.java
$ java NioDemo
请输入字符串
shiyanlou
写入数据后指针变化-position:9 limit：100 capacity :100
flip后指针变化-position:0 limit：9 capacity :100
clear后指针变化-position:0 limit：100 capacity :100
shiyanlou
</code></pre>
]]></content>
    </entry>
</feed>