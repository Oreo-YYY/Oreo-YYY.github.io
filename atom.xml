<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://y-rui.github.io</id>
    <title>Gridea</title>
    <updated>2020-12-12T01:30:58.709Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://y-rui.github.io"/>
    <link rel="self" href="https://y-rui.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://y-rui.github.io/images/avatar.png</logo>
    <icon>https://y-rui.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[Java-2-面对对象]]></title>
        <id>https://y-rui.github.io/post/java-2-mian-dui-dui-xiang/</id>
        <link href="https://y-rui.github.io/post/java-2-mian-dui-dui-xiang/">
        </link>
        <updated>2020-07-18T03:13:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="类">类</h2>
<p>定义类</p>
<ul>
<li>定义类名，用于区分不同的类。如下代码中 public class 后面跟的就是类名。class是声明类的关键字，类名后面跟上大括号，大括号里面就是类的一些信息。public 为权限修饰符</li>
<li>编写类的属性。对象有什么，需要通过属性来表示。属性的定义是写在类名后面的大括号里，在定义属性时，要明确属性的类型。在一个类当中可以写一个或多个属性。当然也可以不定义属性</li>
<li>编写类的方法。方法也是写在大括号里面。可以定义一个方法或多个方法，当然也可以不定义方法</li>
</ul>
<pre><code>public class People {
//属性（成员变量） 有什么
    double height;  //身高
    int age;     //年龄
    int sex;    //性别，0为男性，非0为女性

//方法 干什么
    void cry(){
        System.out.println(&quot;我在哭！&quot;);
    }
    void laugh(){
        System.out.println(&quot;我在笑！&quot;);
    }
    void printBaseMes(){
        System.out.println(&quot;我的身高是&quot;+height+&quot;cm&quot;);
        System.out.println(&quot;我的年龄是&quot;+age+&quot;岁&quot;);
        if(this.sex==0)
            System.out.println(&quot;我是男性！&quot;);
        else
            System.out.println(&quot;我是女性！&quot;);

    }
}
</code></pre>
<p>一个类可以包含以下<strong>类型变量</strong></p>
<ul>
<li>局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁</li>
<li>成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问</li>
<li>类变量：也叫静态变量，类变量也声明在类中，方法体之外，但必须声明为 static 类型</li>
</ul>
<h2 id="对象">对象</h2>
<pre><code>People LiLei = new People();
</code></pre>
<pre><code>public class NewObject {
    public static void main(String[] args) {
        People LiLei = new People(); //创建一个People对象LiLei

        LiLei.height =170;
        LiLei.age = 20;
        LiLei.sex = 1;

        LiLei.printBaseMes();
    }
}
</code></pre>
<pre><code>$ javac NewObject.java People.java
$ java NewObject
我的身高是170.0cm
我的年龄是20岁
我是女性！
</code></pre>
<h2 id="构造方法">构造方法</h2>
<pre><code>public class People{
    //无参构造方法
    public People(){

    }
    //有一个参数的构造方法
    public People(int age){

    }
}
</code></pre>
<pre><code>public class People {
//属性（成员变量）有什么
    double height;     //身高
    int age;           //年龄
    int sex;       //性别，0为男性，非0为女性

    //构造方法，初始化了所有属性
    public People(double h, int a, int s){
        height = h;
        age = a;
        sex = s;
    }
}
</code></pre>
<pre><code>//创建对象，调用我们自己定义的有参构造方法
People XiaoMing = new People(168, 21, 1);
</code></pre>
<ul>
<li>上面的例子中通过 new 关键字将类实例化成对象，而 new 后面跟的就是构造方法。于是可以知道 new + 构造方法 可以创建一个新的对象</li>
</ul>
<h2 id="引用与对象实例">引用与对象实例</h2>
<ul>
<li>在新建对象实例时，需要为对象实例设置一个对象名，就像这样</li>
</ul>
<pre><code>Object object=new Object();
</code></pre>
<ul>
<li>那么变量 object 就真的是 Object 对象么，这里其实只是创建了一个 object 对象的引用。如果同学们学过 C 语言，这里就和指针一样，变量 object 保存的其实 Object 对象的引用，指向了 Object 对象</li>
</ul>
<pre><code> ----------           ----------
 | object |---------&gt; | Object |
 ----------           ----------
 |        |           |        |
 ----------           ----------
 |        |           |        |
 ----------           ----------
 |        |           |        |
 ----------           ----------
 |        |           |        |
 ----------           ----------
</code></pre>
<ul>
<li>再看下面的例子</li>
</ul>
<pre><code>Object object1 = new Object();
Object object2 = object1;
System.out.println(object1 == object2);
</code></pre>
<ul>
<li>运行得到的结果为 true，说明 object1 和 object2 的内存地址相同 (== 会比较两个对象的内存地址是否相同），它们实际上是引用同一对象，如果改变 object1 对象内部的属性，那么 object2 的属性同样会改变</li>
</ul>
<h2 id="static">static</h2>
<p><strong>静态成员</strong></p>
<ul>
<li>Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问</li>
</ul>
<pre><code>public class StaticTest{
    public static String string=&quot;shiyanlou&quot;;
    public static void main(String[] args){
        //静态成员不需要实例化 直接就可以访问
        System.out.println(StaticTest.string);
        //如果不加static关键字 需要这样访问
        StaticTest staticTest=new StaticTest();
        System.out.println(staticTest.string);
        //如果加上static关键字，上面的两种方法都可以使用
    }
}
</code></pre>
<p><strong>静态方法</strong></p>
<ul>
<li>被 static 修饰的方法是静态方法，静态方法不依赖于对象，不需要将类实例化便可以调用，由于不实例化也可以调用，所以不能有 this，也不能访问非静态成员变量和非静态方法。但是非静态成员变量和非静态方法可以访问静态方法</li>
</ul>
<h2 id="final">final</h2>
<p>final 关键字可以修饰类、方法、属性和变量</p>
<ol>
<li>final 修饰类，则该类不允许被继承，为最终类</li>
<li>final 修饰方法，则该方法不允许被覆盖（重写）</li>
<li>final 修饰属性：则该类的属性不会进行隐式的初始化（类的初始化属性必须有值）或在构造方法中赋值（但只能选其一）</li>
<li>final 修饰变量，则该变量的值只能赋一次值，即常量</li>
</ol>
<pre><code>//静态常量
public final static String SHI_YAN_LOU=&quot;shiyanlou&quot;;
</code></pre>
<h2 id="权限修饰符">权限修饰符</h2>
<table>
<thead>
<tr>
<th>访问修饰符</th>
<th>本类</th>
<th>同包</th>
<th>子类</th>
<th>其他</th>
</tr>
</thead>
<tbody>
<tr>
<td>private</td>
<td>✔️</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>默认</td>
<td>✔️</td>
<td>✔️</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
</tr>
</tbody>
</table>
<ul>
<li>不同的访问修饰符的访问范围，比如 private 修饰的属性或者方法，只能在当前类中访问或者使用。默认 是什么修饰符都不加，默认在当前类中和同一包下都可以访问和使用。protected 修饰的属性或者方法，对同一包内的类和所有子类可见。public 修饰的属性或者方法，对所有类可见</li>
</ul>
<h2 id="封装">封装</h2>
<ul>
<li>封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别</li>
</ul>
<p>这样做有什么好处？</p>
<ol>
<li>只能通过规定的方法访问数据</li>
<li>隐藏类的实例细节，方便修改和实现</li>
</ol>
<p>如何去实现类的封装呢？</p>
<ol>
<li>修改属性的可见性，在属性的前面添加修饰符 (private)</li>
<li>对每个值属性提供对外的公共方法访问，如创建 getter/setter（取值和赋值）方法，用于对私有属性的访问</li>
<li>在 getter/setter 方法里加入属性的控制语句，例如我们可以加一个判断语句，对于非法输入给予否定</li>
</ol>
<pre><code>public class People {
    //属性（成员变量）有什么，前面添加了访问修饰符private
    //变成了私有属性，必须通过方法调用
    private double height;     //身高

    //属性已经封装好了，如果用户需要调用属性
    //必须用getter和setter方法进行调用
    //getter和setter方法需要程序员自己定义
    public double getHeight(){
    //getter 方法命名是get关键字加属性名（属性名首字母大写）
    //getter 方法一般是为了得到属性值
      return height;
    }

    //同理设置我们的setter方法
    //setter 方法命名是set关键字加属性名（首字母大写）
    //setter 方法一般是给属性值赋值，所以有一个参数
    public void setHeight(double newHeight){
      height = newHeight;
    }
}
</code></pre>
<pre><code>public class NewObject {

    public static void main(String[] args) {
        People LiLei = new People();    //创建了一个People对象LiLei

        //利用setter方法为属性赋值
        LiLei.setHeight(170.0);

        //利用getter方法取属性值
        System.out.println(&quot;LiLei的身高是&quot;+LiLei.getHeight());
    }
}
</code></pre>
<pre><code>$ javac NewObject.java People.java
$ java NewObject
LiLei的身高是170.0
</code></pre>
<h2 id="this">this</h2>
<ul>
<li>this 关键字代表当前对象。使用 this.属性 操作当前对象的属性，this.方法 调用当前对象的方法</li>
</ul>
<pre><code>public void setAge(int age) {
  this.age = age;
}
public int getAge() {
  return age;
}
</code></pre>
<ul>
<li>当成员变量和局部变量之间发生冲突时，在属性名前面添加了 this 关键字。 此时就代表将一个参数的值赋给当前对象的属性。同理 this 关键字可以调用当前对象的方法</li>
</ul>
<h2 id="继承">继承</h2>
<pre><code>public class Animal {
    public int legNum;     //动物四肢的数量

    //类方法
    public void bark() {
        System.out.println(&quot;动物叫！&quot;);
    }
}
</code></pre>
<pre><code>public class Dog extends Animal {
}
</code></pre>
<pre><code>public class Test{
    public static void main(String[] args) {
        Dog a = new Dog();
        a.legNum = 4;
        a.bark();
    }
}
</code></pre>
<pre><code>$ javac Test.java Animal.java Dog.java
$ java Test
动物叫！
</code></pre>
<p>继承的特点</p>
<ol>
<li>子类拥有父类除 private 以外的所有属性和方法</li>
<li>子类可以拥有自己的属性和方法</li>
<li>子类可以重写实现父类的方法</li>
<li>Java 中的继承是单继承，一个类只有一个父类</li>
</ol>
<ul>
<li>Java 实现多继承的一个办法是 implements（实现）接口，但接口不能有非静态的属性</li>
</ul>
<h2 id="super">super</h2>
<p>super 关键字在子类内部使用，代表父类对象</p>
<ol>
<li>访问父类的属性 super.属性名</li>
<li>访问父类的方法 super.bark()</li>
<li>子类构造方法需要调用父类的构造方法时，在子类的构造方法体里最前面的位置：super()</li>
</ol>
<h2 id="方法重载与重写">方法重载与重写</h2>
<p><strong>方法重载</strong></p>
<ul>
<li>方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。方法重载一般用于创建一组任务相似但是参数不同的方法</li>
</ul>
<pre><code>public class Test {
    void f(int i) {
        System.out.println(&quot;i=&quot; + i);
    }

    void f(float f) {
        System.out.println(&quot;f=&quot; + f);
    }

    void f(String s) {
        System.out.println(&quot;s=&quot; + s);
    }

    void f(String s1, String s2){
        System.out.println(&quot;s1+s2=&quot;+(s1+s2));
    }

    void f(String s, int i){
        System.out.println(&quot;s=&quot;+s+&quot;,i=&quot;+i);
    }

    public static void main(String[] args) {
        Test test = new Test();
        test.f(3456);
        test.f(34.56f);
        test.f(&quot;abc&quot;);
        test.f(&quot;abc&quot;,&quot;def&quot;);
        test.f(&quot;abc&quot;,3456);
    }
}
</code></pre>
<pre><code>$ javac Test.java
$ java Test
i=3456
f=34.56
s=abc
s1+s2=abcdef
s=abc,i=3456
</code></pre>
<p>方法重载有以下几种规则</p>
<ol>
<li>方法中的参数列表必须不同。比如：参数个数不同或者参数类型不同</li>
<li>重载的方法中允许抛出不同的异常</li>
<li>可以有不同的返回值类型，但是参数列表必须不同</li>
<li>可以有不同的访问修饰符</li>
</ol>
<p><strong>方法重写</strong></p>
<ul>
<li>子类可以继承父类的方法，但如果子类对父类的方法不满意，想在里面加入适合自己的一些操作时，就需要将方法进行重写。并且子类在调用方法中，优先调用子类的方法</li>
<li>当然在方法重写时要注意，重写的方法一定要与原父类的方法语法保持一致，比如返回值类型，参数类型及个数，和方法名都必须一致</li>
</ul>
<p>比如 Animal 类中有 bark() 这个方法代表了动物叫，但是不同的动物有不同的叫法，比如狗是汪汪汪，猫是喵喵喵</p>
<pre><code>public class Animal {
    //类方法
    public void bark() {
        System.out.println(&quot;动物叫！&quot;);
    }
}
</code></pre>
<pre><code>public class Dog extends Animal {
       //重写父类的bark方法
        public void bark() {
        System.out.println(&quot;汪！汪！汪！&quot;);
    }
}
</code></pre>
<pre><code>public class Test{
    public static void main(String args[]){
           Animal a = new Animal(); // Animal 对象
        Dog d = new Dog();   // Dog 对象

          Animal b = new Dog(); // Dog 对象,向上转型为Animal类型，具体会在后面的内容进行详解

          a.bark();// 执行 Animal 类的方法
         d.bark();//执行 Dog 类的方法
          b.bark();//执行 Dog 类的方法
       }
}
</code></pre>
<pre><code>$ javac Test.java Dog.java Animal.java
$ java Test
动物叫！
汪！汪！汪！
汪！汪！汪！
</code></pre>
<h2 id="多态">多态</h2>
<ul>
<li>多态是指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。多态也称作动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法</li>
<li>通俗地讲，只通过父类就能够引用不同的子类，这就是多态，我们只有在运行的时候才会知道引用变量所指向的具体实例对象</li>
</ul>
<p>多态的实现条件</p>
<ul>
<li>Java 实现多态有三个必要条件：继承、重写和向上转型（即父类引用指向子类对象）</li>
<li>只有满足上述三个条件，才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为</li>
</ul>
<p>多态的实现方式</p>
<ul>
<li>Java 中多态的实现方式：继承父类进行方法重写，抽象类和抽象方法，接口实现</li>
</ul>
<p><strong>向上转型</strong></p>
<pre><code>Animal a = new Animal();  //a是父类的引用指向的是本类的对象

Animal b = new Dog(); //b是父类的引用指向的是子类的对象
</code></pre>
<p>在这里，可以认为由于 Dog 继承于 Animal，所以 Dog 可以自动向上转型为 Animal，所以 b 是可以指向 Dog 实例对象的</p>
<ul>
<li>注：不能使用一个子类的引用去指向父类的对象，因为子类对象中可能会含有父类对象中所没有的属性和方法。</li>
</ul>
<p>如果定义了一个指向子类对象的父类引用类型，那么它除了能够引用父类中定义的所有属性和方法外，还可以使用子类强大的功能。但是对于只存在于子类的方法和属性就不能获取</p>
<pre><code>class Animal {
    //父类方法
    public void bark() {
        System.out.println(&quot;动物叫！&quot;);
    }
}

class Dog extends Animal {

    //子类重写父类的bark方法
    public void bark() {
        System.out.println(&quot;汪、汪、汪！&quot;);
    }
    //子类自己的方法
    public void dogType() {
        System.out.println(&quot;这是什么品种的狗？&quot;);
    }
}


public class Test {

    public static void main(String[] args) {
        Animal a = new Animal();
        Animal b = new Dog();
        Dog d = new Dog();

        a.bark();
        b.bark();
        //b.dogType();
        //b.dogType()编译不通过
        d.bark();
        d.dogType();
    }

}
</code></pre>
<pre><code>$ javac Test.java
$ java Test
动物叫！
汪、汪、汪！
汪、汪、汪！
这是什么品种的狗？
</code></pre>
<p>在这里，由于 b 是父类的引用，指向子类的对象，因此不能获取子类的方法（dogType() 方法）, 同时当调用 bark() 方法时，由于子类重写了父类的 bark() 方法，所以调用子类中的 bark() 方法</p>
<ul>
<li>因此，向上转型，在运行时，会遗忘子类对象中与父类对象中不同的方法，也会覆盖与父类中相同的方法——重写（方法名，参数都相同）</li>
</ul>
<h2 id="抽象类">抽象类</h2>
<ul>
<li>在定义类时，前面加上 abstract 关键字修饰的类叫抽象类</li>
</ul>
<p>抽象类中有抽象方法，这种方法是不完整的，仅有声明而没有方法体。抽象方法声明语法如下</p>
<pre><code>abstract void f();  //f()方法是抽象方法
</code></pre>
<p>那我们什么时候会用到抽象类呢？</p>
<ol>
<li>在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法。也就是说抽象类是约束子类必须要实现哪些方法，而并不关注方法如何去实现</li>
<li>从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性</li>
</ol>
<p>所以由上可知，抽象类是限制规定子类必须实现某些方法，但不关注实现细节<br>
那抽象类如何用代码实现呢，它的规则如下：</p>
<ol>
<li>用 abstract 修饰符定义抽象类</li>
<li>用 abstract 修饰符定义抽象方法，只用声明，不需要实现</li>
<li>包含抽象方法的类就是抽象类</li>
<li>抽象类中可以包含普通的方法，也可以没有抽象方法</li>
<li>抽象类的对象不能直接创建，通常是定义引用变量指向子类对象</li>
</ol>
<p>需要子类实现的抽象方法</p>
<pre><code>//抽象方法
public abstract class TelePhone {
    public abstract void call();  //抽象方法,打电话
    public abstract void message(); //抽象方法，发短信
}
</code></pre>
<p>构建子类，并实现抽象方法</p>
<pre><code>public class CellPhone extends TelePhone {

    @Override
    public void call() {
        System.out.println(&quot;我可以打电话！&quot;);
    }

    @Override
    public void message() {
        System.out.println(&quot;我可以发短信！&quot;);
    }

    public static void main(String[] args) {
        CellPhone cp = new CellPhone();
        cp.call();
        cp.message();
    }

}
</code></pre>
<pre><code>$ javac CellPhone.java TelePhone.java
$ java CellPhone

我可以打电话！
我可以发短信！
</code></pre>
<h2 id="接口">接口</h2>
<ul>
<li>接口用于描述类所具有的功能，而不提供功能的实现，功能的实现需要写在实现接口的类中，并且该类必须实现接口中所有的未实现方法</li>
</ul>
<pre><code>修饰符 interface 接口名称 [extends 其他的接口名] {
        // 声明变量
        // 抽象方法
}
</code></pre>
<pre><code>// Animal.java
interface Animal {
        //int x;
        //编译错误,x需要初始化，因为是 static final 类型
        int y = 5;
        public void eat();
        public void travel();
}
</code></pre>
<p><strong>注意点</strong><br>
在Java8中</p>
<ul>
<li>接口不能用于实例化对象</li>
<li>接口中方法只能是抽象方法、default 方法、静态方法</li>
<li>接口成员是 static final 类型</li>
<li>接口支持多继承</li>
</ul>
<p>在 Java9 中，接口可以拥有私有方法和私有静态方法，但是只能被该接口中的 default 方法和静态方法使用</p>
<p>多继承实现方式</p>
<pre><code>修饰符 interface A extends 接口1，接口2{

}

修饰符 class A implements 接口1，接口2{

}
</code></pre>
<p>实现上面的接口</p>
<pre><code>// Cat.java
public class Cat implements Animal{

     public void eat(){
         System.out.println(&quot;Cat eats&quot;);
     }

     public void travel(){
         System.out.println(&quot;Cat travels&quot;);
     }
     public static void main(String[] args) {
        Cat cat = new Cat();
        cat.eat();
        cat.travel();
    }
}
</code></pre>
<pre><code>$ javac Cat.java Animal.java
$ java Cat
Cat eats
Cat travels
</code></pre>
<h2 id="内部类">内部类</h2>
<ul>
<li>将一个类的定义放在另一个类的定义内部，这就是内部类。而包含内部类的类被称为外部类</li>
</ul>
<p>内部类的主要作用如下</p>
<ol>
<li>内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类</li>
<li>内部类的方法可以直接访问外部类的所有数据，包括私有的数据</li>
<li>内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便</li>
<li>内部类允许继承多个非接口类型</li>
</ol>
<ul>
<li>注：内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两类。对于一个名为 outer 的外部类和其内部定义的名为 inner 的内部类。编译完成后出现 outer.class 和 outer$inner.class 两类。所以内部类的成员变量 / 方法名可以和外部类的相同</li>
</ul>
<p><strong>成员内部类</strong></p>
<pre><code>// People.java
//外部类People
public class People {
    private String name = &quot;LiLei&quot;;         //外部类的私有属性
    //内部类Student
    public class Student {
        String ID = &quot;20151234&quot;;               //内部类的成员属性
        //内部类的方法
        public void stuInfo(){
            System.out.println(&quot;访问外部类中的name：&quot; + name);
            System.out.println(&quot;访问内部类中的ID：&quot; + ID);
        }
    }

    //测试成员内部类
    public static void main(String[] args) {
        People a = new People();     //创建外部类对象，对象名为a
        Student b = a.new Student(); //使用外部类对象创建内部类对象，对象名为b
        // 或者为 People.Student b = a.new Student();
        b.stuInfo();   //调用内部对象的suInfo方法
    }
}
</code></pre>
<pre><code>$ javac People.java
$ java People
访问外部类中的name：LiLei
访问内部类中的ID：20151234
</code></pre>
<p>成员内部类的使用方法</p>
<ol>
<li>Student 类相当于 People 类的一个成员变量，所以 Student 类可以使用任意访问修饰符</li>
<li>Student 类在 People 类里，所以访问范围在类里的所有方法均可以访问 People 的属性（即内部类里可以直接访问外部类的方法和属性，反之不行）</li>
<li>定义成员内部类后，必须使用外部类对象来创建内部类对象，即 内部类 对象名 = 外部类对象.new 内部类();</li>
<li>如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用 this 关键字。如上述代码中：a.this</li>
</ol>
<ul>
<li>注：成员内部类不能含有 static 的变量和方法，因为成员内部类需要先创建了外部类，才能创建它自己的</li>
</ul>
<p><strong>静态内部类</strong></p>
<ul>
<li>静态内部类通常被称为嵌套类</li>
</ul>
<pre><code>// People.java
//外部类People
public class People {
    private String name = &quot;LiLei&quot;;         //外部类的私有属性

/*外部类的静态变量。
Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问。
*/
    static String ID = &quot;510xxx199X0724XXXX&quot;;

    //静态内部类Student
    public static class Student {
        String ID = &quot;20151234&quot;;               //内部类的成员属性
        //内部类的方法
        public void stuInfo(){
            System.out.println(&quot;访问外部类中的name：&quot; + (new People().name));
            System.out.println(&quot;访问外部类中的ID：&quot; + People.ID);
            System.out.println(&quot;访问内部类中的ID：&quot; + ID);
        }
    }

    //测试成员内部类
    public static void main(String[] args) {
        Student b = new Student();   //直接创建内部类对象，对象名为b
        b.stuInfo();                 //调用内部对象的suInfo方法
    }
}
</code></pre>
<pre><code>$ javac People.java
$ java People
访问外部类中的name：LiLei
访问外部类中的ID：510xxx199X0724XXXX
访问内部类中的ID：20151234
</code></pre>
<p>静态内部类是 static 修饰的内部类，这种内部类的特点是</p>
<ol>
<li>静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问</li>
<li>如果外部类的静态成员与内部类的成员名称相同，可通过 类名.静态成员 访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过 成员名 直接调用外部类的静态成员</li>
<li>创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名 = new 内部类();</li>
</ol>
<p><strong>局部内部类</strong></p>
<ul>
<li>局部内部类，是指内部类定义在方法和作用域内</li>
</ul>
<pre><code>// People.java
//外部类People
public class People {
    //定义在外部类中的方法内：
    public void peopleInfo() {
        final String sex = &quot;man&quot;;  //外部类方法中的常量
        class Student {
            String ID = &quot;20151234&quot;; //内部类中的常量
            public void print() {
                System.out.println(&quot;访问外部类的方法中的常量sex：&quot; + sex);
                System.out.println(&quot;访问内部类中的变量ID:&quot; + ID);
            }
        }
        Student a = new Student();  //创建方法内部类的对象
        a.print();//调用内部类的方法
    }
    //定义在外部类中的作用域内
    public void peopleInfo2(boolean b) {
        if(b){
            final String sex = &quot;man&quot;;  //外部类方法中的常量
            class Student {
                String ID = &quot;20151234&quot;; //内部类中的常量
                public void print() {
                    System.out.println(&quot;访问外部类的方法中的常量sex：&quot; + sex);
                    System.out.println(&quot;访问内部类中的变量ID:&quot; + ID);
                }
            }
            Student a = new Student();  //创建方法内部类的对象
            a.print();//调用内部类的方法
        }
    }
    //测试方法内部类
    public static void main(String[] args) {
        People b = new People(); //创建外部类的对象
        System.out.println(&quot;定义在方法内：===========&quot;);
        b.peopleInfo();  //调用外部类的方法
        System.out.println(&quot;定义在作用域内：===========&quot;);
        b.peopleInfo2(true);
    }
}
</code></pre>
<pre><code>$ javac People.java
$ java People
定义在方法内：===========
访问外部类的方法中的常量sex：man
访问内部类中的变量ID:20151234
定义在作用域内：===========
访问外部类的方法中的常量sex：man
访问内部类中的变量ID:20151234
</code></pre>
<ul>
<li>局部内部类也像别的类一样进行编译，但只是作用域不同而已，只在该方法或条件的作用域内才能使用，退出这些作用域后无法引用的</li>
</ul>
<p><strong>匿名内部类</strong></p>
<ul>
<li>匿名内部类，顾名思义，就是没有名字的内部类。正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写。但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口</li>
</ul>
<pre><code>// Outer.java
public class Outer {

    public Inner getInner(final String name, String city) {
        return new Inner() {
            private String nameStr = name;
            public String getName() {
                return nameStr;
            }
        };
    }

    public static void main(String[] args) {
        Outer outer = new Outer();
        Inner inner = outer.getInner(&quot;Inner&quot;, &quot;NewYork&quot;);
        System.out.println(inner.getName());
    }
}
interface Inner {
    String getName();
}
</code></pre>
<p>运行结果：Inner</p>
<ul>
<li>匿名内部类是不能加访问修饰符的。要注意的是，new 匿名类，这个类是要先定义的, 如果不先定义，编译时会报错该类找不到</li>
<li>同时，在上面的例子中，当所在的方法的形参需要在内部类里面使用时，该形参必须为 final。这里可以看到形参 name 已经定义为 final 了，而形参 city 没有被使用则不用定义为 final</li>
</ul>
<p>然而，因为匿名内部类没名字，是用默认的构造方法的，无参数的，如果需要该类有带参数的构造方法，示例如下</p>
<pre><code>public Inner getInner(final String name, String city) {
  return new Inner(name, city) {
    private String nameStr = name;

    public String getName() {
      return nameStr;
    }
  };
}
</code></pre>
<ul>
<li>注意这里的形参 city，由于它没有被匿名内部类直接使用，而是被抽象类 Inner 的构造方法所使用，所以不必定义为 final</li>
</ul>
<h2 id="package">package</h2>
<ul>
<li>为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间</li>
</ul>
<p><strong>包的作用</strong></p>
<ul>
<li>把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用</li>
<li>包采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别</li>
<li>包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类</li>
</ul>
<pre><code>//在定义文件夹的时候利用&quot;/&quot;来区分层次
//包中用&quot;.&quot;来分层
package com.shiyanlou.java
</code></pre>
<p>如何在不同包中使用另一个包中的类？</p>
<ul>
<li>使用 import 关键字。比如要导入包 com.shiyanlou 下 People 这个类，import com.shiyanlou.People;。同时如果 import com.shiyanlou.<em>; 这是将包下的所有文件都导入进来，</em> 是通配符</li>
</ul>
<p><strong>包的命名规范是全小写字母拼写</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java - StringBuilder]]></title>
        <id>https://y-rui.github.io/post/java-stringbuilder/</id>
        <link href="https://y-rui.github.io/post/java-stringbuilder/">
        </link>
        <updated>2020-07-16T01:57:40.000Z</updated>
        <summary type="html"><![CDATA[<ul>
<li>StringBuilder是可变对象，用来高效拼接字符串</li>
<li>StringBuilder可以支持链式操作，实现链式操作的关键是返回实例本身</li>
<li>StringBuffer是StringBuilder的线程安全版本，现在很少使用</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<ul>
<li>StringBuilder是可变对象，用来高效拼接字符串</li>
<li>StringBuilder可以支持链式操作，实现链式操作的关键是返回实例本身</li>
<li>StringBuffer是StringBuilder的线程安全版本，现在很少使用</li>
</ul>
<!-- more -->
<pre><code>String s = &quot;&quot;;
for (int i = 0; i &lt; 1000; i++) {
    s = s + &quot;,&quot; + i;
}
</code></pre>
<p>虽然可以直接拼接字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率</p>
<p>为了能高效拼接字符串，Java标准库提供了StringBuilder，它是一个可变对象，可以预分配缓冲区，这样，往StringBuilder中新增字符时，不会创建新的临时对象</p>
<pre><code>StringBuilder sb = new StringBuilder(1024);
for (int i = 0; i &lt; 1000; i++) {
    sb.append(',');
    sb.append(i);
}
String s = sb.toString();
</code></pre>
<pre><code>// StringBuilder链式操作
public class Main {
    public static void main(String[] args) {
        var sb = new StringBuilder(1024);
        sb.append(&quot;Mr &quot;)
          .append(&quot;Bob&quot;)
          .append(&quot;!&quot;)
          .insert(0, &quot;Hello, &quot;);
        System.out.println(sb.toString());
    }
}
// Hello, Mr Bob!
</code></pre>
<p>如果我们查看StringBuilder的源码，可以发现，进行链式操作的关键是，定义的append()方法会返回this，这样，就可以不断调用自身的其他方法。</p>
<pre><code>// 仿照StringBuilder，我们也可以设计支持链式操作的类。例如，一个可以不断增加的计数器
public class Main {
    public static void main(String[] args) {
        Adder adder = new Adder();
        adder.add(3)
             .add(5)
             .inc()
             .add(10);
        System.out.println(adder.value());
    }
}

class Adder {
    private int sum = 0;

    public Adder add(int n) {
        sum += n;
        return this;
    }

    public Adder inc() {
        sum ++;
        return this;
    }

    public int value() {
        return sum;
    }
}
</code></pre>
<p>对于普通的字符串+操作，并不需要我们将其改写为StringBuilder，因为Java编译器在编译时就自动把多个连续的+操作编码为StringConcatFactory的操作。在运行期，StringConcatFactory会自动把字符串连接操作优化为数组复制或者StringBuilder操作</p>
<p>StringBuffer，这是Java早期的一个StringBuilder的线程安全版本，它通过同步来保证多个线程操作StringBuffer也是安全的，但是同步会带来执行速度的下降<br>
StringBuilder和StringBuffer接口完全相同，现在完全没有必要使用StringBuffer</p>
<h2 id="练习题">练习题</h2>
<pre><code>// 请使用StringBuilder构造一个INSERT语句
public class Main {
    public static void main(String[] args) {
        String[] fields = { &quot;name&quot;, &quot;position&quot;, &quot;salary&quot; };
        String table = &quot;employee&quot;;
        String insert = buildInsertSql(table, fields);
        System.out.println(insert);
        String s = &quot;INSERT INTO employee (name, position, salary) VALUES (?, ?, ?)&quot;;
        System.out.println(s.equals(insert) ? &quot;测试成功&quot; : &quot;测试失败&quot;);
    }
        static String buildInsertSql(String table, String[] fields) {
        // TODO:
        return &quot;&quot;;
    }
}
</code></pre>
<pre><code>// 答案
        StringBuilder sb = new StringBuilder(1024);
        sb.append(&quot;INSERT INTO &quot;)
         .append(table)
         .append(&quot; (&quot;);
        for(int i = 0; i&lt;= fields.length - 1;i++){
          sb.append(fields[i]);
          if (i != 2){
           sb.append(&quot;, &quot;);
           }
        }
          sb.append(&quot;)&quot;)
         .append(&quot; VALUES (?, ?, ?)&quot;);
         return sb.toString();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java-1-基础语法]]></title>
        <id>https://y-rui.github.io/post/java-ji-chu-yu-fa/</id>
        <link href="https://y-rui.github.io/post/java-ji-chu-yu-fa/">
        </link>
        <updated>2020-07-13T17:05:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="helloworld">HelloWorld</h2>
<pre><code>public class HelloWorld{
    public static void  main(String[] args){
        System.out.println(&quot;HelloWorld!&quot;);
    }
}
</code></pre>
<h2 id="命令行编译java">命令行编译Java</h2>
<pre><code>javac hello.java
java hello
</code></pre>
<h2 id="定义变量">定义变量</h2>
<pre><code>int a = 1;
</code></pre>
<pre><code>public class VarTest
{
  public static void main(String[] args)
  {
    System.out.println(&quot;Define a variable a is &quot;);
    int a; //声明变量a
    a = 5;
    System.out.println(a);  // 打印一个整数a
  }
}
</code></pre>
<h2 id="定义常量">定义常量</h2>
<pre><code>final double PI = 3.14;

final int FINAL_VARIABLE;
FINAL_VARIABLE = 100;
</code></pre>
<pre><code>public class FinalVar{
    public static void main(String[] args){
        final String FINAL_STRING=&quot;shiyanlou&quot;;
        System.out.println(FINAL_STRING);
    }
}
</code></pre>
<h2 id="string">String</h2>
<p><strong>String对象初始化</strong></p>
<pre><code>String s0 = &quot;abc&quot;;

String s1 = new String(&quot;abd&quot;);
</code></pre>
<p><strong>方法</strong></p>
<pre><code>length() //长度
equals() //字符串比较
equalsIgnoreCase() //忽略大小写的比较
== //比较连个对象在内存中存储的地址是否一样
+ concat() //字符串连接
charAt() //按照索引值获得字符串中的指定字符
</code></pre>
<pre><code>public class StringTest {
    public static void main(String[] args) {
         String s = &quot;abcdefabc&quot;;
         System.out.println(&quot;字符a第一次出现的位置为&quot;+s.indexOf('a'));
         System.out.println(&quot;字符串bc第一次出现的位置为&quot;+s.indexOf(&quot;bc&quot;));
         System.out.println(&quot;字符a最后一次出现的位置为&quot;+s.lastIndexOf('a'));
         System.out.println(&quot;从位置3开始到结束的字符串&quot;+s.substring(3));
         System.out.println(&quot;从位置3开始到6之间的字符串&quot;+s.substring(3,6));
    }
}
</code></pre>
<h2 id="运算符">运算符</h2>
<p><strong>算术运算符</strong></p>
<pre><code>public class ArithmeticOperation {
    public static void main(String args[]) {
        int a = 5;
        int b = 3;
        int c = 3;
        int d = 3;
        System.out.println(&quot;a + b = &quot; + (a + b));
        System.out.println(&quot;a - b = &quot; + (a - b));
        System.out.println(&quot;a * b = &quot; + (a * b));
        System.out.println(&quot;a / b = &quot; + (a / b));
        System.out.println(&quot;a % b = &quot; + (a % b));
        System.out.println(&quot;a++ = &quot; + (a++));
        System.out.println(&quot;++a = &quot; + (++a));
        System.out.println(&quot;b-- = &quot; + (b--));
        System.out.println(&quot;--b = &quot; + (--b));
        System.out.println(&quot;c++ = &quot; + (c++));
        System.out.println(&quot;++d = &quot; + (++d));
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac ArithmeticOperation.java
$ java ArithmeticOperation
a + b = 8
a - b = 2
a * b = 15
a / b = 1
a % b = 2
a++ = 5
++a = 7
b-- = 3
--b = 1
c++ = 3
++d = 4
</code></pre>
<ul>
<li>前缀自增自减法 (++i,--i): 先进行自增或者自减运算，再进行表达式运算</li>
<li>后缀自增自减法 (i++,i--): 先进行表达式运算，再进行自增或者自减运算</li>
</ul>
<p><strong>位运算符</strong></p>
<pre><code>public class BitOperation {
    public static void main(String args[]) {
        int a = 60;
        int b = 13;
        System.out.println(&quot;a &amp; b = &quot; + (a &amp; b));
        System.out.println(&quot;a | b = &quot; + (a | b));
        System.out.println(&quot;a ^ b = &quot; + (a ^ b));
        System.out.println(&quot;~a = &quot; + (~a));
        System.out.println(&quot;a &lt;&lt; 2 = &quot; + (a &lt;&lt; 2));
        System.out.println(&quot;a &gt;&gt; 2 = &quot; + (a &gt;&gt; 2));
        System.out.println(&quot;a &gt;&gt;&gt; 2 = &quot; + (a &gt;&gt;&gt; 2));
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac BitOperation.java
$ java BitOperation
a &amp; b = 12
a | b = 61
a ^ b = 49
~a = -61
a &lt;&lt; 2 = 240
a &gt;&gt; 2 = 15
a &gt;&gt;&gt; 2 = 15
</code></pre>
<p><strong>逻辑运算符</strong></p>
<pre><code>public class LogicOperation {
    public static void main(String args[]) {
        boolean a = true;
        boolean b = false;
        System.out.println(&quot;a &amp;&amp; b = &quot; + (a &amp;&amp; b));
        System.out.println(&quot;a || b = &quot; + (a || b));
        System.out.println(&quot;!a = &quot; + (!a));
        System.out.println(&quot;a ^ b = &quot; + (a ^ b));
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac LogicOperation.java
$ java LogicOperation
a &amp;&amp; b = false
a || b = true
!a = false
a ^ b = true
</code></pre>
<p><strong>关系运算符</strong></p>
<pre><code>public class RelationalOperation {
    public static void main(String args[]) {
        int a = 3;
        int b = 5;
        System.out.println(&quot;a == b = &quot; + (a == b));
        System.out.println(&quot;a != b = &quot; + (a != b));
        System.out.println(&quot;a &gt; b = &quot; + (a &gt; b));
        System.out.println(&quot;a &lt; b = &quot; + (a &lt; b));
        System.out.println(&quot;a &gt;= b = &quot; + (a &gt;= b));
        System.out.println(&quot;a &lt;= b = &quot; + (a &lt;= b));
        System.out.println(&quot;a &gt; b ? a : b = &quot; + (a &gt; b ? a : b));
    }
}
</code></pre>
<p>编译运行</p>
<pre><code>$ javac RelationalOperation.java
$ java RelationalOperation
a == b = false
a != b = true
a &gt; b = false
a &lt; b = true
a &gt;= b = false
a &lt;= b = true
a &gt; b ? a : b = 5
</code></pre>
<h2 id="两数只和">两数只和</h2>
<pre><code>import java.util.Scanner;

public class Sum {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int a = in.nextInt();
        int b = in.nextInt();
        System.out.println(a + b);
    }
}
</code></pre>
<h2 id="调用方法">调用方法</h2>
<pre><code>public class MethodTest {
    private static void methodDemo() {
        System.out.println(&quot;Hello Shiyanlou&quot;);
    }

    public static void main(String[] args) {
        methodDemo();
    }
}
</code></pre>
<h2 id="流程控制">流程控制</h2>
<p><strong>if语句</strong></p>
<pre><code>if(条件){
    条件成立时执行的代码
}
</code></pre>
<pre><code>if(条件){
    代码块1
}
else{
    代码块2
}
</code></pre>
<pre><code>if(条件1){
    代码块1
}
else if(条件2){
    代码块2
}
...
else {
    代码块n
}
</code></pre>
<pre><code>//小明考了 78 分，60 分以上及格，80 分以上为良好，90 分以上为优秀，60 分以下要重考
public class ScoreJudge {
    public static void main(String[] args){
        int score = 78;
        if(score &gt;= 60){
            if(score &gt;= 80){
                if(score &gt;= 90){
                    System.out.println(&quot;成绩优秀&quot;);
                }
                else{
                    System.out.println(&quot;成绩良好&quot;);
                }
            }
            else{
                System.out.println(&quot;成绩及格&quot;);
            }
        }
        else{
            System.out.println(&quot;需要补考&quot;);
        }
    }
}
</code></pre>
<p><strong>switch语句</strong></p>
<pre><code>switch(表达式){
    case 值1:
        代码块1
        break;
    case 值2:
        代码块2
        break;
    ...
    default:
        默认执行的代码块
}
</code></pre>
<p><strong>while/do-while语句</strong></p>
<pre><code>while(条件){
    代码块
}
</code></pre>
<pre><code>do{
    代码块
}while(条件);
</code></pre>
<p><strong>for语句</strong></p>
<pre><code>for(循环变量初始化①; 循环条件②; 循环变量值操作③){
    循环操作④
}
</code></pre>
<pre><code>//计算 100 以内不能被 3 整除的数之和
    int sum = 0; // 保存不能被3整除的数之和
    // 循环变量 i 初始值为 1 ,每执行一次对变量加 1，只要小于等于 100 就重复执行循环
    for (int i = 1;i&lt;=100;i++) {
    // 变量 i 与 3 进行求模（取余），如果不等于 0 ，则表示不能被 3 整除
        if (i % 3 != 0) {
            sum = sum + i; // 累加求和
        }
    }
    System.out.println(&quot;1到100之间不能被3整除的数之和为：&quot; + sum);
</code></pre>
<p><strong>练习题</strong></p>
<ul>
<li>从控制台输入一行字符串<br>
去除字符串中的所有空格<br>
打印去除空格后的字符串</li>
</ul>
<pre><code>输入：
    shi ya n  lou
输出：
    shiyanlou
</code></pre>
<pre><code>import java.util.Scanner;

public class StringUtil {
    public static void main(String[] args) {
        Scanner in =new Scanner(System.in);
        //获取String值
        String a=in.nextLine();
        StringBuilder stringBuilder = new StringBuilder(a);
        for (int i = 0; i &lt; stringBuilder.length(); i++) {
            if (stringBuilder.charAt(i)==' ') {
                stringBuilder.deleteCharAt(i);
                i--;
            }
        }
        System.out.println(stringBuilder.toString());
    }
}
</code></pre>
<ul>
<li>从控制台输入字符串 a 和字符串 b<br>
比较字符串 a 和字符 b 是否完全一致，长度，内容等完全一致。<br>
如果完全一致，输出相同，如果不一致，输出不同。<br>
禁止使用equals方法</li>
</ul>
<pre><code>输入：
    abc3
    abc3
输出：
    相同
</code></pre>
<pre><code>import java.util.Scanner;

public class ContrastString {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        //获取String值
        String a = in.nextLine();
        String b = in.nextLine();
        if (a.length() != b.length()) {
            System.out.println(&quot;不同&quot;);
            return;
        }
        for (int i = 0; i &lt; a.length(); i++) {
            if (a.charAt(i) != b.charAt(i)) {
                System.out.println(&quot;不同&quot;);
                return;
            }
        }
        System.out.println(&quot;相同&quot;);
    }
}
</code></pre>
<p><strong>跳转语句</strong></p>
<ul>
<li>break 关键字经常用在条件和循环语句中，用来跳出循环语句</li>
<li>continue关键字的作用是跳过循环体中剩余的语句执行下一次循环</li>
</ul>
<pre><code>public class Jump{
    public static void main(String[] args){
        //break 练习
        for(int i = 1; i &lt;= 10; i++){
            System.out.println(&quot;循环第&quot;+i+&quot;次&quot;);
            if(0 == i % 3){
                break;
            }
            if(0 == i % 5){
                System.out.println(&quot;我进来了！&quot;);
            }
        }
        //continue练习 打印10以内的所有奇数
        for(int i = 1; i &lt;= 10; i++){
            if(0 == i % 2) //判断i是否为偶数
                continue;  //通过continue结束本次循环
            System.out.println(i);
        }
    }
}
</code></pre>
<pre><code>$ javac Jump.java
$ java Jump
循环第1次
循环第2次
循环第3次
1
3
5
7
9
</code></pre>
<p><strong>练习题</strong></p>
<ul>
<li>从控制台获取一个整型参数<br>
当输入数字 1 时输出今天是星期一<br>
当输入数字 2 时输出今天是星期二</li>
</ul>
<pre><code>输入：
    1
输出：
    今天是星期一
</code></pre>
<pre><code>import java.util.Scanner;

public class PrintWeek {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        //获取int值
        int x = in.nextInt();
        switch (x) {
            case 1:
                System.out.println(&quot;今天是星期一&quot;);
                break;
            case 2:
                System.out.println(&quot;今天是星期二&quot;);
                break;
            case 3:
                System.out.println(&quot;今天是星期三&quot;);
                break;
            case 4:
                System.out.println(&quot;今天是星期四&quot;);
                break;
            case 5:
                System.out.println(&quot;今天是星期五&quot;);
                break;
            case 6:
                System.out.println(&quot;今天是星期六&quot;);
                break;
            case 7:
                System.out.println(&quot;今天是星期天&quot;);
                break;
        }
    }
}
</code></pre>
<h2 id="数组">数组</h2>
<pre><code>int ages[];      //存放年龄的数组，类型为整型
char symbol[];   //存放符号的数组，类型为字符型
String [] name;  //存放名称的数组，类型为字符串型
</code></pre>
<pre><code>int [] ages = {12,18,9,33,45,60}; //声明并初始化了一个整型数组，它有6个元素
char [] symbol = new char[10] //声明并分配了一个长度为10的char型数组
</code></pre>
<pre><code>ages[0]=12;
</code></pre>
<pre><code>int [] a1 = {1,2,3};
int [] a2;
a2 = a1;
</code></pre>
<ul>
<li>a2 和 a1 是相同数组的不同名称</li>
</ul>
<pre><code>public class Test {
    public static void main(String[] args) {
        int [] a1 = {1,2,3};
        int [] a2;
        a2 = a1;
        for(int i = 0; i &lt; a2.length; i++){
            a2[i]++;
        }
        for(int i = 0; i &lt; a1.length; i++){
            System.out.println(a1[i]);
        }
    }
}
</code></pre>
<pre><code>$ javac Test.java
$ java Test
2
3
4
</code></pre>
<p><strong>数组遍历</strong></p>
<pre><code>int [] ages = {12, 18, 9, 33, 45, 60};
for(int i = 0; i &lt; ages.length; i++){ //ages.length是获取数组的长度
    System.out.println(&quot;数组中第&quot;+(i+1)+&quot;个元素是 &quot;+ages[i]); //数组下标是从零开始，一定要注意
}
</code></pre>
<ul>
<li>foreach</li>
</ul>
<pre><code>for(元素类型 元素变量:遍历对象){
    执行的代码
}
</code></pre>
<pre><code>public class JudgePrime {
    public static void main(String[] args){
        int [] ages = {12, 18, 9, 33, 45, 60};
        int i = 1;
        for(int age:ages){
            System.out.println(&quot;数组中第&quot;+i+&quot;个元素是&quot;+age);
            i++;
        }
    }
}
</code></pre>
<pre><code>$ javac JudgePrime.java
$ java JudgePrime
数组中第1个元素是12
数组中第2个元素是18
数组中第3个元素是9
数组中第4个元素是33
数组中第5个元素是45
数组中第6个元素是60
</code></pre>
<p><strong>二维数组</strong></p>
<pre><code>public class ArrayTest {
    public static void main(String[] args) {
        String[][] name = {{&quot;ZhaoYi&quot;, &quot;QianEr&quot;, &quot;SunSan&quot;},
                {&quot;LiSi&quot;, &quot;ZhouWu&quot;, &quot;WuLiu&quot;}};
        for (int i = 0; i &lt; 2; i++) {
            for (int j = 0; j &lt; 3; j++) {
                System.out.println(name[i][j]);
            }
        }
    }
}
</code></pre>
<pre><code>$ javac ArrayTest.java
$ java ArrayTest
ZhaoYi
QianEr
SunSan
LiSi
ZhouWu
WuLiu
</code></pre>
<p><strong>练习题</strong><br>
有一份成绩单，上面有 10 位学生的成绩（61，57，95，85，75，65，44，66，90，32），请求出平均成绩并输出</p>
<ul>
<li>将 10 位同学的成绩保存在数组中</li>
</ul>
<pre><code>public class AverageScore {
    public static void main(String[] args) {
        int[] data = {61, 57, 95, 85, 75, 65, 44, 66, 90, 32};
        int sum = 0;
        for (int i = 0; i &lt; data.length; i++) {
            sum += data[i];
        }
        System.out.println(&quot;平均成绩：&quot; + sum / data.length);
    }
}
</code></pre>
<h2 id="用户输入操作">用户输入操作</h2>
<pre><code>import java.util.Scanner;

public class ScannerDemo {
    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        //获取用户输入的一行数据  返回为字符串
        String s = in.nextLine();
        System.out.println(s);
        //循环读取String数据，当输入exit时退出循环
        while (!in.hasNext(&quot;exit&quot;)) {
            System.out.println(in.nextLine());
        }
        //关闭输入
        in.close();
    }
}
</code></pre>
<pre><code>shiyanlou
shiyanlou
aa
aa
bbb
bbb
cc
cc
exit
</code></pre>
<p><strong>练习题</strong></p>
<ul>
<li>获取用户的输入信息（字符串）<br>
当用户输入 end 时，结束输入并打印用户之前输入的所有信息（输入的信息数量不超过 100 个）</li>
</ul>
<pre><code>输入：
    shi
    yan
    lou
    end
输出：
    shi
    yan
    lou
</code></pre>
<pre><code>import java.util.Scanner;

public class InputTest {
    public static void main(String[] args) {
        String[] data = new String[100];
        Scanner in = new Scanner(System.in);
        for (int i = 0; i &lt; 100; i++) {
            if ((data[i] = in.nextLine()).equals(&quot;end&quot;)) {
                break;
            }
        }
        for (String a : data) {
            if (a.equals(&quot;end&quot;)) {
                break;
            }
            System.out.println(a);
        }
    }
}
</code></pre>
<h2 id="练习题">练习题</h2>
<ul>
<li>现给出一串数据（313, 89, 123, 323, 313, 15, 90, 56, 39）求出最大值和最小值并输出</li>
</ul>
<pre><code>import java.util.Arrays;

public class MaxAndMin {
    public static void main(String[] args) {
        int[] data = {313, 89, 123, 323, 313, 15, 90, 56, 39};
        //    方法1
        int max = data[0];
        int min = data[0];
        for (int i = 0; i &lt; data.length; i++) {
            if (data[i] &gt; max) {
                max = data[i];
            }
            if (data[i] &lt; min) {
                min = data[i];
            }
        }
        System.out.println(min);
        System.out.println(max);
        //方法二
        //Arrays.sort(data);
        //System.out.println(data[0]);
        //System.out.println(data[data.length - 1]);
        //方法三
        //System.out.println(Arrays.stream(data).min().getAsInt());
        //System.out.println(Arrays.stream(data).max().getAsInt());
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python]]></title>
        <id>https://y-rui.github.io/post/python/</id>
        <link href="https://y-rui.github.io/post/python/">
        </link>
        <updated>2020-05-08T15:28:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="逢7就跳过">逢7就跳过</h2>
<ul>
<li>while</li>
</ul>
<pre><code>a = 0
while a &lt; 100:
    a = a + 1
    if a % 7 == 0 or a % 10 == 7 or a // 10 == 7:
        continue
    else:
        print(a)
</code></pre>
<ul>
<li>for</li>
</ul>
<pre><code>for a in range(1,101):
    if a % 7 == 0 or a % 10 == 7 or a // 10 == 7:
        continue
    else:
        print(a)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jupyter Notebook 快捷键]]></title>
        <id>https://y-rui.github.io/post/jupyter-notebook-kuai-jie-jian/</id>
        <link href="https://y-rui.github.io/post/jupyter-notebook-kuai-jie-jian/">
        </link>
        <updated>2020-05-08T10:18:30.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><code>B</code>：在当前单元格下方新建空白单元格。</li>
<li><code>M</code>：将单元格格式转换为 Markdown。</li>
<li><code>Y</code>：将单元格格式转换为 Code。</li>
<li>连续按 <code>D</code>+<code>D</code>：删除当前单元格。（慎用，推荐使用 X 剪切单元格代替，因为其可以起到删除效果，且删错了还可以粘贴回来）</li>
<li><code>Shift + Enter</code>：运行当前单元格内容。（当 Markdown 单元格处于编辑状态时，运行即可复原）</li>
<li><code>Tab</code>: 代码补全</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[新手入门-Linux桌面环境使用]]></title>
        <id>https://y-rui.github.io/post/xin-shou-ru-men-linux-zhuo-mian-huan-jing-shi-yong/</id>
        <link href="https://y-rui.github.io/post/xin-shou-ru-men-linux-zhuo-mian-huan-jing-shi-yong/">
        </link>
        <updated>2020-05-07T02:03:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-打开终端">1. 打开终端</h2>
<pre><code>cd Code
//进入Code文件夹
touch hello_shiyanlou.c
//创建hello_shiyanlou.c文件
</code></pre>
<h2 id="2-输入c语言代码">2. 输入C语言代码</h2>
<pre><code>gedit hello_shiyanlou.c
//用gedit编辑器将hello_shiyanlou.c文件打开
</code></pre>
<p>在gedit里面输入以下代码</p>
<pre><code>#include&lt;stdio.h&gt;
int main()
{
    printf(&quot;Hello,Shiyanlou.&quot;);
    return 0;
}
</code></pre>
<h2 id="3-编译程序">3. 编译程序</h2>
<pre><code>gcc -o hello_shiyanlou hello_shiyanlou.c
//编译hello_shiyanlou.c程序并且生成hello_shiyanlou文件
</code></pre>
<h2 id="4-执行程序">4. 执行程序</h2>
<pre><code>./hello_shiyanlou
//执行hello_shiyanlou程序
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://y-rui.github.io/post/hello-gridea/</id>
        <link href="https://y-rui.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>