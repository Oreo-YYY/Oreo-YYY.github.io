<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Java基础2-面对对象 | NoteForStudy</title>
<link rel="shortcut icon" href="https://y-rui.github.io/favicon.ico?v=1608466007398">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://y-rui.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Java基础2-面对对象 | NoteForStudy - Atom Feed" href="https://y-rui.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="类
定义类

定义类名，用于区分不同的类。如下代码中 public class 后面跟的就是类名。class是声明类的关键字，类名后面跟上大括号，大括号里面就是类的一些信息。public 为权限修饰符
编写类的属性。对象有什么，需要通过属性..." />
    <meta name="keywords" content="Java,实验楼" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://y-rui.github.io">
  <img class="avatar" src="https://y-rui.github.io/images/avatar.png?v=1608466007398" alt="">
  </a>
  <h1 class="site-title">
    NoteForStudy
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/y-rui" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Java基础2-面对对象
            </h2>
            <div class="post-info">
              <span>
                2020-07-18
              </span>
              <span>
                26 min read
              </span>
              
                <a href="https://y-rui.github.io/tag/6kU31awxe/" class="post-tag">
                  # Java
                </a>
              
                <a href="https://y-rui.github.io/tag/ZJvG0o9NN/" class="post-tag">
                  # 实验楼
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h2 id="类">类</h2>
<p>定义类</p>
<ul>
<li>定义类名，用于区分不同的类。如下代码中 public class 后面跟的就是类名。class是声明类的关键字，类名后面跟上大括号，大括号里面就是类的一些信息。public 为权限修饰符</li>
<li>编写类的属性。对象有什么，需要通过属性来表示。属性的定义是写在类名后面的大括号里，在定义属性时，要明确属性的类型。在一个类当中可以写一个或多个属性。当然也可以不定义属性</li>
<li>编写类的方法。方法也是写在大括号里面。可以定义一个方法或多个方法，当然也可以不定义方法</li>
</ul>
<pre><code>public class People {
//属性（成员变量） 有什么
    double height;  //身高
    int age;     //年龄
    int sex;    //性别，0为男性，非0为女性

//方法 干什么
    void cry(){
        System.out.println(&quot;我在哭！&quot;);
    }
    void laugh(){
        System.out.println(&quot;我在笑！&quot;);
    }
    void printBaseMes(){
        System.out.println(&quot;我的身高是&quot;+height+&quot;cm&quot;);
        System.out.println(&quot;我的年龄是&quot;+age+&quot;岁&quot;);
        if(this.sex==0)
            System.out.println(&quot;我是男性！&quot;);
        else
            System.out.println(&quot;我是女性！&quot;);

    }
}
</code></pre>
<p>一个类可以包含以下<strong>类型变量</strong></p>
<ul>
<li>局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁</li>
<li>成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问</li>
<li>类变量：也叫静态变量，类变量也声明在类中，方法体之外，但必须声明为 static 类型</li>
</ul>
<h2 id="对象">对象</h2>
<pre><code>People LiLei = new People();
</code></pre>
<pre><code>public class NewObject {
    public static void main(String[] args) {
        People LiLei = new People(); //创建一个People对象LiLei

        LiLei.height =170;
        LiLei.age = 20;
        LiLei.sex = 1;

        LiLei.printBaseMes();
    }
}
</code></pre>
<pre><code>$ javac NewObject.java People.java
$ java NewObject
我的身高是170.0cm
我的年龄是20岁
我是女性！
</code></pre>
<h2 id="构造方法">构造方法</h2>
<pre><code>public class People{
    //无参构造方法
    public People(){

    }
    //有一个参数的构造方法
    public People(int age){

    }
}
</code></pre>
<pre><code>public class People {
//属性（成员变量）有什么
    double height;     //身高
    int age;           //年龄
    int sex;       //性别，0为男性，非0为女性

    //构造方法，初始化了所有属性
    public People(double h, int a, int s){
        height = h;
        age = a;
        sex = s;
    }
}
</code></pre>
<pre><code>//创建对象，调用我们自己定义的有参构造方法
People XiaoMing = new People(168, 21, 1);
</code></pre>
<ul>
<li>上面的例子中通过 new 关键字将类实例化成对象，而 new 后面跟的就是构造方法。于是可以知道 new + 构造方法 可以创建一个新的对象</li>
</ul>
<h2 id="引用与对象实例">引用与对象实例</h2>
<ul>
<li>在新建对象实例时，需要为对象实例设置一个对象名，就像这样</li>
</ul>
<pre><code>Object object=new Object();
</code></pre>
<ul>
<li>那么变量 object 就真的是 Object 对象么，这里其实只是创建了一个 object 对象的引用。如果同学们学过 C 语言，这里就和指针一样，变量 object 保存的其实 Object 对象的引用，指向了 Object 对象</li>
</ul>
<pre><code> ----------           ----------
 | object |---------&gt; | Object |
 ----------           ----------
 |        |           |        |
 ----------           ----------
 |        |           |        |
 ----------           ----------
 |        |           |        |
 ----------           ----------
 |        |           |        |
 ----------           ----------
</code></pre>
<ul>
<li>再看下面的例子</li>
</ul>
<pre><code>Object object1 = new Object();
Object object2 = object1;
System.out.println(object1 == object2);
</code></pre>
<ul>
<li>运行得到的结果为 true，说明 object1 和 object2 的内存地址相同 (== 会比较两个对象的内存地址是否相同），它们实际上是引用同一对象，如果改变 object1 对象内部的属性，那么 object2 的属性同样会改变</li>
</ul>
<h2 id="static">static</h2>
<p><strong>静态成员</strong></p>
<ul>
<li>Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问</li>
</ul>
<pre><code>public class StaticTest{
    public static String string=&quot;shiyanlou&quot;;
    public static void main(String[] args){
        //静态成员不需要实例化 直接就可以访问
        System.out.println(StaticTest.string);
        //如果不加static关键字 需要这样访问
        StaticTest staticTest=new StaticTest();
        System.out.println(staticTest.string);
        //如果加上static关键字，上面的两种方法都可以使用
    }
}
</code></pre>
<p><strong>静态方法</strong></p>
<ul>
<li>被 static 修饰的方法是静态方法，静态方法不依赖于对象，不需要将类实例化便可以调用，由于不实例化也可以调用，所以不能有 this，也不能访问非静态成员变量和非静态方法。但是非静态成员变量和非静态方法可以访问静态方法</li>
</ul>
<h2 id="final">final</h2>
<p>final 关键字可以修饰类、方法、属性和变量</p>
<ol>
<li>final 修饰类，则该类不允许被继承，为最终类</li>
<li>final 修饰方法，则该方法不允许被覆盖（重写）</li>
<li>final 修饰属性：则该类的属性不会进行隐式的初始化（类的初始化属性必须有值）或在构造方法中赋值（但只能选其一）</li>
<li>final 修饰变量，则该变量的值只能赋一次值，即常量</li>
</ol>
<pre><code>//静态常量
public final static String SHI_YAN_LOU=&quot;shiyanlou&quot;;
</code></pre>
<h2 id="权限修饰符">权限修饰符</h2>
<table>
<thead>
<tr>
<th>访问修饰符</th>
<th>本类</th>
<th>同包</th>
<th>子类</th>
<th>其他</th>
</tr>
</thead>
<tbody>
<tr>
<td>private</td>
<td>✔️</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>默认</td>
<td>✔️</td>
<td>✔️</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
</tr>
</tbody>
</table>
<ul>
<li>不同的访问修饰符的访问范围，比如 private 修饰的属性或者方法，只能在当前类中访问或者使用。默认 是什么修饰符都不加，默认在当前类中和同一包下都可以访问和使用。protected 修饰的属性或者方法，对同一包内的类和所有子类可见。public 修饰的属性或者方法，对所有类可见</li>
</ul>
<h2 id="封装">封装</h2>
<ul>
<li>封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别</li>
</ul>
<p>这样做有什么好处？</p>
<ol>
<li>只能通过规定的方法访问数据</li>
<li>隐藏类的实例细节，方便修改和实现</li>
</ol>
<p>如何去实现类的封装呢？</p>
<ol>
<li>修改属性的可见性，在属性的前面添加修饰符 (private)</li>
<li>对每个值属性提供对外的公共方法访问，如创建 getter/setter（取值和赋值）方法，用于对私有属性的访问</li>
<li>在 getter/setter 方法里加入属性的控制语句，例如我们可以加一个判断语句，对于非法输入给予否定</li>
</ol>
<pre><code>public class People {
    //属性（成员变量）有什么，前面添加了访问修饰符private
    //变成了私有属性，必须通过方法调用
    private double height;     //身高

    //属性已经封装好了，如果用户需要调用属性
    //必须用getter和setter方法进行调用
    //getter和setter方法需要程序员自己定义
    public double getHeight(){
    //getter 方法命名是get关键字加属性名（属性名首字母大写）
    //getter 方法一般是为了得到属性值
      return height;
    }

    //同理设置我们的setter方法
    //setter 方法命名是set关键字加属性名（首字母大写）
    //setter 方法一般是给属性值赋值，所以有一个参数
    public void setHeight(double newHeight){
      height = newHeight;
    }
}
</code></pre>
<pre><code>public class NewObject {

    public static void main(String[] args) {
        People LiLei = new People();    //创建了一个People对象LiLei

        //利用setter方法为属性赋值
        LiLei.setHeight(170.0);

        //利用getter方法取属性值
        System.out.println(&quot;LiLei的身高是&quot;+LiLei.getHeight());
    }
}
</code></pre>
<pre><code>$ javac NewObject.java People.java
$ java NewObject
LiLei的身高是170.0
</code></pre>
<h2 id="this">this</h2>
<ul>
<li>this 关键字代表当前对象。使用 this.属性 操作当前对象的属性，this.方法 调用当前对象的方法</li>
</ul>
<pre><code>public void setAge(int age) {
  this.age = age;
}
public int getAge() {
  return age;
}
</code></pre>
<ul>
<li>当成员变量和局部变量之间发生冲突时，在属性名前面添加了 this 关键字。 此时就代表将一个参数的值赋给当前对象的属性。同理 this 关键字可以调用当前对象的方法</li>
</ul>
<h2 id="继承">继承</h2>
<pre><code>public class Animal {
    public int legNum;     //动物四肢的数量

    //类方法
    public void bark() {
        System.out.println(&quot;动物叫！&quot;);
    }
}
</code></pre>
<pre><code>public class Dog extends Animal {
}
</code></pre>
<pre><code>public class Test{
    public static void main(String[] args) {
        Dog a = new Dog();
        a.legNum = 4;
        a.bark();
    }
}
</code></pre>
<pre><code>$ javac Test.java Animal.java Dog.java
$ java Test
动物叫！
</code></pre>
<p>继承的特点</p>
<ol>
<li>子类拥有父类除 private 以外的所有属性和方法</li>
<li>子类可以拥有自己的属性和方法</li>
<li>子类可以重写实现父类的方法</li>
<li>Java 中的继承是单继承，一个类只有一个父类</li>
</ol>
<ul>
<li>Java 实现多继承的一个办法是 implements（实现）接口，但接口不能有非静态的属性</li>
</ul>
<h2 id="super">super</h2>
<p>super 关键字在子类内部使用，代表父类对象</p>
<ol>
<li>访问父类的属性 super.属性名</li>
<li>访问父类的方法 super.bark()</li>
<li>子类构造方法需要调用父类的构造方法时，在子类的构造方法体里最前面的位置：super()</li>
</ol>
<h2 id="方法重载与重写">方法重载与重写</h2>
<p><strong>方法重载</strong></p>
<ul>
<li>方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。方法重载一般用于创建一组任务相似但是参数不同的方法</li>
</ul>
<pre><code>public class Test {
    void f(int i) {
        System.out.println(&quot;i=&quot; + i);
    }

    void f(float f) {
        System.out.println(&quot;f=&quot; + f);
    }

    void f(String s) {
        System.out.println(&quot;s=&quot; + s);
    }

    void f(String s1, String s2){
        System.out.println(&quot;s1+s2=&quot;+(s1+s2));
    }

    void f(String s, int i){
        System.out.println(&quot;s=&quot;+s+&quot;,i=&quot;+i);
    }

    public static void main(String[] args) {
        Test test = new Test();
        test.f(3456);
        test.f(34.56f);
        test.f(&quot;abc&quot;);
        test.f(&quot;abc&quot;,&quot;def&quot;);
        test.f(&quot;abc&quot;,3456);
    }
}
</code></pre>
<pre><code>$ javac Test.java
$ java Test
i=3456
f=34.56
s=abc
s1+s2=abcdef
s=abc,i=3456
</code></pre>
<p>方法重载有以下几种规则</p>
<ol>
<li>方法中的参数列表必须不同。比如：参数个数不同或者参数类型不同</li>
<li>重载的方法中允许抛出不同的异常</li>
<li>可以有不同的返回值类型，但是参数列表必须不同</li>
<li>可以有不同的访问修饰符</li>
</ol>
<p><strong>方法重写</strong></p>
<ul>
<li>子类可以继承父类的方法，但如果子类对父类的方法不满意，想在里面加入适合自己的一些操作时，就需要将方法进行重写。并且子类在调用方法中，优先调用子类的方法</li>
<li>当然在方法重写时要注意，重写的方法一定要与原父类的方法语法保持一致，比如返回值类型，参数类型及个数，和方法名都必须一致</li>
</ul>
<p>比如 Animal 类中有 bark() 这个方法代表了动物叫，但是不同的动物有不同的叫法，比如狗是汪汪汪，猫是喵喵喵</p>
<pre><code>public class Animal {
    //类方法
    public void bark() {
        System.out.println(&quot;动物叫！&quot;);
    }
}
</code></pre>
<pre><code>public class Dog extends Animal {
       //重写父类的bark方法
        public void bark() {
        System.out.println(&quot;汪！汪！汪！&quot;);
    }
}
</code></pre>
<pre><code>public class Test{
    public static void main(String args[]){
           Animal a = new Animal(); // Animal 对象
        Dog d = new Dog();   // Dog 对象

          Animal b = new Dog(); // Dog 对象,向上转型为Animal类型，具体会在后面的内容进行详解

          a.bark();// 执行 Animal 类的方法
         d.bark();//执行 Dog 类的方法
          b.bark();//执行 Dog 类的方法
       }
}
</code></pre>
<pre><code>$ javac Test.java Dog.java Animal.java
$ java Test
动物叫！
汪！汪！汪！
汪！汪！汪！
</code></pre>
<h2 id="多态">多态</h2>
<ul>
<li>多态是指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。多态也称作动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法</li>
<li>通俗地讲，只通过父类就能够引用不同的子类，这就是多态，我们只有在运行的时候才会知道引用变量所指向的具体实例对象</li>
</ul>
<p>多态的实现条件</p>
<ul>
<li>Java 实现多态有三个必要条件：继承、重写和向上转型（即父类引用指向子类对象）</li>
<li>只有满足上述三个条件，才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为</li>
</ul>
<p>多态的实现方式</p>
<ul>
<li>Java 中多态的实现方式：继承父类进行方法重写，抽象类和抽象方法，接口实现</li>
</ul>
<p><strong>向上转型</strong></p>
<pre><code>Animal a = new Animal();  //a是父类的引用指向的是本类的对象

Animal b = new Dog(); //b是父类的引用指向的是子类的对象
</code></pre>
<p>在这里，可以认为由于 Dog 继承于 Animal，所以 Dog 可以自动向上转型为 Animal，所以 b 是可以指向 Dog 实例对象的</p>
<ul>
<li>注：不能使用一个子类的引用去指向父类的对象，因为子类对象中可能会含有父类对象中所没有的属性和方法。</li>
</ul>
<p>如果定义了一个指向子类对象的父类引用类型，那么它除了能够引用父类中定义的所有属性和方法外，还可以使用子类强大的功能。但是对于只存在于子类的方法和属性就不能获取</p>
<pre><code>class Animal {
    //父类方法
    public void bark() {
        System.out.println(&quot;动物叫！&quot;);
    }
}

class Dog extends Animal {

    //子类重写父类的bark方法
    public void bark() {
        System.out.println(&quot;汪、汪、汪！&quot;);
    }
    //子类自己的方法
    public void dogType() {
        System.out.println(&quot;这是什么品种的狗？&quot;);
    }
}


public class Test {

    public static void main(String[] args) {
        Animal a = new Animal();
        Animal b = new Dog();
        Dog d = new Dog();

        a.bark();
        b.bark();
        //b.dogType();
        //b.dogType()编译不通过
        d.bark();
        d.dogType();
    }

}
</code></pre>
<pre><code>$ javac Test.java
$ java Test
动物叫！
汪、汪、汪！
汪、汪、汪！
这是什么品种的狗？
</code></pre>
<p>在这里，由于 b 是父类的引用，指向子类的对象，因此不能获取子类的方法（dogType() 方法）, 同时当调用 bark() 方法时，由于子类重写了父类的 bark() 方法，所以调用子类中的 bark() 方法</p>
<ul>
<li>因此，向上转型，在运行时，会遗忘子类对象中与父类对象中不同的方法，也会覆盖与父类中相同的方法——重写（方法名，参数都相同）</li>
</ul>
<h2 id="抽象类">抽象类</h2>
<ul>
<li>在定义类时，前面加上 abstract 关键字修饰的类叫抽象类</li>
</ul>
<p>抽象类中有抽象方法，这种方法是不完整的，仅有声明而没有方法体。抽象方法声明语法如下</p>
<pre><code>abstract void f();  //f()方法是抽象方法
</code></pre>
<p>那我们什么时候会用到抽象类呢？</p>
<ol>
<li>在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法。也就是说抽象类是约束子类必须要实现哪些方法，而并不关注方法如何去实现</li>
<li>从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性</li>
</ol>
<p>所以由上可知，抽象类是限制规定子类必须实现某些方法，但不关注实现细节<br>
那抽象类如何用代码实现呢，它的规则如下：</p>
<ol>
<li>用 abstract 修饰符定义抽象类</li>
<li>用 abstract 修饰符定义抽象方法，只用声明，不需要实现</li>
<li>包含抽象方法的类就是抽象类</li>
<li>抽象类中可以包含普通的方法，也可以没有抽象方法</li>
<li>抽象类的对象不能直接创建，通常是定义引用变量指向子类对象</li>
</ol>
<p>需要子类实现的抽象方法</p>
<pre><code>//抽象方法
public abstract class TelePhone {
    public abstract void call();  //抽象方法,打电话
    public abstract void message(); //抽象方法，发短信
}
</code></pre>
<p>构建子类，并实现抽象方法</p>
<pre><code>public class CellPhone extends TelePhone {

    @Override
    public void call() {
        System.out.println(&quot;我可以打电话！&quot;);
    }

    @Override
    public void message() {
        System.out.println(&quot;我可以发短信！&quot;);
    }

    public static void main(String[] args) {
        CellPhone cp = new CellPhone();
        cp.call();
        cp.message();
    }

}
</code></pre>
<pre><code>$ javac CellPhone.java TelePhone.java
$ java CellPhone

我可以打电话！
我可以发短信！
</code></pre>
<h2 id="接口">接口</h2>
<ul>
<li>接口用于描述类所具有的功能，而不提供功能的实现，功能的实现需要写在实现接口的类中，并且该类必须实现接口中所有的未实现方法</li>
</ul>
<pre><code>修饰符 interface 接口名称 [extends 其他的接口名] {
        // 声明变量
        // 抽象方法
}
</code></pre>
<pre><code>// Animal.java
interface Animal {
        //int x;
        //编译错误,x需要初始化，因为是 static final 类型
        int y = 5;
        public void eat();
        public void travel();
}
</code></pre>
<p><strong>注意点</strong><br>
在Java8中</p>
<ul>
<li>接口不能用于实例化对象</li>
<li>接口中方法只能是抽象方法、default 方法、静态方法</li>
<li>接口成员是 static final 类型</li>
<li>接口支持多继承</li>
</ul>
<p>在 Java9 中，接口可以拥有私有方法和私有静态方法，但是只能被该接口中的 default 方法和静态方法使用</p>
<p>多继承实现方式</p>
<pre><code>修饰符 interface A extends 接口1，接口2{

}

修饰符 class A implements 接口1，接口2{

}
</code></pre>
<p>实现上面的接口</p>
<pre><code>// Cat.java
public class Cat implements Animal{

     public void eat(){
         System.out.println(&quot;Cat eats&quot;);
     }

     public void travel(){
         System.out.println(&quot;Cat travels&quot;);
     }
     public static void main(String[] args) {
        Cat cat = new Cat();
        cat.eat();
        cat.travel();
    }
}
</code></pre>
<pre><code>$ javac Cat.java Animal.java
$ java Cat
Cat eats
Cat travels
</code></pre>
<h2 id="内部类">内部类</h2>
<ul>
<li>将一个类的定义放在另一个类的定义内部，这就是内部类。而包含内部类的类被称为外部类</li>
</ul>
<p>内部类的主要作用如下</p>
<ol>
<li>内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类</li>
<li>内部类的方法可以直接访问外部类的所有数据，包括私有的数据</li>
<li>内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便</li>
<li>内部类允许继承多个非接口类型</li>
</ol>
<ul>
<li>注：内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两类。对于一个名为 outer 的外部类和其内部定义的名为 inner 的内部类。编译完成后出现 outer.class 和 outer$inner.class 两类。所以内部类的成员变量 / 方法名可以和外部类的相同</li>
</ul>
<p><strong>成员内部类</strong></p>
<pre><code>// People.java
//外部类People
public class People {
    private String name = &quot;LiLei&quot;;         //外部类的私有属性
    //内部类Student
    public class Student {
        String ID = &quot;20151234&quot;;               //内部类的成员属性
        //内部类的方法
        public void stuInfo(){
            System.out.println(&quot;访问外部类中的name：&quot; + name);
            System.out.println(&quot;访问内部类中的ID：&quot; + ID);
        }
    }

    //测试成员内部类
    public static void main(String[] args) {
        People a = new People();     //创建外部类对象，对象名为a
        Student b = a.new Student(); //使用外部类对象创建内部类对象，对象名为b
        // 或者为 People.Student b = a.new Student();
        b.stuInfo();   //调用内部对象的suInfo方法
    }
}
</code></pre>
<pre><code>$ javac People.java
$ java People
访问外部类中的name：LiLei
访问内部类中的ID：20151234
</code></pre>
<p>成员内部类的使用方法</p>
<ol>
<li>Student 类相当于 People 类的一个成员变量，所以 Student 类可以使用任意访问修饰符</li>
<li>Student 类在 People 类里，所以访问范围在类里的所有方法均可以访问 People 的属性（即内部类里可以直接访问外部类的方法和属性，反之不行）</li>
<li>定义成员内部类后，必须使用外部类对象来创建内部类对象，即 内部类 对象名 = 外部类对象.new 内部类();</li>
<li>如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用 this 关键字。如上述代码中：a.this</li>
</ol>
<ul>
<li>注：成员内部类不能含有 static 的变量和方法，因为成员内部类需要先创建了外部类，才能创建它自己的</li>
</ul>
<p><strong>静态内部类</strong></p>
<ul>
<li>静态内部类通常被称为嵌套类</li>
</ul>
<pre><code>// People.java
//外部类People
public class People {
    private String name = &quot;LiLei&quot;;         //外部类的私有属性

/*外部类的静态变量。
Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问。
*/
    static String ID = &quot;510xxx199X0724XXXX&quot;;

    //静态内部类Student
    public static class Student {
        String ID = &quot;20151234&quot;;               //内部类的成员属性
        //内部类的方法
        public void stuInfo(){
            System.out.println(&quot;访问外部类中的name：&quot; + (new People().name));
            System.out.println(&quot;访问外部类中的ID：&quot; + People.ID);
            System.out.println(&quot;访问内部类中的ID：&quot; + ID);
        }
    }

    //测试成员内部类
    public static void main(String[] args) {
        Student b = new Student();   //直接创建内部类对象，对象名为b
        b.stuInfo();                 //调用内部对象的suInfo方法
    }
}
</code></pre>
<pre><code>$ javac People.java
$ java People
访问外部类中的name：LiLei
访问外部类中的ID：510xxx199X0724XXXX
访问内部类中的ID：20151234
</code></pre>
<p>静态内部类是 static 修饰的内部类，这种内部类的特点是</p>
<ol>
<li>静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问</li>
<li>如果外部类的静态成员与内部类的成员名称相同，可通过 类名.静态成员 访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过 成员名 直接调用外部类的静态成员</li>
<li>创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名 = new 内部类();</li>
</ol>
<p><strong>局部内部类</strong></p>
<ul>
<li>局部内部类，是指内部类定义在方法和作用域内</li>
</ul>
<pre><code>// People.java
//外部类People
public class People {
    //定义在外部类中的方法内：
    public void peopleInfo() {
        final String sex = &quot;man&quot;;  //外部类方法中的常量
        class Student {
            String ID = &quot;20151234&quot;; //内部类中的常量
            public void print() {
                System.out.println(&quot;访问外部类的方法中的常量sex：&quot; + sex);
                System.out.println(&quot;访问内部类中的变量ID:&quot; + ID);
            }
        }
        Student a = new Student();  //创建方法内部类的对象
        a.print();//调用内部类的方法
    }
    //定义在外部类中的作用域内
    public void peopleInfo2(boolean b) {
        if(b){
            final String sex = &quot;man&quot;;  //外部类方法中的常量
            class Student {
                String ID = &quot;20151234&quot;; //内部类中的常量
                public void print() {
                    System.out.println(&quot;访问外部类的方法中的常量sex：&quot; + sex);
                    System.out.println(&quot;访问内部类中的变量ID:&quot; + ID);
                }
            }
            Student a = new Student();  //创建方法内部类的对象
            a.print();//调用内部类的方法
        }
    }
    //测试方法内部类
    public static void main(String[] args) {
        People b = new People(); //创建外部类的对象
        System.out.println(&quot;定义在方法内：===========&quot;);
        b.peopleInfo();  //调用外部类的方法
        System.out.println(&quot;定义在作用域内：===========&quot;);
        b.peopleInfo2(true);
    }
}
</code></pre>
<pre><code>$ javac People.java
$ java People
定义在方法内：===========
访问外部类的方法中的常量sex：man
访问内部类中的变量ID:20151234
定义在作用域内：===========
访问外部类的方法中的常量sex：man
访问内部类中的变量ID:20151234
</code></pre>
<ul>
<li>局部内部类也像别的类一样进行编译，但只是作用域不同而已，只在该方法或条件的作用域内才能使用，退出这些作用域后无法引用的</li>
</ul>
<p><strong>匿名内部类</strong></p>
<ul>
<li>匿名内部类，顾名思义，就是没有名字的内部类。正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写。但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口</li>
</ul>
<pre><code>// Outer.java
public class Outer {

    public Inner getInner(final String name, String city) {
        return new Inner() {
            private String nameStr = name;
            public String getName() {
                return nameStr;
            }
        };
    }

    public static void main(String[] args) {
        Outer outer = new Outer();
        Inner inner = outer.getInner(&quot;Inner&quot;, &quot;NewYork&quot;);
        System.out.println(inner.getName());
    }
}
interface Inner {
    String getName();
}
</code></pre>
<p>运行结果：Inner</p>
<ul>
<li>匿名内部类是不能加访问修饰符的。要注意的是，new 匿名类，这个类是要先定义的, 如果不先定义，编译时会报错该类找不到</li>
<li>同时，在上面的例子中，当所在的方法的形参需要在内部类里面使用时，该形参必须为 final。这里可以看到形参 name 已经定义为 final 了，而形参 city 没有被使用则不用定义为 final</li>
</ul>
<p>然而，因为匿名内部类没名字，是用默认的构造方法的，无参数的，如果需要该类有带参数的构造方法，示例如下</p>
<pre><code>public Inner getInner(final String name, String city) {
  return new Inner(name, city) {
    private String nameStr = name;

    public String getName() {
      return nameStr;
    }
  };
}
</code></pre>
<ul>
<li>注意这里的形参 city，由于它没有被匿名内部类直接使用，而是被抽象类 Inner 的构造方法所使用，所以不必定义为 final</li>
</ul>
<h2 id="package">package</h2>
<ul>
<li>为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间</li>
</ul>
<p><strong>包的作用</strong></p>
<ul>
<li>把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用</li>
<li>包采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别</li>
<li>包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类</li>
</ul>
<pre><code>//在定义文件夹的时候利用&quot;/&quot;来区分层次
//包中用&quot;.&quot;来分层
package com.shiyanlou.java
</code></pre>
<p>如何在不同包中使用另一个包中的类？</p>
<ul>
<li>使用 import 关键字。比如要导入包 com.shiyanlou 下 People 这个类，import com.shiyanlou.People;。同时如果 import com.shiyanlou.<em>; 这是将包下的所有文件都导入进来，</em> 是通配符</li>
</ul>
<p><strong>包的命名规范是全小写字母拼写</strong></p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E7%B1%BB">类</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1">对象</a></li>
<li><a href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">构造方法</a></li>
<li><a href="#%E5%BC%95%E7%94%A8%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B">引用与对象实例</a></li>
<li><a href="#static">static</a></li>
<li><a href="#final">final</a></li>
<li><a href="#%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6">权限修饰符</a></li>
<li><a href="#%E5%B0%81%E8%A3%85">封装</a></li>
<li><a href="#this">this</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF">继承</a></li>
<li><a href="#super">super</a></li>
<li><a href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99">方法重载与重写</a></li>
<li><a href="#%E5%A4%9A%E6%80%81">多态</a></li>
<li><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB">抽象类</a></li>
<li><a href="#%E6%8E%A5%E5%8F%A3">接口</a></li>
<li><a href="#%E5%86%85%E9%83%A8%E7%B1%BB">内部类</a></li>
<li><a href="#package">package</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://y-rui.github.io/post/java-stringbuilder/">
              <h3 class="post-title">
                Java - StringBuilder
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/y-rui" target="_blank">y-rui</a>
  <a class="rss" href="https://y-rui.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
