<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Java基础3-常用类 | Gridea</title>
<link rel="shortcut icon" href="https://y-rui.github.io/favicon.ico?v=1607965906290">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://y-rui.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Java基础3-常用类 | Gridea - Atom Feed" href="https://y-rui.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="Arrays

Arrays 类包含用于操作数组的各种方法（例如排序和搜索）。还包含一个静态工厂，允许将数组转为 List

Arrays 常用方法



方法
描述




&lt;T&gt; List&lt;T&gt; asList(T..." />
    <meta name="keywords" content="Java,实验楼" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://y-rui.github.io">
  <img class="avatar" src="https://y-rui.github.io/images/avatar.png?v=1607965906290" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Java基础3-常用类
            </h2>
            <div class="post-info">
              <span>
                2020-07-23
              </span>
              <span>
                16 min read
              </span>
              
                <a href="https://y-rui.github.io/tag/6kU31awxe/" class="post-tag">
                  # Java
                </a>
              
                <a href="https://y-rui.github.io/tag/ZJvG0o9NN/" class="post-tag">
                  # 实验楼
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h2 id="arrays">Arrays</h2>
<ul>
<li>Arrays 类包含用于操作数组的各种方法（例如排序和搜索）。还包含一个静态工厂，允许将数组转为 List</li>
</ul>
<p><strong>Arrays 常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;T&gt; List&lt;T&gt; asList(T... a)</code></td>
<td>返回由指定数组构造的 List</td>
</tr>
<tr>
<td><code>void sort(Object[] a)</code></td>
<td>对数组进行排序</td>
</tr>
<tr>
<td><code>void fill(Object[] a, Object val)</code></td>
<td>为数组的所有元素都赋上相同的值</td>
</tr>
<tr>
<td><code>boolean equals(Object[] a, Object[] a2)</code></td>
<td>检查两个数组是否相等</td>
</tr>
<tr>
<td><code>int binarySearch(Object[] a, Object key)</code></td>
<td>对排序后的数组使用二分法查找数据</td>
</tr>
</tbody>
</table>
<p><strong>实例</strong></p>
<pre><code>import java.util.Arrays;
import java.util.Random;

public class ArraysDemo {
    public static void main(String[] args) {
        int[] arr = new int[10];
        //将数组元素都设为9
        Arrays.fill(arr, 9);
        System.out.println(&quot;fill:&quot; + Arrays.toString(arr));
        Random random = new Random();
        for (int i = 0; i &lt; arr.length; i++) {
            //使用100以内的随机数赋值数组
            arr[i] = random.nextInt(101);
        }
        //重新赋值后的数组
        System.out.println(&quot;重新赋值：&quot; + Arrays.toString(arr));
        //将索引为5的元素设为50
        arr[5] = 50;
        //排序
        Arrays.sort(arr);
        //排序后的数组
        System.out.println(&quot;sort排序后：&quot; + Arrays.toString(arr));
        //查找50的位置
        int i = Arrays.binarySearch(arr, 50);
        System.out.println(&quot;值为50的元素索引：&quot;+i);
        //复制一份新数组
        int[] newArr = Arrays.copyOf(arr, arr.length);
        //比较
        System.out.println(&quot;equals:&quot;+Arrays.equals(arr, newArr));
    }
}
</code></pre>
<pre><code>$ javac ArraysDemo.java
$ java ArraysDemo
fill:[9, 9, 9, 9, 9, 9, 9, 9, 9, 9]
重新赋值：[69, 83, 40, 58, 94, 42, 2, 53, 43, 83]
sort排序后：[2, 40, 43, 50, 53, 58, 69, 83, 83, 94]
值为50的元素索引：3
equals:true
</code></pre>
<p><strong>练习题</strong></p>
<ul>
<li>使用 Arrays 将数组 [6, 17, 92, 32, 58, 22, 84, 66, 36, 33] 进行排序</li>
<li>找出排序后 33 所在的位置</li>
<li>测试一下如果不排序能否找到值 33</li>
</ul>
<pre><code>import java.util.Arrays;

public class ArraysTest {
    public static void main(String[] args) {
        int[] arr = {6, 17, 92, 32, 58, 22, 84, 66, 36, 33};
        Arrays.sort(arr);
        System.out.println(Arrays.binarySearch(arr, 33));
    }
}
</code></pre>
<h2 id="stringbuilder">StringBuilder</h2>
<ul>
<li>StringBuilder 类是可变的。它是 String 的对等类，它可以增加和编写字符的可变序列，并且能够将字符插入到字符串中间或附加到字符串末尾（当然是不用创建其他对象的）</li>
</ul>
<p><strong>StringBuilder 的构造方法</strong></p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>StringBuilder()</code></td>
<td>构造一个其中不带字符的 StringBuilder，其初始容量为 16 个字符</td>
</tr>
<tr>
<td><code>StringBuilder(CharSequence seq)</code></td>
<td>构造一个 StringBuilder，它包含与指定CharSequence 相同的字符</td>
</tr>
<tr>
<td><code>StringBuilder(int capacity)</code></td>
<td>构造一个具有指定初始容量的 StringBuilder</td>
</tr>
<tr>
<td><code>StringBuilder(String str)</code></td>
<td>并将其内容初始化为指定的字符串内容</td>
</tr>
</tbody>
</table>
<p><strong>StringBuilder 类的常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>返回值</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>insert(int offsetm,Object obj)</code></td>
<td>StringBuilder</td>
<td>在 offsetm 的位置插入字符串 obj</td>
</tr>
<tr>
<td><code>append(Object obj)</code></td>
<td>StringBuilder</td>
<td>在字符串末尾追加字符串 obj</td>
</tr>
<tr>
<td><code>length()</code></td>
<td>int</td>
<td>确定 StringBuilder 对象的长度</td>
</tr>
<tr>
<td><code>setCharAt(int index,char ch)</code></td>
<td>void</td>
<td>使用 ch 指定的新值设置 index 指定的位置上的字符</td>
</tr>
<tr>
<td><code>toString()</code></td>
<td>String</td>
<td>转换为字符串形式</td>
</tr>
<tr>
<td><code>reverse()</code></td>
<td>StringBuilder</td>
<td>反转字符串</td>
</tr>
<tr>
<td><code>delete(int start, int end)</code></td>
<td>StringBuilder</td>
<td>删除调用对象中从 start 位置开始直到end指定的索引（end-1）位置的字符序列</td>
</tr>
<tr>
<td><code>replace(int start, int end, String str)</code></td>
<td>StringBuilder</td>
<td>使用一组字符替换另一组字符。将用替换字符串从 start 指定的位置开始替换，直到 end 指定的位置结束</td>
</tr>
</tbody>
</table>
<pre><code>public class StringBuilderTest {

    public static void main(String[] args){
        //定义和初始化一个StringBuilder类的字串s
        StringBuilder s = new StringBuilder(&quot;I&quot;);
        //在s后面添加字串&quot; java&quot;
        s.append(&quot; java&quot;);
        //在s[1]的位置插入字串
        s.insert(1, &quot; love&quot;);
        String t = s.toString(); //转为字符串
        System.out.println(t);
    }
}
</code></pre>
<p>输出结果为：I love java</p>
<h2 id="calendar">Calendar</h2>
<p>在早期的 JDK 版本中，Date 类附有两大功能</p>
<ol>
<li>允许用年、月、日、时、分、秒来解释日期</li>
<li>允许对表示日期的字符串进行格式化和句法分析</li>
</ol>
<ul>
<li>在 JDK1.1 中提供了类 Calendar 来完成第一种功能，类 DateFormat 来完成第二项功能。DateFormat 是 java.text 包中的一个类。与 Date 类有所不同的是，DateFormat 类可以接受用各种语言和不同习惯表示的日期字符串</li>
<li>但是 Calendar 类是一个抽象类，它完成 Date 类与普通日期表示法之间的转换，而我们更多的是使用 Calendar 类的子类 GregorianCalendar 类。它实现了世界上普遍使用的公历系统。当然我们也可以继承 Calendar 类，然后自己定义实现日历方法</li>
</ul>
<p><strong>GregorianCalendar 类的构造函数</strong></p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>GregorianCalendar()</code></td>
<td>创建的对象中的相关值被设置成指定时区，缺省地点的当前时间，即程序运行时所处的时区、地点的当前时间</td>
</tr>
<tr>
<td><code>GregorianCalendar(TimeZone zone)</code></td>
<td>创建的对象中的相关值被设置成指定时区 zone，缺省地点的当前时间</td>
</tr>
<tr>
<td><code>GregorianCalendar(Locale aLocale)</code></td>
<td>创建的对象中的相关值被设置成缺省时区，指定地点 aLocale 的当前时间</td>
</tr>
<tr>
<td><code>GregorianCalendar(TimeZone zone,Locale aLocale)</code></td>
<td>创建的对象中的相关值被设置成指定时区，指定地点的当前时间</td>
</tr>
</tbody>
</table>
<ul>
<li>TimeZone 是 java.util 包中的一个类，其中封装了有关时区的信息。每一个时区对应一组 ID。类 TimeZone 提供了一些方法完成时区与对应 ID 两者之间的转换</li>
</ul>
<pre><code>//太平洋时区的 ID 为 PST
TimeZone tz0 = TimeZone.getTimeZone(&quot;PST&quot;)
//getDefault()可以获取主机所处时区的对象
TimeZone tz1 = TimeZone.getDefault()
</code></pre>
<ul>
<li>Locale 只是一种机制，它用来标识一个特定的地理、政治或文化区域获取一个 Locale 对象的构造方法</li>
</ul>
<pre><code>//调用Locale类的构造方法
Locale l0 = new Locale(String language)
Locale l1 = new Locale(String language, String country)
Locale l2 = new Locale(String languge, String country, String variant)

//调用Locale类中定义的常量
Locale  l1 = Locale.CHINA
</code></pre>
<p><strong>实例</strong></p>
<pre><code>import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

public class CalendarDemo {
    public static void main(String[] args) {
        System.out.println(&quot;完整显示日期时间：&quot;);
        // 字符串转换日期格式
        DateFormat fdate = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        String str = fdate.format(new Date());
        System.out.println(str);

        // 创建 Calendar 对象
        Calendar calendar = Calendar.getInstance();
        // 初始化 Calendar 对象，但并不必要，除非需要重置时间
        calendar.setTime(new Date());

        // 显示年份
        System.out.println(&quot;年： &quot; + calendar.get(Calendar.YEAR));

        // 显示月份 (从0开始, 实际显示要加一)
        System.out.println(&quot;月： &quot; + calendar.get(Calendar.MONTH));


        // 当前分钟数
        System.out.println(&quot;分钟： &quot; + calendar.get(Calendar.MINUTE));

        // 今年的第 N 天
        System.out.println(&quot;今年的第 &quot; + calendar.get(Calendar.DAY_OF_YEAR) + &quot;天&quot;);

        // 本月第 N 天
        System.out.println(&quot;本月的第 &quot; + calendar.get(Calendar.DAY_OF_MONTH) + &quot;天&quot;);

        // 3小时以后
        calendar.add(Calendar.HOUR_OF_DAY, 3);
        System.out.println(&quot;三小时以后的时间： &quot; + calendar.getTime());
        // 格式化显示
        str = (new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SS&quot;)).format(calendar.getTime());
        System.out.println(str);

        // 重置 Calendar 显示当前时间
        calendar.setTime(new Date());
        str = (new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SS&quot;)).format(calendar.getTime());
        System.out.println(str);

        // 创建一个 Calendar 用于比较时间
        Calendar calendarNew = Calendar.getInstance();

        // 设定为 5 小时以前，后者大，显示 -1
        calendarNew.add(Calendar.HOUR, -5);
        System.out.println(&quot;时间比较：&quot; + calendarNew.compareTo(calendar));

        // 设定7小时以后，前者大，显示 1
        calendarNew.add(Calendar.HOUR, +7);
        System.out.println(&quot;时间比较：&quot; + calendarNew.compareTo(calendar));

        // 退回 2 小时，时间相同，显示0
        calendarNew.add(Calendar.HOUR, -2);
        System.out.println(&quot;时间比较：&quot; + calendarNew.compareTo(calendar));

        // calendarNew创建时间点
        System.out.println((new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SS&quot;)).format(calendarNew.getTime()));
        // calendar创建时间点
        System.out.println((new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SS&quot;)).format(calendar.getTime()));
        System.out.println(&quot;时间比较：&quot; + calendarNew.compareTo(calendar));
    }
}
</code></pre>
<pre><code>$ javac CalendarDemo.java
$ java CalendarDemo
完整显示日期时间：
2018-12-12 15:50:49
年： 2018
月： 11
分钟： 50
今年的第 346天
本月的第 12天
三小时以后的时间： Wed Dec 12 18:50:49 CST 2018
2018-12-12 18:50:49:449
2018-12-12 15:50:49:455
时间比较：-1
时间比较：1
时间比较：1
2018-12-12 15:50:49:456
2018-12-12 15:50:49:455
时间比较：1
</code></pre>
<p>运行上面的代码后，看见控制台上的输出结果会不会有所疑问呢？</p>
<ul>
<li>其实 month 的含义与 Date 类相同，0 代表 1 月，11 代表 12 月</li>
<li>有的可能不明白最后一个的输出为什么有时是 0 ，有时是 1，在这里会涉及到 calendarNew 与 calendar 的创建时间点，calendarNew 经过增加和减少时间后恢复到原来的时间点，也就是最终比较的是谁先创建好，时间点靠后的大一些，而 calendarNew 创建的时间点只有可能是大于等于 calendar 的，需要根据实际的创建时间点进行比较</li>
</ul>
<h2 id="date">Date</h2>
<ul>
<li>Date 类表示日期和时间，里面封装了操作日期和时间的方法。Date 类经常用来获取系统当前时间</li>
</ul>
<p>类 Date 中定义的未过时的构造方法</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Date()</code></td>
<td>构造一个 Date 对象并对其进行初始化以反映当前时间</td>
</tr>
<tr>
<td><code>Date(long date)</code></td>
<td>构造一个 Date 对象，并根据相对于 GMT 1970 年 1 月 1 日 00:00:00 的毫秒数对其进行初始化</td>
</tr>
</tbody>
</table>
<p><strong>实例</strong></p>
<pre><code>import java.text.SimpleDateFormat;
import java.util.Date;

public class DateDemo {
    public static void main(String[] args) {
        String strDate, strTime;
        Date objDate = new Date();
        System.out.println(&quot;今天的日期是：&quot; + objDate);
        long time = objDate.getTime();
        System.out.println(&quot;自1970年1月1日起以毫秒为单位的时间（GMT）：&quot; + time);
        strDate = objDate.toString();
        //提取 GMT 时间
        strTime = strDate.substring(11, (strDate.length() - 4));
        //按小时、分钟和秒提取时间
        strTime = &quot;时间：&quot; + strTime.substring(0, 8);
        System.out.println(strTime);
        //格式化时间
        SimpleDateFormat formatter = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        System.out.println(formatter.format(objDate));
    }
}
</code></pre>
<pre><code>$ javac DateDemo.java
$ java DateDemo
今天的日期是：Wed Dec 12 14:43:15 CST 2018
自1970年1月1日起以毫秒为单位的时间（GMT）：1544596995669
时间：14:43:15
2018-12-12 14:43:15
</code></pre>
<ul>
<li>Date 类的很多方法自 JDK 1.1 开始就已经过时了</li>
</ul>
<h2 id="math">Math</h2>
<ul>
<li>Math 类在 java.lang 包中，包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数</li>
</ul>
<p><strong>常见方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>返回值</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pow(double a, double b)</code></td>
<td>double</td>
<td>计算 a 的 b 次方</td>
</tr>
<tr>
<td><code>sqrt(double numvalue)</code></td>
<td>double</td>
<td>计算给定值的正平方根</td>
</tr>
<tr>
<td><code>abs(int numvalue)</code></td>
<td>int</td>
<td>计算 int 类型值 numvalue 的绝对值，也接收 long、float 和 double 类型的参数</td>
</tr>
<tr>
<td><code>max(int a, int b)</code></td>
<td>int</td>
<td>返回 int 型 a 和 b 中的较大值，也接收 long、float 和 double 类型的参数</td>
</tr>
<tr>
<td><code>min(int a, int b)</code></td>
<td>int</td>
<td>返回 a 和 b 中的较小值，也可接受 long、float 和 double 类型的参数</td>
</tr>
<tr>
<td><code>random()</code></td>
<td>double</td>
<td>返回带正号的 double 值，该值大于等于 0.0 且小于 1.0</td>
</tr>
</tbody>
</table>
<p><strong>实例</strong></p>
<pre><code>public class MathDemo {
    public static void main(String[] args) {
        System.out.println(Math.abs(-12.7));
        System.out.println(Math.ceil(12.7));
        System.out.println(Math.rint(12.4));
        System.out.println(Math.random());
        System.out.println(&quot;sin30 = &quot; + Math.sin(Math.PI / 6));
        // 计算30°的正弦值，参数是用弧度表示的角，即π的六分之一
        System.out.println(&quot;cos30 = &quot; + Math.cos(Math.PI / 6));
        // 计算30°的余弦值，这些计算三角函数的方法，其参数和返回值的类型都为double
        System.out.println(&quot;tan30 = &quot; + Math.tan(Math.PI / 6));
        // 计算30°的正切值
    }
}
</code></pre>
<pre><code>$ javac MathDemo.java
$ java MathDemo
12.7
13.0
12.0
0.8011998172263968
sin30 = 0.49999999999999994
cos30 = 0.8660254037844387
tan30 = 0.5773502691896257
</code></pre>
<p><strong>练习题</strong></p>
<ul>
<li>使用 Math.random() 生成两个随机数 a 和 b</li>
<li>求出两个随机数中的较大值</li>
<li>只能使用 Math 类中的方法</li>
</ul>
<pre><code>public class MathTest {
    public static void main(String[] args) {
        double a = Math.random();
        double b = Math.random();
        System.out.println(a);
        System.out.println(b);
        System.out.println(Math.max(a, b));
    }

}
</code></pre>
<h2 id="system">System</h2>
<p>System 类提供了以下功能</p>
<ul>
<li>标准输入，标准输出和错误输出流</li>
<li>访问外部定义的属性和环境变量</li>
<li>加载文件和库的方法</li>
<li>以及用于快速复制数组的实用方法</li>
</ul>
<p>System 不可以被实例化，只可以使用其静态方法</p>
<pre><code>//从指定的源数组中复制一个数组，从源数组指定的位置开始，到目标数组指定的位置
public static void arraycopy(Object src,int srcPos, Object dest,int desPos,int length)
//返回以毫秒为单位的当前时间(从1970年到现在的毫秒数)
public static long currentTimeMillis()
//终止当前正在运行的Java虚拟机，status为 0时退出
public static void exit(int status)
//  运行垃圾收集器
public static void gc()
// 取得当前系统的全部属性
public static Properties getProperties()
//获取指定键的系统属性
public static String  getProperty(String key)
</code></pre>
<pre><code>$ javac SystemDemo.java
$ java SystemDemo
[1, 2, 8, 9, 10, 6]
当前时间：1544670501472
java版本信息：11
</code></pre>
<p><strong>练习题</strong></p>
<ul>
<li>获取 Java 的安装目录 (java.home)</li>
<li>练习 System.arraycopy 方法（自己随便复制两个数组）</li>
</ul>
<pre><code>import java.util.Arrays;

public class SystemTest {
    public static void main(String[] args) {
        int[] a = {7, 8, 9, 10, 11};
        int[] b = {1, 2, 3, 4, 5, 6};
        //从数组a的第二个元素开始，复制到b数组的第三个位置 复制的元素长度为3
        System.arraycopy(a, 1, b, 2, 3);
        //输出结果
        System.out.println(Arrays.toString(b));
        System.out.println(&quot;java安装路径：&quot; + System.getProperty(&quot;java.home&quot;));
    }
}
</code></pre>
<h2 id="random">Random</h2>
<ul>
<li>Random 类用于生成伪随机数流，在 java.util包下</li>
</ul>
<pre><code>import java.util.Random;

public class RandomDemo {
    public static void main(String[] args) {
        Random random = new Random();
        //随机生成一个整数 int范围
        System.out.println(random.nextInt());
        //生成 [0,n] 范围的整数  设n=100
        System.out.println(random.nextInt(100 + 1));
        //生成 [0,n) 范围的整数  设n=100
        System.out.println(random.nextInt(100));
        //生成 [m,n] 范围的整数  设n=100 m=40
        System.out.println((random.nextInt(100 - 40 + 1) + 40));
        //随机生成一个整数 long范围
        System.out.println(random.nextLong());
        //生成[0,1.0)范围的float型小数
        System.out.println(random.nextFloat());
        //生成[0,1.0)范围的double型小数
        System.out.println(random.nextDouble());
    }
}
</code></pre>
<pre><code>$ javac RandomDemo.java
$ java RandomDemo
272128541
67
93
66
-23177167376469717070.93104035
0.20044632645967309
</code></pre>
<p><strong>练习题</strong></p>
<ul>
<li>从控制台中获取 Int 数据 m，n (m &lt; n)，先输入 m，后输入 n</li>
<li>输出一个 [m,n] 之间的随机数</li>
</ul>
<pre><code>import java.util.Random;
import java.util.Scanner;

public class RandomTest {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int m = in.nextInt();
        int n = in.nextInt();
        Random random = new Random();
        System.out.println(random.nextInt(n - m + 1) + m);
    }
}
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#arrays">Arrays</a></li>
<li><a href="#stringbuilder">StringBuilder</a></li>
<li><a href="#calendar">Calendar</a></li>
<li><a href="#date">Date</a></li>
<li><a href="#math">Math</a></li>
<li><a href="#system">System</a></li>
<li><a href="#random">Random</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://y-rui.github.io/post/java-2-mian-dui-dui-xiang/">
              <h3 class="post-title">
                Java基础2-面对对象
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://y-rui.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
