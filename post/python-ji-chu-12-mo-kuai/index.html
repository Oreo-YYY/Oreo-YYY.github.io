<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Python基础12-模块 | NoteForStudy</title>
<link rel="shortcut icon" href="https://y-rui.github.io/favicon.ico?v=1608466007398">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://y-rui.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Python基础12-模块 | NoteForStudy - Atom Feed" href="https://y-rui.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="模块
到目前为止，我们在 Python 解释器中写的所有代码都在我们退出解释器的时候丢失了。但是当人们编写大型程序的时候他们会倾向于将代码分为多个不同的文件以便使用，调试以及拥有更好的可读性。在 Python 中我们使用模块来到达这些目的。..." />
    <meta name="keywords" content="Python,实验楼" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://y-rui.github.io">
  <img class="avatar" src="https://y-rui.github.io/images/avatar.png?v=1608466007398" alt="">
  </a>
  <h1 class="site-title">
    NoteForStudy
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/y-rui" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Python基础12-模块
            </h2>
            <div class="post-info">
              <span>
                2020-08-18
              </span>
              <span>
                8 min read
              </span>
              
                <a href="https://y-rui.github.io/tag/uGwwKRarA/" class="post-tag">
                  # Python
                </a>
              
                <a href="https://y-rui.github.io/tag/ZJvG0o9NN/" class="post-tag">
                  # 实验楼
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h2 id="模块">模块</h2>
<p>到目前为止，我们在 Python 解释器中写的所有代码都在我们退出解释器的时候丢失了。但是当人们编写大型程序的时候他们会倾向于将代码分为多个不同的文件以便使用，调试以及拥有更好的可读性。在 Python 中我们使用模块来到达这些目的。模块是包括 Python 定义和声明的文件。文件名就是模块名加上  .py  后缀</p>
<p>你可以由全局变量 <code>__name__</code> 得到模块的模块名（一个字符串）</p>
<pre><code>&quot;&quot;&quot;
Bars Module
============
这是一个打印不同分割线的示例模块
&quot;&quot;&quot;
def starbar(num):
    &quot;&quot;&quot;打印 * 分割线

    :arg num: 线长
    &quot;&quot;&quot;
    print('*' * num)

def hashbar(num):
    &quot;&quot;&quot;打印 # 分割线

    :arg num: 线长
    &quot;&quot;&quot;
    print('#' * num)

def simplebar(num):
    &quot;&quot;&quot;打印 - 分割线

    :arg num: 线长
    &quot;&quot;&quot;
    print('-' * num)
</code></pre>
<p>现在我们启动解释器然后导入我们的模块</p>
<pre><code>&gt;&gt;&gt; import bars
&gt;&gt;&gt;
</code></pre>
<p>我们必须使用模块名来访问模块内的函数</p>
<pre><code>&gt;&gt;&gt; bars.hashbar(10)
##########
&gt;&gt;&gt; bars.simplebar(10)
----------
&gt;&gt;&gt; bars.starbar(10)
**********
</code></pre>
<p><strong>导入模块</strong><br>
有不同的方式导入模块。我们已经看到过一种了。你甚至可以从模块中导入指定的函数。这样做</p>
<pre><code>&gt;&gt;&gt; from bars import simplebar, starbar
&gt;&gt;&gt; simplebar(20)
--------------------
</code></pre>
<p>你也可以使用 <code>from module import *</code> 导入模块中的所有定义，然而这并不是推荐的做法</p>
<h2 id="包">包</h2>
<ul>
<li>含有 <code>__init__.py</code> 文件的目录可以用来作为一个包，目录里的所有 .py 文件都是这个包的子模块</li>
</ul>
<p>本节实验将创建下面的 mymodule 目录，mymodule 是一个包名并且 bars 和 utils 是里面的两个子模块</p>
<p>首先创建 mymodule 目录</p>
<pre><code>cd /home/shiyanlou
mkdir mymodule
</code></pre>
<p>然后将上一节编写的 <code>bars.py</code> 拷贝到 mymodule 目录下，然后可以使用 touch 创建一个 <code>utils.py</code> 文件</p>
<p>使用 touch 命令创建一个空的 <code>__init__.py</code> 文件</p>
<pre><code>touch mymodule/__init__.py
</code></pre>
<p>如果 <code>__init__.py</code> 文件内有一个名为 <code>__all__</code> 的列表，那么只有在列表内列出的名字将会被公开</p>
<p>因此如果 mymodule 内的 <code>__init__.py</code> 文件含有以下内容</p>
<pre><code>from mymodule.bars import simplebar
__all__ = [simplebar, ]
</code></pre>
<p>那么导入时将只有 simplebar 可用。如果你在 python3 解释器中进行测试，需要确定是在 mymodule 目录同级的目录下执行的 python3，类似下面的操作，否则会出现 <code>ImportError: No module named 'mymodule'</code> 的报错</p>
<pre><code>cd /home/shiyanlou
python3
&gt;&gt;&gt;
</code></pre>
<p><code>from mymodule import *</code> 只能工作在模块级别的对象上，试图导入函数或类将导致 <code>syntax error</code></p>
<h2 id="默认模块">默认模块</h2>
<p>现在你安装 Python 的时候会附带安装不同的模块，你可以按需使用它们，也可以为其它特殊用途安装新模块。<br>
你也能在解释器里使用 <code>help()</code> 函数查找任何模块/类的文档。如果你想要知道字符串所有可用的方法，你可以像下面这样做</p>
<pre><code>&gt;&gt;&gt; help(str)
</code></pre>
<p><strong>os 模块</strong></p>
<ul>
<li>os 模块提供了与操作系统相关的功能</li>
</ul>
<pre><code>&gt;&gt;&gt; import os
</code></pre>
<p><code>getuid()</code> 函数返回当前进程的有效用户 id</p>
<pre><code>&gt;&gt;&gt; os.getuid()
500
</code></pre>
<p><code>getpid()</code> 函数返回当前进程的 id。<code>getppid()</code> 返回父进程的 id</p>
<pre><code>&gt;&gt;&gt; os.getpid()
16150
&gt;&gt;&gt; os.getppid()
14847
</code></pre>
<p><code>uname()</code> 函数返回识别操作系统的不同信息，在 Linux 中它返回的详细信息可以从 <code>uname -a</code> 命令得到。<code>uname()</code> 返回的对象是一个元组，<code>(sysname, nodename, release, version, machine)</code></p>
<pre><code>&gt;&gt;&gt; os.uname()
('Linux', 'd80', '2.6.34.7-56.fc13.i686.PAE', '#1 SMP Wed Sep 15 03:27:15 UTC 2010', 'i686')
</code></pre>
<p><code>getcwd()</code> 函数返回当前工作目录。<code>chdir(path)</code> 则是更改当前目录到 path。在例子中我们首先看到当前工作目录是 /home/shiyanlou，然后我们更改当前工作目录到 /Code 并再一次查看当前工作目录</p>
<pre><code>&gt;&gt;&gt; os.getcwd()
'/home/shiyanlou'
&gt;&gt;&gt; os.chdir('Code')
&gt;&gt;&gt; os.getcwd()
'/home/shiyanlou/Code'
</code></pre>
<p>所以现在让我们使用 os 模块提供的另一个函数来创建一个自己的函数，它将列出给定目录下的所有文件和目录</p>
<pre><code>def view_dir(path='.'):
    &quot;&quot;&quot;
    这个函数打印给定目录中的所有文件和目录
    :args path: 指定目录，默认为当前目录
    &quot;&quot;&quot;
    names = os.listdir(path)
    names.sort()
    for name in names:
        print(name, end =' ')
    print()
</code></pre>
<p>使用例子中的 view_dir() 函数</p>
<pre><code>&gt;&gt;&gt; view_dir('/')
.bashrc .dockerenv .profile bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var
</code></pre>
<p><strong>Requests 模块</strong></p>
<blockquote>
<p>Requests 一个非转基因的 Python HTTP 库，人类可以安全享用<br>
警告：非专业使用其他 HTTP 库会导致危险的副作用，包括：安全缺陷症、冗余代码症、重新发明轮子症、啃文档症、抑郁、头疼、甚至死亡</p>
</blockquote>
<p>第三方模块并不是默认的模块，意味着你需要安装它，我们使用 pip3 安装它</p>
<p>首先要安装 pip3</p>
<pre><code>sudo apt-get update
sudo apt-get install python3-pip
</code></pre>
<p>然后用 pip3 安装 requests</p>
<pre><code>sudo pip3 install requests
</code></pre>
<p>上面的命令会在你的系统中安装 Python3 版本的 Requests 模块</p>
<p><strong>获得一个简单的网页</strong></p>
<p>你可以使用 get() 方法获取任意一个网页</p>
<pre><code>&gt;&gt;&gt; import requests
&gt;&gt;&gt; req = requests.get('https://github.com')
&gt;&gt;&gt; req.status_code
200
</code></pre>
<p>req 的 text 属性存有服务器返回的 HTML 网页，由于 HTML 文本太长就不在这里贴出来了</p>
<p>使用这个知识，让我们写一个能够从指定的 URL 中下载文件的程序<br>
代码写入文件 /home/shiyanlou/download.py</p>
<pre><code>#!/usr/bin/env python3
import requests

def download(url):
    '''
    从指定的 URL 中下载文件并存储到当前目录
    url: 要下载页面内容的网址
    '''
    # 检查 URL 是否存在
    try:
        req = requests.get(url)
    except requests.exceptions.MissingSchema:
        print('Invalid URL &quot;{}&quot;'.format(url))
        return
    # 检查是否成功访问了该网站
    if req.status_code == 403:
        print('You do not have the authority to access this page.')
        return
    filename = url.split('/')[-1]
    with open(filename, 'w') as fobj:
        fobj.write(req.content.decode('utf-8'))
    print(&quot;Download over.&quot;)

if __name__ == '__main__':
    url = input('Enter a URL: ')
    download(url)
</code></pre>
<p>可以看到目录下已经多了一个 sample.txt 文件</p>
<p>你可能已经注意到了 <code>if __name__ == '__main__':</code> 这条语句，它的作用是，只有在当前模块名为 <code>__main__</code> 的时候（即作为脚本执行的时候）才会执行此 if 块内的语句。换句话说，当此文件以模块的形式导入到其它文件中时，if 块内的语句并不会执行</p>
<p>你可以将上面的程序修改的更友好些。举个例子，你可以检查当前目录是否已存在相同的文件名。os.path 模块可以帮助你完成这个</p>
<p><strong>argparse 命令行参数处理模块</strong><br>
你还记得 ls 命令吗，你可以传递不同的选项作为命令行参数。</p>
<p>这里是用到的模块是 sys，命令行传入的所有参数都可以使用 sys.argv 获取。如果希望对参数进行处理可以使用 argparse 模块，阅读这篇 <a href="https://docs.python.org/zh-cn/3/howto/argparse.html">文档</a> 学习。</p>
<h2 id="tab-补全">TAB 补全</h2>
<p>首先创建一个文件：~/.pythonrc ，文件内写入如下内容</p>
<pre><code>import rlcompleter, readline
readline.parse_and_bind('tab: complete')


history_file = os.path.expanduser('~/.python_history')
readline.read_history_file(history_file)

import atexit
atexit.register(readline.write_history_file, history_file)
</code></pre>
<p>下一步在 ~/.bashrc 文件中设置 PYTHONSTARTUP 环境变量指向这个文件</p>
<pre><code>export PYTHONSTARTUP=~/.pythonrc
</code></pre>
<p>现在，从今以后每当你打开 bash shell，你将会有 TAB 补全和 Python 解释器中代码输入的历史记录</p>
<p>要在当前 shell 中使用，source 这个 bashrc 文件</p>
<pre><code>source ~/.bashrc
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E6%A8%A1%E5%9D%97">模块</a></li>
<li><a href="#%E5%8C%85">包</a></li>
<li><a href="#%E9%BB%98%E8%AE%A4%E6%A8%A1%E5%9D%97">默认模块</a></li>
<li><a href="#tab-%E8%A1%A5%E5%85%A8">TAB 补全</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://y-rui.github.io/post/python-ji-chu-11-lei/">
              <h3 class="post-title">
                Python基础11-类
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/y-rui" target="_blank">y-rui</a>
  <a class="rss" href="https://y-rui.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
